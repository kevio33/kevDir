# 一、线程

## 	1.概述：

- 在JAVA中，用Thread类代表线程，所有线程对象，都必须是Thread类或者Thread类子类的实例。每个线程的任务就是执行一段顺序执行的代码，JAVA使用线程执行体来容纳这段代码。所以，我们创建线程时，主要是根据实际需求，编写放入线程执行体的代码。

- 在Java中，**每次程序运行至少启动2个线程**：一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。

- 线程总体分两类：用户线程和守候线程。


当所有用户线程执行完毕的时候，JVM自动关闭。但是守候线程却独立于JVM，守候线程一般是由操作系统或者用户自己创建的。

## 2.创建线程方式：

### 	(1)继承Thread类创建线程

​			**定义一个类继承Thread，重写run()方法:**

```java
public class ExtendThread extends Thread {
 
	private int i;
	
	public static void main(String[] args) {
		for(int j = 0;j < 50;j++) {
			
			//调用Thread类的currentThread()方法获取当前线程
			System.out.println(Thread.currentThread().getName() + " " + j);
			
			if(j == 10) {
				//创建并启动第一个线程
				new ExtendThread().start();
				
				//创建并启动第二个线程
				new ExtendThread().start();
			}
		}
	}
 
	public void run() {
		for(;i < 100;i++) {
			//当通过继承Thread类的方式实现多线程时，可以直接使用this获取当前执行的线程
			System.out.println(this.getName() + " "  + i);
		}
	}
}
```

### 	(2)实现Runnable接口

```java
Thread(Runnabletarget)  //Runnabletarget:：实现了Runnable接口的类的实例，Thread类也实现了Runnable接口，因此，从Thread类继承的类的实例也可以作为target传入这个构造方法。
Thread(Runnabletarget, String name)  //name:给线程命名
Thread(ThreadGroupgroup, Runnable target)  
Thread(ThreadGroupgroup, Runnable target, String name)//ThreadGroup group：当前建立的线程所属的线程组。如果不指定线程组，所有的线程都被加到一个默认的线程组中。  
Thread(ThreadGroupgroup, Runnable target, String name, long stackSize)//long stackSize：线程栈的大小，这个值一般是CPU页面的整数倍。如x86的页面大小是4KB.在x86平台下，默认的线程栈大小是12KB。  
```

**可见，实现了runnable接口也同样要将其作为参数放入thread构造函数，因为thread对象才是执行线程的调用体，只是其调用了runnable中的run方法**

```java
/** 
 * 实现Runnable接口的类 
 */  
public class RunnableImpl implements Runnable{  
    private Stringname;  
    public RunnableImpl(String name) {  
       this.name = name;  
    }  
    @Override  
    public void run() {  
       for (int i = 0; i < 5; i++) {  
           for(long k=0;k<100000000;k++);  
           System.out.println(name+":"+i);  
       }       
    }  
}  
   
/** 
 * 测试Runnable类实现的多线程程序 
 */  
public class TestRunnable {  
   
    public static void main(String[] args) {  
       RunnableImpl ri1=new RunnableImpl("李白");  
       RunnableImpl ri2=new RunnableImpl("屈原");  
       Thread t1=new Thread(ri1);  
       Thread t2=new Thread(ri2);  
       t1.start();  
       t2.start();  
    }  
}  
```



### 	(3)通过Callable和Future接口创建

从JAVA5开始，JAVA提供提供了Callable接口，该接口是Runnable接口的增强版，Callable接口提供了一个call()方法可以作为线程执行体，但call()方法比run()方法功能更强大，call()方法的功能的强大体现在：

**1、call()方法可以有返回值；**

**2、call()方法可以声明抛出异常；**

因为Callable并不是Runnable 接口的子接口，所以Callable对象不能直接作为Thread的target。因此就提供了Future接口来代表Callable接口里的call()方法返回值，并为Future接口提供了一个FutureTask实现类，该类实现了Future接口，并实现了Runnable接口，所以FutureTask可以作为Thread类的target，同时也解决了Callable对象不能作为Thread类的target这一问题。

```java
//在Future接口里定义了如下几个公共方法来控制与它关联的Callable任务：
1、boolean cancel(boolean mayInterruptIfRunning)：试图取消Future里关联的Callable任务；

2、V get()：返回Callable任务里call()方法的返回值，调用该方法将导致程序阻塞，必须等到子线程结束以后才会得到返回值；

3、V get(long timeout, TimeUnit unit)：返回Callable任务里call()方法的返回值。该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间后，Callable任务依然没有返回值，将会抛出TimeoutException异常；

4、boolean isCancelled()：如果Callable任务正常完成前被取消，则返回true；

5、boolean isDone()：如果Callable任务已经完成， 则返回true；
```

**使用步骤：**

```java
1、创建Callable接口实现类，并实现call()方法，该方法将作为线程执行体，且该方法有返回值，再创建Callable实现类的实例；

2、使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值；

3、使用FutureTask对象作为Thread对象的target创建并启动新线程；

4、调用FutureTask对象的get()方法来获得子线程执行结束后的返回值。
```

```java
public class ThirdThreadImp {
	
	public static void main(String[] args) {
		
		//这里call()方法的重写是采用lambda表达式，没有新建一个Callable接口的实现类
		FutureTask<Integer> task =  new FutureTask<Integer>((Callable<Integer>)()->{
			int i = 0;
			for(;i < 50;i++) {
				System.out.println(Thread.currentThread().getName() + 
						"  的线程执行体内的循环变量i的值为：" + i);	
			}
			//call()方法的返回值
			return i;
		});
		
		for(int j = 0;j < 50;j++) {
			System.out.println(Thread.currentThread().getName() + 
					" 大循环的循环变量j的值为：" + j);
			if(j == 20) {
				new Thread(task,"有返回值的线程").start();
			}
		}
		try {
			System.out.println("子线程的返回值：" + task.get());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
 
}
```

**调用FutureTask对象的get()方法，必须等到子线程结束以后，才会有返回值。**



## 3.启动线程:

​	在thread对象上调用start()方法。对Java来说，run()方法没有任何特别之处。像main()方法一样，它只是新线程知道调用的方法名称（和签名）。因此，在Runnable上或者Thread上调用run方法是合法的。但并不启动新的线程。

## 4.补充：

​	程序运行状态：

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150905033659802)

```java
    1、新状态：线程对象已经创建，还没有在其上调用start()方法。

    2、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。

    3、运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

    4、等待/阻塞/睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。

    5、死亡态：当线程的run()方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。
```



#### ①获取当前线程对象：

```java
Thread.currentThread();
```

#### 	②线程栈模型与线程变量：

线程栈是指某时刻时内存中线程调度的栈信息，**当前调用的方法总是位于栈顶**。线程栈的内容是随着程序的运行动态变化的，因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方)。

下面通过一个示例性的代码说明线程（调用）栈的变化过程。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150905033648798)

当程序执行到t.start();时候，程序多出一个分支（增加了一个调用栈B），这样，栈A、栈B并行执行。

#### ③阻止线程执行：

除开IO阻塞，线程阻止考虑以下三个方面：

##### 	**睡眠：**

```java
 Thread.sleep(longmillis);
 Thread.sleep(long millis, int nanos);
强制当前正在执行的线程休眠（暂停执行），以“减慢线程”。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。
    
 try {  
     Thread.sleep(123);  
 } catch (InterruptedException e) {  
     e.printStackTrace();   
 }  
```

**注意：线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就开始执行。但它并不释放对象锁。也就是说如果有synchronized同步快，其他线程仍然不能访问共享数据。注意该方法要捕捉异常。**

##### 	**等待：**

**void wait()** 在其他线程调用此对象的 notify() 方法或者 notifyAll()方法前，导致当前线程等待。

**void wait(long timeout)**在其他线程调用此对象的notify() 方法 或者 notifyAll()方法，或者超过指定的时间量前，导致当前线程等待。

**注意：**wait()后，线程**会释放掉它所占有的“锁标志”**，从而使线程所在对象中的其他synchronized数据可被别的线程使用。wait()和notify()因为会对对象的“锁标志”进行操作，所以他们必需在Synchronized函数或者 synchronized block 中进行调用。如果在non-synchronized 函数或 non-synchronized block 中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。。

```java
/** 
 * 计算输出其他线程锁计算的数据 
 */  
public class ThreadA {  
    public static void main(String[] args) {  
       ThreadB b=new ThreadB();  
       //启动计算线程  
       b.start();  
       //线程A拥有b对象上的锁。线程为了调用wait()或notify()方法，该线程必须是那个对象锁的拥有者  
       synchronized (b) {  
           try {  
              System.out.println("等待对象b完成计算......");  
              b.wait();  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
           System.out.println("b对象计算的总和是：" + b.total);  
       }  
    }  
}  
   
/** 
 * 计算1+2+3+...+100的和 
 */  
public class ThreadB extends Thread {  
    int total;  
    public void run(){  
       synchronized (this) {  
           for (int i=0;i<101;i++){  
              total+=i;  
           }  
           //（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程A被唤醒  
           notify();  
       }  
    }  
}  

结果：
等待对象b完成计算......  
b对象计算的总和是：5050  
```

notifyAll唤醒所以等待锁的线程

##### 	让步：

线程优先级：有1-10，默认为5，可以通过setPriority(priority)方法设置优先级

```java
Thread.yield();
暂停当前正在执行的线程对象，并执行其他线程。yield做的是让当前线程回到可运行状态，以允许相同优先级的其他线程获得运行机会，注意是相同优先级。但是实际过程中无法保证其让步目的，因为让步的线程还是可能被线程调度程序再次选中。
```

 **结论**：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。

##### 	合并（join）：

Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作

```java
Thread t = new MyThread();  
t.start();  
t.join();  
t.join(5000);让t之后线程等待5000毫秒，如果超过这个时间，则停止等待，变为可运行状态。
```

#### ④线程同步与锁

##### 	同步(synchronized)：

线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。

```java
public class Foo {  
    private int x = 100;  
    public int getX() {  
        return x;  
    }  
    public int fix(int y) {  
        x = x - y;  
        return x;  
    }  
}   
   
public class FooRunnable implements Runnable {  
    private Foo foo =new Foo();  
   
    public static void main(String[] args) {  
       FooRunnable r = new FooRunnable();  
        Thread ta = new Thread(r,"Thread-A");  
        Thread tb = new Thread(r,"Thread-B");  
        ta.start();  
        tb.start();  
    }  
   
    @Override  
    public void run() {  
       for (int i = 0; i < 3; i++) {  
            this.fix(30);  
            try {  
                Thread.sleep(1);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            System.out.println(Thread.currentThread().getName()+ " :当前foo对象的x值= " + foo.getX());  
        }  
    }  
   
    public int fix(int y) {  
       return foo.fix(y);  
    }  
}  
```

执行结果：

![image-20210429144852134](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210429144852134.png)

 从结果发现，这样的输出值明显是不合理的，原因是**两个线程不加控制的访问Foo对象并修改其数据所致**。如果要保持结果的合理性，只需要达到一个目的，就是将对Foo的访问加以限制，每次只能有一个线程在访问。这样就能保证Foo对象中数据的合理性了。

在具体的java代码中需要完成以下两个操作：

```java
把竞争访问的资源类Foo变量x标识为private；
同步修改变量的代码，使用synchronized关键字同步方法或代码。
```

##### 	

##### 	锁

​	原理：java中**每个对象都有一个内置锁**，加上了synchronized关键字的方法，获得对调用该方法的对象加锁，俗称“对象锁”。(**这里的对象加锁并非是说执行该加锁方法的时候整个对象的所有成员都不允许其他线程访问了,而是说该对象内所有的加锁的非静态方法共用这一把锁, 一个加锁非静态方法执行, 另一个加锁非静态方法不能执行,要等持有锁的线程释放锁, 不同对象之间的方法不互相作用**)；同样修饰静态方法时，该类获得“类锁”，该类中所有静态方法共用一把锁。

**注意：**1）只能同步方法，不能同步变量和类

​		   2）每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？

​	       3）不必同步类中所有的方法，类可以同时拥有同步和非同步方法。

​		   4）如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。

​		    5）同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。

​             6）在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如下：

```java
public int fix(int y) {  
       synchronized (this) {  
           x = x - y;  
       }  
       return x;  
   }  
```

同步方法也可改为非同步方法:

```java
public synchronized int getX() {  
    return x++;  
}
//等同于，效果完全一样
public int getX() {  
      synchronized (this) {  
          return x;  
      }  
  } 
```



#### 	⑤线程安全类

当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”即使是线程安全类，也应该特别小心，因为操作的线程之间仍然不一定安全。

举个形象的例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，删除集合中所有元素的时候。第二个线程也来执行与第一个线程相同的操作，也许在第一个线程查询后，第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了。

```java
public class NameList {  
    private List nameList = Collections.synchronizedList(newLinkedList());  
   
    public void add(String name) {  
        nameList.add(name);  
    }  
   
    public String removeFirst() {  
       if (nameList.size()>0) {  
       return (String) nameList.remove(0);  
       } else {  
           return null;  
       }  
    }    
}  
   
public class TestNameList {  
    public static void main(String[] args) {  
        final NameList nl =new NameList();  
         nl.add("苏东坡");  
         class NameDropper extends Thread{  
           @Override  
           public void run() {  
              String name = nl.removeFirst();  
                System.out.println(name);  
           }          
         }  
         Thread t1=new NameDropper();  
         Thread t2=new NameDropper();  
         t1.start();  
         t2.start();  
    }  
} 
```

结果：

```java
苏东坡  
null  
```

虽然集合对象是线程安全的，但是程序还不是线程安全，出现这种事件的原因，上例中一个线程操作列表过程无法组织另一个线程对列表的其他操作。解决办法是，在对集合对象操作时做一个同步：

```java
public class NameList {  
    private List nameList = Collections.synchronizedList(newLinkedList());  
   
    public synchronized void add(String name) {  
        nameList.add(name);  
    }  
   
    public synchronized StringremoveFirst() {  
       if (nameList.size()>0) {  
        return (String) nameList.remove(0);  
       } else {  
           return null;  
       }  
    }    
}
```

#### ⑥死锁

死锁对Java程序来说，是很复杂的，也很难发现问题。当两个线程被阻塞，每个线程在等待另一个线程时就发生死锁。

```java
public class Deadlock {  
    private static class Resource{  
       public int value;  
    }  
    private Resource resourceA=new Resource();  
    private Resource resourceB=new Resource();  
    public int read(){  
       synchronized (resourceA) {  
           synchronized (resourceB) {  
              return resourceB.value+resourceA.value;  
           }  
       }  
    }  
    public void write(int a,int b){  
       synchronized(resourceB){  
           synchronized (resourceA) {  
              resourceA.value=a;  
              resourceB.value=b;  
           }  
       }  
    }  
}  
```

假设read()方法由一个线程启动，write()方法由另外一个线程启动。读线程将拥有resourceA锁，写线程将拥有resourceB锁，两者都坚持等待的话就出现死锁。死锁没有解决办法，只有避免，这就需要在设计的时候让线程始终按照顺序获取锁这一策略

#### 	⑦守护线程

 守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。

```java
public final void setDaemon(boolean on)将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java虚拟机退出。  
```

**该方法必须在启动线程前调用。**

```java
/** 
 * Java线程：线程的调度-守护线程 
 */  
public class Test {  
    public static void main(String[] args) {  
       Thread t1=new MyCommon();  
       Thread t2=new Thread(new MyDaemon());  
       t2.setDaemon(true);//设置为守护线程  
       t2.start();  
       t1.start();        
    }  
}  
class MyCommon extends Thread{  
    @Override  
    public void run() {  
       for(int i=0;i<5;i++){  
           System.out.println("线程1第"+i+"次执行！");  
           try {  
              Thread.sleep(7);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
}  
class MyDaemon implements Runnable{  
    @Override  
    public void run() {  
       for (long i = 0; i < 9999999L; i++) {  
           System.out.println("后台线程第" + i +"次执行！");  
           try {  
              Thread.sleep(7);  
           } catch (InterruptedException e) {  
              e.printStackTrace();  
           }  
       }  
    }    
} 

结果：
线程1第0次执行！  
后台线程第0次执行！  
后台线程第1次执行！  
线程1第1次执行！  
后台线程第2次执行！  
线程1第2次执行！  
后台线程第3次执行！  
线程1第3次执行！  
后台线程第4次执行！  
线程1第4次执行！  
后台线程第5次执行！  
后台线程第6次执行！  
后台线程第7次执行！  
后台线程第8次执行！  
后台线程第9次执行！  
后台线程第10次执行！
```

​     从上面的执行结果可以看出：

​    前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。

​    实际上：JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台线程时候一定要注意这个问题。

#### ⑧volatile

volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。volatile可以用在任何变量前面（除了final变量）

##### 并发编程：

三个基本概念：

- 原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

  ```java
  原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：
  
  （1）基本类型的读取和赋值操作，且赋值必须是值赋给变量，变量之间的相互赋值不是原子性操作。
  
  （2）所有引用reference的赋值操作
  
  （3）java.concurrent.Atomic.* 包中所有类的一切操作
  ```

  

- 可见性：指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

  ```java
  在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
  ```

- 有序性：即程序执行的顺序按照代码的先后顺序执行。

```java
在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
```

##### volatile特性：

- 保证可见性，有序性，不保证原子性：（1）当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去。（2）这个写会操作会导致其他线程中的volatile变量缓存无效。
- 禁止指令重排序：

```java
重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：

 （1）重排序操作不会对存在数据依赖关系的操作进行重排序。

　 比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。

 （2）重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变

　 比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。

    重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。
 public class TestVolatile{
	int a = 1;
	boolean status = false;
	
	//状态切换为true
	public void changeStatus{
		a = 2;   //1
		status = true;  //2
	}
	
	//若状态为true，则为running
	public void run(){
		if(status){   //3
			int b = a + 1;  //4
			System.out.println(b);
		}
	}
 
}
即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。
```

## 5.线程池：

##### 	(1)概述：

 线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。

##### 	(2)使用：

###### 		①创建固定大小线程池：

```java
import java.util.concurrent.ExecutorService;  
import java.util.concurrent.Executors;  
   
/** 
 * Java线程：线程池 
 */  
public class Test {  
    public static void main(String[] args) {  
       //创建一个可重用固定线程数的线程池  
       ExecutorService pool =Executors.newFixedThreadPool(2);  
       //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口  
       Thread t1 = new MyThread();  
       Thread t2 = new MyThread();  
        Thread t3 = new MyThread();  
        Thread t4 = new MyThread();  
        Thread t5 = new MyThread();  
        //将线程放入线程池中进行执行  
        pool.execute(t1);  
        pool.execute(t2);  
        pool.execute(t3);  
        pool.execute(t4);  
        pool.execute(t5);  
        //关闭线程池  
        pool.shutdown();  
    }  
}  
class MyThread extends Thread{  
    public void run(){  
       System.out.println(Thread.currentThread().getName()+"正在执行...");  
    }  
}
```

结果：

```java
pool-1-thread-1正在执行...  
pool-1-thread-2正在执行...  
pool-1-thread-2正在执行...  
pool-1-thread-2正在执行...  
pool-1-thread-1正在执行...  
```

###### 	②创建单任务线程池：

```java
在上面代码基础上修改
//创建一个使用单个 worker线程的 Executor，以无界队列方式来运行该线程。  
ExecutorService pool=Executors.newSingleThreadExecutor();
```

结果：

```java
pool-1-thread-1正在执行...  
pool-1-thread-1正在执行...  
pool-1-thread-1正在执行...  
pool-1-thread-1正在执行...  
pool-1-thread-1正在执行...  
```

对于以上两种连接池，大小都是固定的，当要加入的池的线程（或者任务）超过池最大尺寸时候，则入此线程池需要排队等待。 一旦池中有线程完毕，则排队等待的某个线程会入池执行。

###### ③可变尺寸的线程池：

```java
//创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。  
ExecutorService pool=Executors.newCachedThreadPool();  
```

结果:

```java
pool-1-thread-2正在执行...  
pool-1-thread-4正在执行...  
pool-1-thread-1正在执行...  
pool-1-thread-3正在执行...  
pool-1-thread-5正在执行...
```

###### ④延迟线程池:

```java
/** 
 * Java线程：线程池 
 */  
public class Test {  
    public static void main(String[] args) {  
       //创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。  
        ScheduledExecutorService pool=Executors.newScheduledThreadPool(2);  
       //创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口  
       Threadt1 = new MyThread();  
       Threadt2 = new MyThread();  
        Thread t3 = new MyThread();  
        Thread t4 = new MyThread();  
        Thread t5 = new MyThread();  
        //将线程放入线程池中进行执行  
        pool.execute(t1);  
        pool.execute(t2);  
        pool.execute(t3);  
        //使用延迟执行风格的方法  
        pool.schedule(t4, 10, TimeUnit.MILLISECONDS);  
        pool.schedule(t5, 10, TimeUnit.MILLISECONDS);  
        //关闭线程池  
        pool.shutdown();  
    }  
}  
class MyThread extends Thread{  
    public void run(){  
       System.out.println(Thread.currentThread().getName()+"正在执行...");  
    }  
} 
```

结果:

```java
pool-1-thread-1正在执行...  
pool-1-thread-1正在执行...  
pool-1-thread-1正在执行...  
pool-1-thread-1正在执行...  
pool-1-thread-2正在执行... 
```

###### ⑤单任务延迟线程池：

```java
//创建一个单任务执行线程池，它可安排在给定延迟后运行命令或者定期地执行。  
ScheduledExecutorServicepool=Executors.newSingleThreadScheduledExecutor();  
```

