# 计算机网络基础知识

## 1.网络体系结构

**是计算机之间相互通信的层次，以及各层中的协议和层次之间接口的集合。1978年ISO提出了”异种机连网标准”的框架结构，这就是著名的开放系统互联基本参考模型 OSI/RM (Open Systems Interconnection Reference Modle),简称为 OSI 。**

**OSI参考模型用物理层、数据链路层、网络层、传输层、对话层、表示层和应用层七个层次描述网络的结构，它的规范对所有的厂商是开放的，具有指导国际网络结构和开放系统走向的作用。它直接影响总线、接口和网络的性能。常见的网络体系结构有FDDI、以太网、令牌环网和快速以太网等。从网络互连的角度看，网络体系结构的关键要素是协议和拓扑。**

### 	OSI模型：

#### 		①物理层**(PhysicalLayer)**

通过媒介传输比特,确定机械及电气规范，**机械特性**规定了网络连接时所需接插件的规格尺寸、引脚数量和排列情况等;**电气特性**规定了在物理连接上传输bit流时线路上信号电平的大小、阻抗匹配、传输速率距离限制等

```markdown
在这一层，数据的单位称为比特(bit)。物理层的主要设备:中继器、集线器、适配器.
```

#### 		②数据链路层**(DataLinkLayer)**

物理层提供比特流服务的基础上，**建立相邻结点之间的数据链路，通过差错控制提供数据帧(Frame)在信道上无差错的传输**，并进行各电路上的动作系列。

数据链路层在不可靠的物理介质上**提供可靠的传输**。该层的作用包括:物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。**将比特组装成帧和点到点的传递**

```markdown
在这一层，数据的单位称为帧(frame)。每一帧包括一定数量的数据和一些必要的控制信息.数据链路层主要设备:二层交换机、网桥。
```



#### 		③网络层**(Networklayer)**

在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。**网络层的任务就是选择合适的网间路由和交换结点**，确保数据及时传送。**网络层将数据链路层提供的帧组成数据包，包中封装有网络层包头，其中含有逻辑地址信息- -源站点和目的站点地址的网络地址。**

如果你在谈论一个IP地址，那么你是在处理第3层的问题，这是”数据包”问题，而不是第2层的”帧”。IP是第3层问题的一部分，此外还有一些路由协议和	。有关路由的一切事情都在第3层处理。地址解析和路由是3层的重要目的。网络层还可以实现拥塞控制、网际互连等功能。

```java
在这一层，数据的单位称为数据包(packet)。网络层主要设备:路由器
```



#### 	④传输层**(Transportlayer)**

第4层的数据单元也称作处理信息的传输层(Transport layer)。但是，当你谈论TCP等具体的协议时又有特殊的叫法，**TCP的数据单元称为段(segments)而UDP协议的数据单元称为”数据报(datagrams)”**。这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端(最终用户到最终用户)的**透明的、可靠的数据传输服务**。所谓透明的传输是指在通信过程中传输层对上层屏蔽了通信传输系统的具体细节。

**提供端到端的可靠报文传递和错误恢复**



#### 	⑤会话层**(Sessionlayer)**

这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的。

**建立、管理和终止会话**

#### 	⑥**表示层(Presentationlayer)**

这一层主要解决用户信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。例如图像格式的显示，就是由位于表示层的协议来支持。

**对数据进行翻译、加密和压缩**



#### 	⑦**应用层(Applicationlayer)**

应用层为操作系统或网络应用程序提供访问网络服务的接口。

**允许访问OSI环境的手段**



### TCP/IP分层：

#### 	①网络接口层（兼容物理层和数据链路层）

####     ②网际层

#### 	③运输层

#### 	④应用层

从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。

### 五层协议：

#### 	①物理层

#### 	②数据链路层

#### 	③网络层

#### 	④运输层

#### 	⑤应用层

## 2.**网络协议**

**是计算机网络和分布系统中互相通信的对等实体间交换信息时所必须遵守的规则的集合。**

| 层次       | 协议                                   |
| ---------- | -------------------------------------- |
| 物理层     | IEEE802.3 （中继器，集线器，网关）     |
| 数据链路层 | VLAN、MAC （网桥，交换机）             |
| 网络层     | IP、IPX、RIP、ARP、RARP、OSPF(路由器)  |
| 传输层     | TCP、UDP、SPX                          |
| 会话层     | NFS、SQL、NETBIOS、RPC                 |
| 表示层     | JPEG、MPEG、ASII                       |
| 应用层     | FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS |

<img src="https://gitee.com/kevinyong/kevin-gallery/raw/master/f58f6ad856c6802b636d20d8f5ba2c3e.jpeg" alt="太厉害了，终于有人能把TCP/IP 协议讲的明明白白了" style="zoom:150%;" />

### (1)端口号:

数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号。**端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址。**

一台计算机上同时可以运行多个程序。**传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序**，并准确地将数据传输。

![image-20210504170451748](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210504170451748.png)



**通过 IP 地址、端口号、协议号进行通信识别**

仅仅拼接端口号识别某一个通信是远远不够的

![image-20210504170724294](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210504170724294.png)

![image-20210504170741646](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210504170741646.png)

### (2)IP

### (3)TCP、UDP

#### 	①TCP：

（Transmission Control Protocol，传输控制协议）

TCP协议是面向**连接的，可靠地**，**面向字节流的**。

##### 如何保证传输的可靠性

- **连接管理机制：**

正常情况下，TCP要经过三次握手建立连接，四次挥手断开连接。

- **确认应答（ACK）机制：**

TCP会对每一个发送的字节进行编号，接收方接到数据后，会对发送方发送确认应答(***ACK报文***)，并且这个ACK报文中带有相应的确认编号(**序列号**)，告诉发送方，下一次发送的数据从编号多少开始发。如果发送方发送相同的数据，接收端也可以通过序列号判断出，直接将数据丢弃。

![image-20210929134437426](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/image-20210929134437426.png)

- **超时重传机制：**

如果主机A发送给主机B的数据因为网络拥堵等原因丢包了，数据无法到达主机B。
在特定时间内，主机A没有接收到主机B发送回来的ACK，就会把数据进行重发。

如果数据被重发之后还是没有收到接收方的确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长，直到最后关闭连接。

- **滑动窗口：**

因为加入了确认应答机制和超时重传机制，导致性能变差，为了提高性能，引入滑动窗口机制。

即两主机发送数据帧时，不是一帧帧的发送，而是每次发送指定窗口大小的数据帧（当然可以不满，窗口的大小取决于接收窗口和拥塞窗口中的较小值）。

- **流量控制：**

如果发送端发送的数据太快，接收端来不及接收就会出现丢包问题。为了解决这个问题，TCP协议利用了滑动窗口进行了流量控制。在TCP首部有一个16位字段大小的窗口，窗口的大小就是接收端接收数据缓冲区的剩余大小。接收端会在收到数据包后发送ACK报文时，将自己的窗口大小填入ACK中，发送方会根据ACK报文中的窗口大小进而控制发送速度。如果窗口大小为零，发送方会停止发送数据。

- **拥塞控制：**

如果网络出现拥塞，则会产生丢包等问题，这时发送方会将丢失的数据包继续重传，网络拥塞会更加严重，所以在网络出现拥塞时应注意控制发送方的发送数据，降低整个网络的拥塞程度。拥塞控制主要有四部分组成：慢开始、拥塞避免、快重传、快恢复。

##### 	三次握手（建立连接）:

首先看一下TCP头部的一些控制信息：

> - 序列号：seq，占32位，用来标识从发送端到接收端发送的字节流。它表示在这个报文段中的的第一个数据字节。
> - 确认号：ack，32位，只有ACK标志位为1时，收到的确认序号才有效，**确认序号（ack）**应当是上次已成功收到数据字节序号加1，表示下一次数据从哪里开始发送。
> - 标志位：
>   - SYN：发起一个新链接
>   - FIN：释放一个连接
>   - ACK：确认序号有效

- TCP 提供面向有连接的通信传输。面向有连接是指在数据通信开始之前先做好两端之间的准备工作。

- 所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。

  

  

  ![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20170607205709367)

- 第一次握手：客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。

- 第二次握手：服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。

- 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。

  

  

- ![太厉害了，终于有人能把TCP/IP 协议讲的明明白白了](https://gitee.com/kevinyong/kevin-gallery/raw/master/7b09f56589ba71b99fad5aeae19f363d.jpeg)



##### 四次挥手（终止TCP连接）：

- 四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。
- 由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。**首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。**

![太厉害了，终于有人能把TCP/IP 协议讲的明明白白了](https://gitee.com/kevinyong/kevin-gallery/raw/master/f0adfc32f118133170ad1a48b5a2eb58.jpeg)

- 中断连接端可以是客户端，也可以是服务器端。
- 第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
- 第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。
- 第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。
- 第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2ms后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20170606084851272)

#### ②UDP：

（User Data Protocol，用户数据报协议）

首先UDP协议是**无连接，不可靠**，面向数据报的。

**无连接：**知道对端的IP和端⼝号就直接进⾏传输, 不需要建⽴连接;
**不可靠：** UDP没有确认机制来确保报文的到达，没有对报文进行排序的机制，也不提供反馈信息来控制端到端报文传输的速度，所以它的传输是不可靠的。
**面向数据报：**不能够灵活的控制读写数据的次数和数量。

#### ③TCP长短链接

- **TCP短连接**: client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.短连接一般只会在 client/server间传递一次读写操
- **TCP长连接:** client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

### (4)HTTP

#### -http请求报文组成：

请求报文是由三部分组成：

- 请求行：
- 请求首部（Head）：
- 请求体

![HTTP请求报文结构](https://gitee.com/kevinyong/kevin-gallery/raw/master/c1e3fde69a1a96de96f3bf994628868db2e.jpg)



①请求行：以请求方法开头，空格分开，后面跟着请求URI和协议版，本号。

> 常用的请求方法有：
>
> | HTTP请求报文的方法 | 描述                                                         |
> | ------------------ | ------------------------------------------------------------ |
> | GET                | 获取资源                                                     |
> | POST               | 传输实体主体                                                 |
> | PUT                | 上传文件                                                     |
> | DELETE             | 删除文件                                                     |
> | HEAD               | 和GET方法类似，但只返回报文首部，不返回报文实体主体部分；向服务器请求URI资源的信息，确定资源的有效性 |
> | PATCH              | 对资源进行部分修改，对PUT的补充                              |
> | OPTIONS            | 返回请求URI资源所支持的方法                                  |
> | TRACE              | 确认客户端到服务器之间发生的转发和代理操作，不常用           |
> | CONNECT            | 要求用隧道协议连接代理，使用SSL和TLS加密后通信               |



GET 和 POST区别：

- 作用

  GET用户获取资源，POST用于传输实体主体

- 参数位置

  GET参数放在URL中，POST参数存储在实体主体中，并且GET方法提交请求的URL中的数据最多是2048字节，POST请求提交数据没有大小限制。

- 安全性：

  GET安全性相对POST差一些，因为参数是直接放在URL中

- 幂等性：

  GET方法具有幂等性的，而POST方法不具有幂等性。这里幂等性指[客户端]连续发出多次请求，收到的结果都是一样的.

```js
/*请求报文的例子*/
GET /chn/yxsz/index.htm HTTP/1.1 /*请求行使用相对URL*/     
Host:www.tsinghua.edu.cn        /*此行为首部行的开始，给出主机的域名*/ 
Connection:close               /*告诉服务器发送完请求的文档可释放连接*/                  
user-Agent:Mozilla/5.0        /*表明用户代理是使用Netscape浏览器*/ 
Accept-Language:cn           /*表示用户希望优先得到中文版本的文档*/
```





#### -HTTP版本及其区别

HTTP 1.0 /  HTTP 1.1  / HTTP 2.0

**①HTTP 1.0和HTTP 1.1的区别**

- 长链接

  HTTP 1.1支持长连接和请求的流水线操作。长连接是指不在需要每次请求都重新建立一次连接，HTTP 1.0默认使用短连接，每次请求都要重新建立一次TCP连接，资源消耗较大。

  > 请求的流水线操作是指[客户端]在收到HTTP的响应报文之前可以先发送新的请求报文，不支持请求的流水线操作需要等到收到HTTP的响应报文后才能继续发送新的请求报文。

- 缓存处理

  在HTTP 1.0中主要使用header中的If-Modified-Since,Expires作为缓存判断的标准，HTTP 1.1引入了Entity tag，If-Unmodified-Since, If-Match等更多可供选择的缓存头来控制缓存策略。

- 错误状态码

  在HTTP 1.1 新增了24个错误状态响应码

- HOST 域

  在HTTP 1.0 中认为每台服务器都会绑定唯一的IP地址，所以，请求中的URL并没有传递主机名。但后来一台服务器上可能存在多个虚拟机，它们共享一个IP地址，所以HTTP 1.1中请求消息和响应消息都应该支持Host域。

- 带宽优化及网络连接的使用

  在HTTP 1.0中会存在浪费带宽的现象，主要是因为不支持断点续传功能，[客户端]()只是需要某个对象的一部分，服务端却将整个对象都传了过来。在HTTP 1.1中请求头引入了range头域，它支持只请求资源的某个部分，返回的状态码为206。

**②HTTP 2.0的新特性**

- 新的二进制格式：HTTP 1.x的解析是基于文本，HTTP 2.0的解析采用二进制，实现方便，健壮性更好。

- 多路复用：每一个request对应一个id，一个连接上可以有多个request，每个连接的request可以随机混在一起，这样接收方可以根据request的id将request归属到各自不同的服务端请求里。

- header压缩：

  在HTTP 1.x中，header携带大量信息，并且每次都需要重新发送，HTTP 2.0采用编码的方式减小了header的大小，同时通信双方各自缓存一份header fields表，避免了header的重复传输。

- 服务端推送：[客户端]在请求一个资源时，会把相关资源一起发给[客户端]，这样[客户端]就不需要再次发起请求。



#### -http和https区别

|              | HTTP              | HTTPS                                   |
| ------------ | ----------------- | --------------------------------------- |
| 端口         | 80                | 443                                     |
| 安全性       | 无加密，安全性差  | 有加密机制，安全性较高                  |
| 资源消耗     | 较少              | 由于加密处理，资源消耗更多              |
| 是否需要证书 | 不需要            | 需要                                    |
| 协议         | 运行在TCP协议之上 | 运行在SSL协议之上，SSL运行在TCP协议之上 |

#### -对称加密和非对称加密：

- 对称加密

  对称加密指加密和解密使用同一密钥，优点是运算速度快，缺点是如何安全将密钥传输给另一方。常见的对称加密[算法]()有DES、AES等等。

- 非对称加密

  非对称加密指的是加密和解密使用不同的密钥，一把公开的公钥，一把私有的私钥。公钥加密的信息只有私钥才能解密，私钥加密的信息只有公钥才能解密。优点解决了对称加密中存在的问题。缺点是运算速度较慢。常见的非对称加密[算法]()有RSA、DSA、ECC等等。

  非对称加密的工作流程：A生成一对非对称密钥，将公钥向所有人公开，B拿到A的公钥后使用A的公钥对信息加密后发送给A，经过加密的信息只有A手中的私钥能解密。这样B可以通过这种方式将自己的公钥加密后发送给A，两方建立起通信，可以通过对方的公钥加密要发送的信息，接收方用自己的私钥解密信息。



#### -HTTPS加密过程：

上面已经介绍了对称加密和非对称加密的优缺点，HTTPS是将两者结合起来，使用的对称加密和非对称加密的混合加密[算法]。具体做法就是使用非对称加密来传输对称密钥来保证安全性，使用对称加密来保证通信的效率。

简化的工作流程：服务端生成一对非对称密钥，将公钥发给[客户端]。[客户端]生成对称密钥，用服务端发来的公钥进行加密，加密后发给服务端。服务端收到后用私钥进行解密，得到[客户端]发送的对称密钥。通信双方就可以通过对称密钥进行高效地通信了。

但是仔细想想这其中存在一个很大地问题，就是[客户端]最开始如何判断收到的这个公钥就是来自服务端而不是其他人冒充的？

这就需要证书上场了，服务端会向一个权威机构申请一个证书来证明自己的身份，到时候将证书（证书中包含了公钥）发给[客户端]就可以了，[客户端]收到证书后既证明了服务端的身份又拿到了公钥就可以进行下一步操作了。

HTTPS的加密过程：

1. [客户端]向服务端发起第一次握手请求，告诉服务端[客户端]所支持的SSL的指定版本、加密[算法]及密钥长度等信息。 
2. 服务端将自己的公钥发给数字证书认证机构，数字证书认证机构利用自己的私钥对服务器的公钥进行数字签名，并给服务器颁发公钥证书。 
3. 服务端将证书发给客服端。 
4. 客服端利用数字认证机构的公钥，向数字证书认证机构验证公钥证书上的数字签名，确认服务器公开密钥的真实性。 
5. 客服端使用服务端的公开密钥加密自己生成的对称密钥，发给服务端。 
6. 服务端收到后利用私钥解密信息，获得[客户端]发来的对称密钥。 
7. 通信双方可用对称密钥来加密解密信息。 

上述流程存在的一个问题是[客户端]哪里来的数字认证机构的公钥，其实，在很多浏览器开发时，会内置常用数字证书认证机构的公钥。

![图片说明](https://gitee.com/kevinyong/kevin-gallery/raw/master/D43554BAA12D549DCD55A28AD54B5934)

#### -常见状态码

| 状态码 | 类别             |
| ------ | ---------------- |
| 1xx    | 信息性状态码     |
| 2xx    | 成功状态码       |
| 3xx    | 重定向状态码     |
| 4xx    | 客户端错误状态码 |
| 5xx    | 服务端错误状态码 |

**1xx:**

- 100 Continue：正常，客户端可以继续发送请求
- 101 Switching Protocols：切换协议，服务器根据客户端请求切换协议

**2xx:**

- 200 OK ：200表示**请求在服务器端被正常处理**了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。
- 204 No Content： 204表示服务器接收的请求已经**成功处理**，但是在返回的**响应报文中不含实体的主体部分**。另外，也不允许返回任何实体的主体。当浏览器在发送请求后接收到204响应，它的显示页面不会发生更新。
- 206 Partial Content：206表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文内包含由Content-Range指定范围的实体内容。

**3xx：**

- 301 Moved Permanently: 永久重定向，301状态码表示请求的资源已经分配，以后请求该资源应该访问新的URI

- 302 Found：临时重定向，302表示请求的资源已经被分配了新的URI，希望客户端本次能使用新的URI访问。**和301不同的是，这种资源的URI变更是临时的额**，而不是永久的，因此不用去更新书签。

- 303 See Other：该状态码和 302 有着异曲同工之妙，表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。

  如果浏览器原本是用POST方法去请求服务器，收到303状态码之后，会改用GET并访问资源新的URI。

- 304 Not Modified：未修改。客户端请求的文档已在其缓存中，文档自缓存以来尚未被修改过。客户端使用文档的缓存副本，而不从服务器下载文档。

  >  例如，客户端请求的资源在客户端本地已有缓存，会在请求头部中加入“If-Modified-Since", "If-None-Match"等字段，服务端根据这些字段信息判断这些资源信息是否经过修改，如果没有则返回 304 状态码，客户端可以直接使用缓存中的资源。

- 305 Use Proxy：所请求的资源必须通过代理访问

- 307 Temporary Redirect: 临时重定向，和302有相同的含义，区别在于 307 不会强制浏览器将 POST 方法改为 GET 方法，而是遵循浏览器自身的标准。

**4XX：**

- 400 Bad Request:400 状态码**表示请求报文中存在语法错误**。当错误发生时，需修改请求的内容后再次发送请求。
- 401 Unauthorized: 401 状态码表示发送的请求需要通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。第一次收到 401 状态码表示需要进行用户认证，第二次再收到 401 状态码说明用户认证失败。
- 403 Forbidden: 表明对请求资源的访问被服务器拒绝了，当未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能发生 403
- 404 Not Found: 表示服务器无法找到请求资源，此外也可能是服务器端在拒绝请求且不想说明原因。
- 405 Method Not Allowed : 客户端请求中的方法被禁止
- 406 Not Acceptable ： 服务器无法根据客户端请求的内容特性完成请求。
- 408 Request Time-out: 服务器等待客户端发送的请求时长过长，超时

**5xx：**

- 500  Internal Server Error： 表明**服务器端在执行请求时发生了错误**。也有可能是 Web应用存在的 bug 或某些临时的故障。
- 501 Not Implemented ： 服务器不支持请求功能，无法完成请求。
- 502 Bad Gateway ： Web 服务器作为网关或代理服务器时，从上游服务器收到了无效响应。此类错误一般与服务器本身有关（与请求无关）。
- 503 Service Unavailable ： 表明**服务器暂时处于超负载或正在进行停机维护**，现在无法处理请求。





#### -浏览器输入url地址到显示主页过程：

①对输入到浏览器的url进行DNS解析，将域名转换为IP地址

②和目的服务器建立TCP连接

③向目的服务器发送HTTP请求

④服务器处理请求并返回HTTP报文

⑤浏览器解析并渲染页面



### (5)ARP协议

ARP协议属于网络层的协议，主要作用是实现从**IP地址转换为MAC地址。**在每个主机或者路由器中都建有一个`ARP缓存表`，表中有IP地址及IP地址对应的MAC地址。先来看一下什么时IP地址和MAC地址。



在网络层使用的是IP地址，在数据据链路层使用的是MAC地址。

网络层实现的是主机之间的通信，而链路层实现的是链路之间的通信，所以从下图可以看出，在数据传输过程中，IP数据报的源地址(IP1)和目的地址(IP2)是一直不变的，而MAC地址(硬件地址)却一直随着链路的改变而改变。



ARP工作流程：

①在局域网内，主机A要向主机B发送IP数据报时，首先会在主机A的ARP缓存表中查找是否有IP地址及其对应的MAC地址，如果有，则将MAC地址写入到MAC帧的首部，并通过局域网将该MAC帧发送到MAC地址所在的主机B。 

②如果主机A的ARP缓存表中没有主机B的IP地址及所对应的MAC地址，主机A会在局域网内广播发送一个ARP请求分组。局域网内的所有主机都会收到这个ARP请求分组。 

③主机B在看到主机A发送的ARP请求分组中有自己的IP地址，会像主机A以单播的方式发送一个带有自己MAC地址的响应分组。 

④主机A收到主机B的ARP响应分组后，会在ARP缓存表中写入主机B的IP地址及其IP地址对应的MAC地址。 

⑤如果主机A和主机B不在同一个局域网内，即使知道主机B的MAC地址也是不能直接通信的，必须通过路由器转发到主机B的局域网才可以通过主机B的MAC地址找到主机B。并且主机A和主机B已经可以通信的情况下，主机A的ARP缓存表中寸的并不是主机B的IP地址及主机B的MAC地址，而是主机B的IP地址及该通信链路上的下一跳路由器的MAC地址。这就是上图中的源IP地址和目的IP地址一直不变，而MAC地址却随着链路的不同而改变。 

⑥如果主机A和主机B不在同一个局域网，参考上图中的主机H1和主机H2，这时主机H1需要先广播找到路由器R1的MAC地址，再由R1广播找到路由器R2的MAC地址，最后R2广播找到主机H2的MAC地址，建立起通信链路。



### (6)ICMP

它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。



## 3.ip、网关、mac

### (1)ip地址

是用来唯一标识互联网上计算机的逻辑地址。每台连网计算机都依靠IP地址来标识自己，每一个不同的网络都要一个ip地址，所以电脑换网ip地址会变

### (2)网关

网关是内部局域网链接外部互联网的一个关口！ 就是路由器！！一个电脑可以有多个网关， 默认网关的意思是一台主机如果找不到可用的网关，就把数据包发送给默认指定的网关，由这个网关来处理数据包。从一个网络向另一个网络发送信息，也必须经过一道“关口”，这道关口就是网关。

```markdown
网络A和网络B相互通信，必须要经过网关，如果网络A中的某台终端a与网络B中的某台终端b相互通信，a会将数据首先转发给网络A的网关（192.168.1.1），然后转发到网络B的网关（192.168.2.1），最后才能将数据转发到终端b。
```

### (3)MAC地址

mac地址，又称为物理地址/局域网地址/网卡地址。它是一个用来确认网络设备位置的地址。在[OSI模型]中，第三层网络层负责[IP地址]，第二层数据链路层则负责MAC位址。MAC地址用于在网络中唯一标示一个[网卡]，一台设备若有一或多个网卡，则每个网卡都需要并会有一个唯一的MAC地址 。



### (4)