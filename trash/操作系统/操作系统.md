# 一、操作系统结构

**操作系统核心的东西是内核。**

## 1.内核

### 什么是内核

计算机是由各种外部硬件设备组成的，比如内存、cpu、硬盘等，如果每个应用都要和这些硬件设备对接通信协议，那这样太累了，所以这个中间人就由内核来负责，**让内核作为应用连接硬件设备的桥梁**，应用程序只需关心与内核交互，不用关心硬件的细节。

 ![内核](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/Kernel_Layout.png)  

### 内核具备能力

- **进程调度**：管理进程、线程，决定哪个进程、线程使用 CPU；
- **内存管理**：管理内存，决定内存的分配和回收；
- **硬件通信能力**：管理硬件设备，为进程与硬件设备之间提供通信能力；
- **提供系统调用**：如果应用程序要运行更高权限运行的服务，那么就需要有系统调用，它是用户程序与操作系统之间的接口。
- ......

### 如何工作

大多数操作系统，把**内存**分成了两个区域：

- **内核空间**：用于存放操作系统内核代码和数据的内存区域 ，这个内存空间只有内核程序可以访问；
- **用户空间**： 用于存放用户应用程序代码和数据的内存区域 ，这个内存空间专门给应用程序使用；

当程序使用用户空间时，常说该程序在**用户态**执行，而当程序使内核空间时，程序则在**内核态**执行。 

> - **用户态**：用户应用程序运行时的状态，在这个状态下，用户应用程序只能访问受限的系统资源，无法直接访问操作系统内核中的数据结构和代码。用户态下的程序运行速度较快，但是对系统资源的访问权限有限。
> - **内核态**： 指操作系统内核运行时的状态，在这个状态下，内核代码拥有最高的权限，可以访问所有的系统资源，包括硬件设备、内存和CPU等。内核态下的程序运行速度较慢，但是可以直接访问系统资源 。 

> 应用程序如果需要进入内核空间，就需要通过系统调用： ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E6%A0%B8/systemcall.png) 
>
> - 当应用程序使用系统调用时，会产生一个中断。
> - 发生中断后， CPU 会中断当前在执行的用户程序，转而跳转到中断处理程序，也就是开始执行内核程序。
> - 内核处理完后，主动触发中断，把 CPU 执行权限交回给用户程序，回到用户态继续工作。 





# 二、进程管理

## 1.进程

我们编写的代码通过编译后就会生成二进制可执行文件，当运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」（Process）**。 

### **并发**

对于一个支持多进程的单核CPU，CPU从一个进程快速切换到另一个进程，每个进程运行几十毫秒，这在宏观上看似并行，其实微观上时并发。

### 进程状态

**一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。** 

 ![进程的三种基本状态](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/7-%E8%BF%9B%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.jpg) 

如果加入创建和结束，那么就是：

![进程五种状态的变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg) 

> 当由大量阻塞状态进程时候，可能会导致内存浪费，因此在虚拟内存管理的操作系统中，会把阻塞状态的进程的物理内存空间换到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。 

需要一个新的状态，来**描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态**。 

![七状态](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg) 

### 进程的结构控制

在操作系统中，是用**进程控制块**（*process control block，PCB*）数据结构来描述进程的。  **PCB 是进程存在的唯一标识** 



### 进程的上下文切换

**一个进程切换到另一个进程运行，称为进程的上下文切换**。 

> 进程是由内核管理和调度的，所以**进程的切换只能发生在内核态**。 

**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。** 

> **进程上下文切换有哪些场景：**
>
> - 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
> - 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
> - 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
> - 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；
> - 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；



### 进程间通信

1. 管道（Pipe）：管道是一种半双工通信方式，它可以用于具有亲缘关系的进程之间的通信。管道有两种形式：匿名管道和命名管道。匿名管道只能用于具有亲缘关系的进程之间的通信，而命名管道则可以用于任意两个进程之间的通信。
2. 消息队列（Message Queue）：消息队列是一种用于进程间通信的内核数据结构，它可以用于无亲缘关系的进程之间的通信。消息队列允许进程向队列中发送和接收消息，每个消息都有一个特定的类型，接收进程可以根据消息类型来处理消息。
3. 共享内存（Shared Memory）：共享内存是一种允许多个进程访问同一块内存区域的机制。共享内存通常用于需要大量数据交换的进程间通信中，因为它可以减少数据拷贝的开销。
4. 信号量（Semaphore）：信号量是一种用于进程间同步和互斥的机制。信号量可以用于控制对共享资源的访问，以避免进程间的竞争条件。
5. 套接字（Socket）：套接字是一种用于网络通信的机制，它也可以用于进程间通信。套接字允许进程在网络上发送和接收数据，从而实现进程间的通信。
6. 远程过程调用（RPC）：远程过程调用是一种允许进程在网络上调用其他进程的函数或过程的机制。RPC可以用于实现分布式系统中的进程间通信。





## 2.线程

**线程是进程当中的一条执行流程。是程序执行的基本单位 **

### 线程的优点：

- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发执行；
- 各个线程之间可以共享地址空间和文件等资源；

### 线程上下文切换

线程的上下文切换开销，比进程上下文切换小得多。

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；

### 线程与进程比较

线程与进程的比较如下：

- 进程是资源（包括内存、打开的文件等）分配的单位，线程(严格来说是内核级线程)是 CPU 调度的基本单位；
- 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。 
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销；
- 线程的上下文切换比进程快得多，且开销也小很多



### 线程的实现

#### 用户级线程(ULT)

![1713077378403](操作系统.assets/1713077378403.png)

用户线程是基于用户态的线程管理库来实现的。 

**用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。** 不需要用户态/核心态切换，速度快。**内核对ULT无感知，线程阻塞则进程（包括它所有的线程）阻塞**

> **协程也可以看作是用户级线程**

##### 优点

- 每个进程都需要有它私有的线程控制块（TCB）列表，用来跟踪记录它各个线程状态信息（PC、栈指针、寄存器），TCB 由用户级线程库函数来维护，可用于不支持线程技术的操作系统；
- 用户线程的切换也是由线程库函数来完成的，无需用户态与内核态的切换，所以速度特别快；

##### 缺点

- 由于操作系统不参与线程的调度，如果一个线程发起了系统调用而阻塞，那进程所包含的用户线程都不能执行了。
- 当一个线程开始运行后，除非它主动地交出 CPU 的使用权，否则它所在的进程当中的其他线程无法运行，因为用户态的线程没法打断当前运行中的线程，它没有这个特权，只有操作系统才有，但是用户线程不是由操作系统管理的。
- 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会比较慢；





#### 内核级线程(KLT)

系统内核管理线程（KLT），内核保存线程的状态和上下文信息，线程阻塞不会引起进程阻塞。 **线程的创建、终止和管理都是由操作系统负责。**效率要比ULT慢，比进程操作快。 

> [Java线程是内核级线程](https://cloud.tencent.com/developer/article/2134440)

![1713077434380](操作系统.assets/1713077434380.png)

内核线程的**优点**：

- 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；
- 分配给线程，多线程的进程获得更多的 CPU 运行时间；

内核线程的**缺点**：

- 在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息，如 PCB 和 TCB；
- 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；



#### LWP

轻量级进程（Light-weight process，LWP）是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。 这种实现方式使得用户线程可以更好地利用多核处理器和其他硬件资源，提高程序的并发性和性能。 



### 多线程模型

#### 多对一

![1713077378403](操作系统.assets/1713077378403.png)

就是用户级线程那样，多个用户级线程映射到一个内核级线程，且一个进程只分配一个内核级线程

**优点**

用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

**缺点**

当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行



#### 一对一

![1713077434380](操作系统.assets/1713077434380.png)

一个用户级线程映射到一个内核级线程。每个用户进程有着与用户级线程同数量的内核级线程。

**优点**

当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

**缺点**

一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。



#### 多对多

![1713078269281](操作系统.assets/1713078269281.png)

n用户及线程映射到m个内核级线程（n>=m）。每个用户进程对应m个内核级线程。

**优点**

- 克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞）
- 又克服了一对一模型中，一个用户进程占用太多内核级线程，开销太大的缺点。



## 3.调度

cpu选择进程能够获取执行的机会，成为调度



### 调度的时机

当进程主动或被动放弃处理机的时候，处理机都会进行调度，例如：

- *从就绪态 -> 运行态*：当进程被创建时，会进入到就绪队列，操作系统会从就绪队列选择一个进程运行；
- *从运行态 -> 阻塞态*：当进程发生 I/O 事件而阻塞时，操作系统必须选择另外一个进程运行；
- *从运行态 -> 结束态*：当进程退出结束后，操作系统得从就绪队列选择另外一个进程运行；

> **不可以调度和切换的情况**
>
> - 处理中断的过程中
> - 进程在操作系统内核程序临界区中
> - 在原子操作过程中。（修改PCB中程序状态标志，并把PCB放到相应队列）

### 调度方式

**非抢占式调度**：只允许进程主动放弃处理机。在运行过程中即便有更紧迫任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。

**抢占式调度**：挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程。 这种抢占式调度处理，需要在时间间隔的末端发生**时钟中断**，以便把 CPU 控制返回给调度程序进行调度，也就是常说的**时间片机制**。 



### 调度算法

