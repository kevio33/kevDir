# 一、安卓

## 1.sp频繁操作会有什么后果?sp能存多少数据？

`sp( SharedPreferences )`的底层由xml来实现，操作sp的过程就是xml的序列化和解析。

- xml是存在磁盘上的， 频繁地读写 SP 会导致磁盘 IO 频繁，从而影响应用程序的性能 
- 另外`dvm`的内存是有限的，同时dvm的堆内存为16M所以不能超过此数字
-  SP 的存储空间不会太大，通常在几百 KB 到几 MB 之间，所有不适合存储大容量数据 



## 2.dvm与jvm的区别

**dvm**

DVM( Dalvik Virtual Machine ) 是 Android 操作系统中使用的一种虚拟机，它是为了在移动设备上运行 Java 代码而开发的。DVM 使用一种名为 `DEX（Dalvik Executable）`格式的中间代码，该中间代码是通过将 Java 字节码(.class文件)转换为 DEX 格式生成的。DVM 在运行时将 DEX 代码转换为机器码，然后执行该机器码。 

**jvm**

JVM 是 Java 语言的虚拟机，它负责运行 Java 字节码。JVM 是一种通用的虚拟机，可以在多种操作系统和硬件平台上运行。JVM 的设计目标是实现“写一次，到处运行”的概念，使得 Java 程序可以在不同的平台上运行。 

> **一个java文件从编码到执行需要经过下面几个阶段**
>
> 1、编译阶段：首先`.java`经过javac编译成`.class`文件
>
> 2、加载阶段：然后`.class`文件经过类加载器加载到JVM内存。
>
> 3、解释阶段：`class字节码`经过字节码解释器解释成系统可识别的指令码。
>
> 4、执行阶段：系统再向硬件设备发送指令码执行操作。

**两者区别**

DVM 与 JVM 有一些相似之处：

- 都使用垃圾回收机制来管理内存等。

DVM 与 JVM 也有一些不同之处：

- 例如 DVM 使用 DEX 格式的中间代码，而 JVM 使用 Java 字节码；
- DVM 在运行时将 DEX 代码转换为机器码，而 JVM 则直接执行 Java 字节码等。 
- JVM基于栈，需要去栈中读写数据；DVM基于寄存器





## 3.Context

> 参考——
>
> [activity、service、application与context区别](https://blog.csdn.net/qq475703980/article/details/88430891)
>
> [context](https://blog.csdn.net/guolin_blog/article/details/47028975)

 ![在这里插入图片描述](面题.assets/20190531205848781.jpg) 

> `Context`:是一个接口类，主要提供通用接口
>
> `ContextImpl`:Context接口的具体实现类
>
> `ContextWrapper`：Context的包装类，内部持有一个ContextImpl的实例对象mBase,对Context的操作最终都进入ContextImpl类
>
> `ContextThemeWrappe`r：该类内部包含了主题(Theme)相关的接口，即android:theme属性指定的。Service不需要主题，所以Service直接继承于ContextWrapper类。而Activity继承此类。



## 4.Application能不能启动Activity

可以开始一个Activity，但是它需要创建一个新的task 

```java
startActivity(intent,Intent.FLAG_ACTIVITY_NEW_TASK);
```



## 5.Android框架结构

回答framework相关的内容

Android平台架构组件如下：

 <img src="面题.assets/android-stack_2x.png" alt="Android 软件堆栈" style="zoom: 50%;" /> 

> **①Linux内核**
>
> Android 平台的基础是 Linux 内核。例如，`Android Runtime (ART)`依靠 Linux 内核来执行底层功能，例如线程和低层内存管理。使用 Linux 内核可让 Android 利用主要安全功能，并且允许设备制造商为著名的内核开发硬件驱动程序。
>
> **②硬件抽象层 (HAL)** 
>
> `硬件抽象层 (HAL)`提供标准界面，向更高级别的`Java API 框架`显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如[相机]或[蓝牙]模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。
>
> **③Android Runtime** 
> 对于运行 Android 5.0（API 级别 21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的 Android Runtime (ART) 实例。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少。编译工具链（例如 Jack）将 Java 源代码编译为 DEX 字节码，使其可在 Android 平台上运行。
>
> >  **ART 的部分主要功能包括：**
> >
> >  - 预先 (AOT) 和即时 (JIT) 编译
> >
> >  - 优化的垃圾回收 (GC)
> >
> >  - 在 Android 9（API 级别 28）及更高版本的系统中，支持将应用软件包中的 Dalvik Executable 格式 (DEX) 文件转换为更紧凑的机器代码。
> >
> >  - 更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置观察点以监控特定字段
> >
> >  在 Android 版本 5.0（API 级别 21）之前，Dalvik 是 Android Runtime。如果您的应用在 ART 上运行效果很好，那么它应该也可在 Dalvik 上运行，但反过来不一定。
> >
> >  Android 还包含一套核心运行时库，可提供 Java API 框架所使用的 Java 编程语言中的大部分功能，包括一些 Java 8 语言功能。
>
> > **Dalvik和ART的区别：**
> > `DALVIK `和 `ART` 都是 Android 系统使用的虚拟机，用于运行 Java 应用程序。两者的主要区别在于字节码的编译方式：
> >
> > - **Dalvik 使用 Just-In-Time (JIT，即时) 编译**，即在应用程序运行时，将字节码编译为机器码。这意味着应用程序的第一次运行会比较慢，但之后的运行会比较快。
> > - **ART 使用 Ahead-Of-Time (AOT，预先) 编译**，即在应用程序安装时，将字节码编译为机器码。这意味着应用程序的第一次运行会比较快，但应用程序的大小会更大。
> >
> > **除了字节码编译方式的区别外，两者还有以下一些区别：**
> >
> > - Dalvik 使用 Dex 文件格式，而 ART 使用 Odex 文件格式。
> > - Dalvik 使用 Dalvik 虚拟机堆，而 ART 使用 ART 虚拟机堆。
> > - Dalvik 使用 Dalvik 垃圾回收器，而 ART 使用 ART 垃圾回收器。
> >
> > 总体而言，ART 比 Dalvik 具有更好的性能和安全性，但应用程序的大小会更大。
> >
> > ```
> > 从 Android 5.0 (Lollipop) 开始，ART 成为了 Android 系统的默认虚拟机。
> > ```
>
> **④原生C/C++库**
>
> 许多核心 Android 系统组件和服务（例如 ART 和 HAL）构建自原生代码，需要以 C 和 C++ 编写的原生库。Android 平台提供 Java 框架 API 以向应用显示其中部分原生库的功能。例如，您可以通过 Android 框架的 Java OpenGL API 访问 OpenGL ES，以支持在应用中绘制和操作 2D 和 3D 图形。
>
> 如果开发的是需要 C 或 C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。
>
> **⑤Java API 框架 **
>
> 您可通过以 Java 语言编写的 API 使用 Android OS 的整个功能集。这些 API 形成创建 Android 应用所需的构建块，它们可简化核心模块化系统组件和服务的重复使用，包括以下组件和服务：
>
> - 丰富、可扩展的视图系统，可用以构建应用的 UI，包括列表、网格、文本框、按钮甚至可嵌入的网络浏览器
>
> - 资源管理器，用于访问非代码资源，例如本地化的字符串、图形和布局文件
>
> - 通知管理器，可让所有应用在状态栏中显示自定义提醒
>
> - Activity 管理器，用于管理应用的生命周期，提供常见的导航返回栈
>
> - 内容提供程序，可让应用访问其他应用（例如“联系人”应用）中的数据或者共享其自己的数据
>
> 开发者可以完全访问 Android 系统应用使用的框架 API。
>
> **⑥系统应用**
>
> Android 随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。平台随附的应用与用户可以选择安装的应用一样，没有特殊状态。因此第三方应用可成为用户的默认网络浏览器、短信 Messenger 甚至默认键盘（有一些例外，例如系统的“设置”应用）。
>
> 系统应用可用作用户的应用，以及提供开发者可从其自己的应用访问的主要功能。例如，如果您的应用要发短信，您无需自己构建该功能，可以改为调用已安装的短信应用向您指定的接收者发送消息。

## 6.View绘制过程



## 7.Canvas原理



## 8.Handler原理



## 9.安卓中的事件分发(事件如何一层层传到button上)

# 二、JAVA

## 1.运行时环境

**不同的数据存放区存放的数据和对应的管理方法是不同的。对于某些数据，如果在编译期间就可以确定数据对象的大小和数据对象的数目，在编译期间为数据对象分配存储空间，这些数据对应的存储分配策略是（）？**

**数据区可以分为：**

- **静态数据区**

- **动态数据区**：动态数据区可以分为`堆区`和`栈区`

> 之所以这样划分，是因为不同的数据存放区存放的数据和对应的管理方法是不同的。静态存储区、堆区和栈区的存储空间分配对应三种不同的策略，分别是静态存储分配、堆式存储分配以及栈式存储分配。

**选项解析：**

- 静态数据区对应的静态存储分配在编译期间为数据对象分配存储空间，这要求编译期间就可以确定数据对象的大小和数据对象的数目，所以`静态数据区`是正确的；

- 当数据的生存期与创建它的函数执行期无关时，比如某些数据可能在函数执行以后长期存在，堆式存储分配是一种灵活的存储方式，但缺点是代价可能比较昂贵，`堆式存储分配`是不符合题意的；

- 栈式存储分配通常用于可动态嵌套的程序结构，如过程、函数以及可嵌套程序块等，栈式存储分配将数据对象的运行存储按照栈的方式来管理，`栈式存储分配`是不符合题意的；

- 动态存储分配是一个统筹的概念，堆式存储分配和栈式存储分配都属于动态存储分配的范畴，所以`动态数据区`是不符合题意的。

## 2.JUC是什么

`JUC`是Java Util Concurrent的缩写，中文名为Java并发工具包。它是Java SE 5.0引入的一个用于简化多线程编程的工具包，位于java.util.concurrent包下。JUC包提供了许多用于管理线程、锁、Condition、并发集合、原子变量等的工具类，使得多线程编程变得更加简单和高效。 

**JUC包中的主要内容包括：**

1. 线程池（Executor）：提供了一种管理线程的方式，可以通过线程池来创建、管理和回收线程。
2. 锁（Lock）：提供了比synchronized关键字更灵活、更高效的锁机制，如ReentrantLock、ReadWriteLock等。
3. Condition：提供了更灵活的线程间通信和协调机制，如await()和signal()方法。
4. 并发集合（Concurrent Collection）：提供了许多线程安全的集合类，如ConcurrentHashMap、CopyOnWriteArrayList等。
5. 原子变量（Atomic Variable）：提供了一种在多线程环境下安全地更新变量的方式，如AtomicInteger、AtomicLong等。
6. 同步工具类（Synchronizer）：提供了一些用于控制多线程访问共享资源的工具类，如Semaphore、CountDownLatch等。

## 3.字节流和字符流区别？

`1字符 = 2字节` 、 `1字节(byte) = 8位(bit) ` 一个汉字占两个字节长度

- 字节流：每次读取(写出)一个字节，当传输的资源文件有中文时，就会出现乱码
- 字符流：每次读取(写出)两个字节，有中文时，使用该流就可以正确传输显示中文。

> **字符流的由来：** Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。

**处理单元不同：**

- 字节流：以字节为单位，可以处理任何类型的数据，如图片、音频、视频等二进制文件。 
- 字符流：以字符（Unicode码元）为单位，根据码表映射字符，一次可能读多个字节。 

**编码方式不同：**

- 字节流：但是字节流不考虑编码，处理二进制方面有优势
- 字符流：考虑数据的编码方式，如UTF-8、GBK等，在读写文本数据时需要指定正确的编码方式，否则可能会导致数据乱码。 

**是否设置缓冲区：**

- 字节流： **默认不使用缓冲区**，是文件本身直接操作的，这意味着每调用一次`read`方法都会请求操作系统来读取一个字节（这往往会伴随着一次磁盘IO，因此效率会比较低。要使用内存缓冲区以提高读取的效率，应该使用`BufferedInputStream`。 ），**字节流是与文件本身操作的，所以字节流操作文件时候，即使不关闭资源，文件也会输出。**
- 字符流： 由于字符流在输出前实际上是要完成Unicode码元序列到相应编码方式的字节序列的转换，所以它会使用内存缓冲区来存放转换后得到的字节序列，等待都转换完毕再一同写入磁盘文件中。 所以如果不调用flush或close方法，不会输出任何内容。

## 4. 线程池是被封装的，它底层创建线程并运行的核心原理是什么 

- 线程池的创建：线程池在创建时需要指定一些参数，如核心线程数、最大线程数、线程空闲时间、工作队列等。这些参数用于控制线程池的行为和性能。
- 任务的提交：当向线程池提交一个任务时，线程池会根据当前的状态和配置来决定如何处理这个任务。如果当前线程数少于核心线程数，则创建一个新线程来执行任务；如果当前线程数大于等于核心线程数，但小于最大线程数，则将任务放入工作队列中等待执行；如果工作队列已满，则创建一个新线程来执行任务；如果当前线程数已达到最大线程数，则根据拒绝策略来处理任务。
- 线程的创建和重用：线程池在创建线程时，会使用一个可重用的线程工厂来创建新线程。当一个任务执行完毕后，线程池不会立即销毁该线程，而是将其放入空闲线程队列中，等待下一个任务的到来。当一个新任务到来时，线程池会优先使用空闲线程队列中的线程来执行任务，以提高线程的重用率。
- 线程的管理和监控：线程池会不断地监控线程的状态和工作队列的情况，以便及时地创建新线程或销毁多余的线程。线程池还提供了一些监控和统计信息，如当前线程数、活动线程数、任务数等，用于监控和调优线程池的性能。



## 5. 最大线程和核心线程有什么区别 

1. 核心线程：**核心线程是线程池中永不会被回收的线程数量**。当向线程池提交一个新任务时，如果当前活动线程数小于核心线程数，则会创建一个新线程来执行任务，即使此时工作队列中还有空闲空间。如果当前活动线程数大于等于核心线程数，则会将任务放入工作队列中等待执行。核心线程数的大小会直接影响线程池的响应速度和吞吐量。
2. 最大线程：**最大线程是线程池中允许创建的最大线程数量**。当向线程池提交一个新任务时，如果当前活动线程数大于等于核心线程数，且工作队列已满，则会创建新线程来执行任务，直到活动线程数达到最大线程数为止。如果当前活动线程数已达到最大线程数，则根据拒绝策略来处理任务。最大线程数的大小会直接影响线程池的资源占用和稳定性。



## 6. isEmpty和size()==0

通常来说，`isEmpty()`方法和`size()==0`时间复杂度都是O(1) 

但在ConcurrentLinkedQueue、ConcurrentHashMap中，size()时间复杂度不是O(1)的，因此**工程实践上使用isEmpty()更加合适**。 



## 7.深拷贝、浅拷贝





# 三、数学

## 1.8个苹果（相同）3个箱子（不同），多少种分法

> 参考——https://zhuanlan.zhihu.com/p/92361742

如果给你8个苹果，要求把这些苹果放在3个盘子里。那么一共有多少种放法？这就是今天要讨论的苹果与盘子问题。由于8个苹果可以相同，也可以不同；3个盘子可以相同或不同；可以允许盘子空或者不空。所以一共有8种情况：

###  (1) **8个相同的苹果放在3个不同的盘子里，每个盘子至少一个苹果，请问一共有几种放法？** 

因为苹果均相同，盘子不同，相当于用2块板在8个苹果的7个空里插板。每次插板之后将苹果分为3份，每份对应一个不同的盘子，这就是插板法。所以共有`C(7,2)= 21`种放法。 



# 四、计算机网络

## 1.

![1711870685791](面题.assets/1711870685791.png)





## 2.http1.0/1.1/2.0之间的区别

`http1.0和http1.1`



## 3.http和https的区别