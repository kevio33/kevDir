

## 1.最长回文串

给定一个包含大写字母和小写字母的字符串 s ，返回**`通过这些字母构造成的最长的回文串 `。**在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。

> ```
> 输入:s = "abccccdd"
> 输出:7
> 解释:
> 我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
> ```
>
> ```
> 输入:s = "aaaaaccc"
> 输出:7
> ```

> 这道题是要**区分大小写字母求回文**，并且要注意，求这些字母能够构成的最长的回文串，所以对于出现次数奇数的字母，也能够加入到回文串中，因为能够凑成整数个
>
> ```java
> public int longestPalindrome(String s) {
>     int[] alphabet = new int[52];
>     for (int i = 0; i < s.length(); i++) {
>         char c = s.charAt(i);
>         if (c >= 'a') {
>             alphabet[c - 'a' + 26]++;// 小写字母
>         } else {
>             alphabet[c - 'A']++;// 大写字母
>         }
>     }
> 
>     int count = 0;//最大回文串长度
>     int oddCount = 0;// 记录最大奇数长度字母
>     for (int i = 0; i < 52; i++) {
>         if (alphabet[i] % 2 == 0)
>             count += alphabet[i];//如果是偶数次数的字母，直接可以构成回文
>         else {
>             if (oddCount != 0)
>                 count += Math.min(oddCount, alphabet[i]) - 1;//对于奇数次数字母，也可以构成回文，只是要变成偶数个再加入
>             oddCount = Math.max(oddCount, alphabet[i]);//取最大的奇数次字母，构成回文中间的数
>         }
>     }
> 
>     count += oddCount;//加上中间奇数次的字母数量
>     return count;
> }
> ```
>



## 2.最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```



**解题思路：**

> **暴力，O(n^3)**
>
> 遍历字串，然后判断是否是回文

> **动态规划，O(n^2)**
>
> 通过一个`boolean dp[i][j]`数组保存`i`到`j`之间的子串状态，如果是回文为true。
>
> 当`s[i] =s[j]`时候，**状态公式**就分为三个条件：
>
> - `i=j`，例如a，是回文
> - `i+1=j`，例如aa，是回文
> - `j-i>1`，此时s[i]=s[j]，因此只需要判断`dp[i+1][j-1]`的状态
>
> ```java
> if (s.charAt(i) == s.charAt(j)) {
>     if (j - i <= 1) {// i=j或i+1 = j,代表a，aa，那肯定是回文
>         dp[i][j] = true;
>     } else if (dp[i + 1][j - 1]) {
>         dp[i][j] = true;// 因为下标i==j了，所以只需要判断包裹在里面的字串是否是回文
>     }
> }
> ```
>
> **遍历顺寻**
>
> 因为要判断`dp[i][j]`，需要先判断`dp[i+1][j-1]`，因此`从下往上，从左往右`遍历
>
> ```java
> for (int i = length - 1; i >= 0; i--) {
>     for (int j = i; j < length; j++) {
>         if (s.charAt(i) == s.charAt(j)) {
>             if (j - i <= 1) {// i=j或i+1 = j,代表a，aa，那肯定是回文
>                 dp[i][j] = true;
>             } else if (dp[i + 1][j - 1]) {
>                 dp[i][j] = true;// 因为下标i==j了，所以只需要判断包裹在里面的字串是否是回文
>             }
>         }
>     }
> }
> ```
>
> 完整代码
>
> ```java
> public static String longestPalindrome(String s) {
> 
>     int length = s.length();
>     boolean dp[][] = new boolean[s.length()][s.length()];
>     int maxLength = 0;
>     int maxLeft = 0;
>     int maxRight = 0;
>     for (int i = length - 1; i >= 0; i--) {
>         for (int j = i; j < length; j++) {
>             if (s.charAt(i) == s.charAt(j)) {
>                 if (j - i <= 1) {// i=j或i+1 = j,代表a，aa，那肯定是回文
>                     dp[i][j] = true;
>                 } else if (dp[i + 1][j - 1]) {
>                     dp[i][j] = true;// 因为下标i==j了，所以只需要判断包裹在里面的字串是否是回文
>                 }
>             }
> 
>             // 判断是否是现在最长的字串
>             if (dp[i][j] && j - i + 1 > maxLength) {
>                 maxLength = maxLength < (j - i + 1) ? (j - i + 1) : maxLength;
>                 maxLeft = i;
>                 maxRight = j;
>             }
>         }
>     }
> 
>     // 返回最大的回文字串
>     return s.substring(maxLeft, maxRight + 1);
> }
> ```
>
> > 128ms
> >
> > 45.44MB

> **双指针扩散**
>
> 通过记录中间数，然后向两边扩散，找到回文串
>
> ```java
> public static String longestPalindrome(String s) {
> 
>     if (s.length() == 0 || s == null)
>         return "";
> 
>     // 回文字符特点，可以把中间部分看出都是同一字符，左右部分对称
>     int[] range = new int[2];// 记录起始位置
>     char[] str = s.toCharArray();
> 
>     for (int i = 0; i < s.length(); i++) {
>         i = findLongest(str, i, range);//中间数字
>     }
> 
>     return s.substring(range[0], range[1] + 1);
> 
> }
> 
> public static int findLongest(char[] str, int low, int[] range) {
>     // 查找中间重复的部分，例如aaaa
>     int high = low;
>     while (high < str.length - 1 && str[high + 1] == str[low]) {
>         high++;
>     }
>     
>     // 从中间向左右扩散
>     int ans = high;
>     while (low > 0 && high < str.length - 1 && str[low - 1] == str[high + 1]) {
>         low--;
>         high++;
>     }
> 
>     if (high - low > range[1] - range[0]) {//更新最大回文串的下标
>         range[0] = low;
>         range[1] = high;
>     }
>     return ans;
> }
> ```
>
> 

## 2.加油站

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i] `升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i] `升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 保证 它是 唯一 的。

> ```
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> ```
>
> ```
> 输入: gas = [2,3,4], cost = [3,4,3]
> 输出: -1
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。
> ```

> **1.自己题解，超时**
>
> ```java
> public int canCompleteCircuit(int[] gas, int[] cost) {
>     int i = 0;
>     int res = -1;
>     while (i < gas.length) {
>         if (gas[i] < cost[i]) {
>             i++;
>             continue;
>         }
>         int fuelCost = gas[i] - cost[i];
>         int j = i + 1;// 记录下标
>         boolean success = true;
>         while (j < cost.length) {
>             fuelCost += gas[j] - cost[j];
>             if (fuelCost < 0) {
>                 success = false;
>                 break;// 证明不可行
>             }
>             j++;
>         }
> 
>         j = 0;
>         if (success) {
>             while (j != i) {
>                 fuelCost += gas[j] - cost[j];
>                 if (fuelCost < 0) {
>                     success = false;
>                     break;// 证明不可行
>                 }
> 
>                 j++;
>             }
> 
>             if (success) {
>                 res = i;
>                 break;
>             }
>         }
> 
>         i++;
> 
>     }
>     return res;
> }
> ```
>
> **评论题解：**
>
>  重点就两句话： 
>
> - 两个数组之差的总和必须大于等于0，否则不能完成绕行 
> - 一个站的收益如果小于0，肯定不能作为起点；***而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过***，寻找下一个。 
>
> ```java
> public int canCompleteCircuit(int[] gas, int[] cost) {
>     int n = gas.length;
>     int total_tank = 0;
>     int curr_tank = 0;
>     int starting_station = 0;
>     for (int i = 0; i < n; ++i) {
>         //总和必须大于等于0，否则不能完成绕行
>         total_tank += gas[i] - cost[i];
>         curr_tank += gas[i] - cost[i];
>         if (curr_tank < 0) {
>             // 一个站的收益如果小于0，肯定不能作为起点；而连续的多个站也可以等效地看做一个站，如果其累积收益小于0，就跳过，寻找下一个。
>             starting_station = i + 1;
>             // 还原到初始状态
>             curr_tank = 0;
>         }
>     }
>     return total_tank >= 0 ? starting_ station : -1;
> }
> ```



## 3.最大数

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

> ```
> 输入：nums = [10,2]
> 输出："210"
> ```
>
> ```
> 输入：nums = [3,30,34,5,9]
> 输出："9534330"
> ```

> **①第一次写以为简单的字典序列排序，谁知道没这么简单，遇到特殊情况就会出问题：**
>
> > **比如30,3两个数的字典序列前者大于后者，所以最终结果是303，但其实330更大**
>
> ```java
> public static String largestNumber(int[] nums) {
> 
>         StringBuffer sb = new StringBuffer();
> 
>         String[] strNum = new String[nums.length];
>         for (int i = 0; i < nums.length; i++) {
>             strNum[i] = "" + nums[i];
>         }
> 
>         Arrays.sort(strNum);
> 
>         for (int i = strNum.length - 1; i >= 0; i--) {
>             sb.append(strNum[i]);
>         }
>         return sb.toString();
>     }
> ```
>
> **②看了题解，发现只需要重写比较器即可**
>
> ```java
> public String largestNumber(int[] nums) {
>     StringBuffer sb = new StringBuffer();
> 
>     String[] strNum = new String[nums.length];
>     for (int i = 0; i < nums.length; i++) {
>         strNum[i] = "" + nums[i];
>     }
> 
>     // 进行排序，并且制定排序规则
>     Arrays.sort(strNum, new Comparator<String>() {
>         @Override
>         public int compare(String o1, String o2) {
>             // 继承此方法的时候，要自定义比较器，conpareTo方法返回值为1(升序),0，-1(降序)。
>             // 返回正值 交换；负值不交换
>             return (o1 + o2).compareTo(o2 + o1);
>         }
>     });
> 
>     for (int i = strNum.length - 1; i >= 0; i--) {
>         sb.append(strNum[i]);
>     }
> 
>     if (sb.charAt(0) == '0')
>         return "0";
>     return sb.toString();
> }
> ```
>



## 4.去除重复字母

 给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。 

> ```
> 输入：s = "bcabc"
> 输出："abc"
> ```
>
> ```
> 输入：s = "cbacdcbc"
> 输出："acdb"
> ```

> 这道题最开始题目没看清，以为就是去除重复字母，其实还有要求是返回结果字典序列最小，并且不打乱其他字符相对位置，例如：`cdabcbbb`，`d`虽然这之中最大的字符，但是d只出现一次，所以最开始遇到就应该输出。
>
> 这道题使用栈就很好解决，每一次便利一个字符，如果该字符比栈顶元素小，并且还未遍历的子串中还存在该栈顶元素，那么就把该栈顶元素出栈，因为后面还会有该字符。
>
> ```java
> public String removeDuplicateLetters(String s) {
>     // 遇到一个新字符 如果比栈顶小 并且在新字符后面还有和栈顶一样的 就把栈顶的字符抛弃了
>     Stack<Character> stack = new Stack<>();
>     for (int i = 0; i < s.length(); i++) {
>         Character c = s.charAt(i);
>         if (stack.contains(c))//栈中只应该存在一个某字符
>             continue;
> 
>         // 遇到新字符比栈顶小，并且后面还有和栈顶一样的，那么就应该选用后面还未出现的栈顶相同字符
>         while (!stack.isEmpty() && stack.peek() > c && s.indexOf(stack.peek(), i) != -1)
>             stack.pop();
>         stack.push(c);
>     }
>     char chars[] = new char[stack.size()];
>     for (int i = 0; i < stack.size(); i++) {//遍历栈，其中的字符序列就是要得到的内容
>         chars[i] = stack.get(i);
>     }
>     return new String(chars);
> }
> ```

## 5.摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

> ```
> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
> ```
>
> ```
> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
> ```
>
> ```
> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2
> ```

> 这道题关键是记录上一次相邻元素差值正负，其实两个变量就可以记录，不用太复杂
>
> ```java
> public int wiggleMaxLength(int[] nums) {
>     if(nums.length<2)
>         return 1;
>     int up = 1;//记录满足差值大于零的
>     int down = 1;
>     for(int i = 1;i<nums.length;i++){
>         if(nums[i]>nums[i-1]){
>             up = down + 1;//累加down的
>         }
> 
>         if(nums[i]<nums[i-1]){//累加up的
>             down = up + 1;
>         }
>     }
>     return Math.max(down,up);
> }
> ```
>
> > 当然对于两个数符号相异的判断还可以采用`乘法`，看结果是否为负

## 6.种花问题

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false 。

> ```
> 输入：flowerbed = [1,0,0,0,1], n = 1
> 输出：true
> ```
>
> ```
> 输入：flowerbed = [1,0,0,0,1], n = 2
> 输出：false
> ```

> **解题思路：**
>
> 这道题最开始题目都没看懂，以为是在原数组基础上插，但是其实是在为0的基础上插。如果为0就代表可以插花。
>
> 这道题其实就是判断有没有连续的0号，如果存在三个连续的0号，那么就可以插一个花。
>
> ```
> 1,0,0,0,1// 可以插入一枝花
> ```
>
> **特殊情况：**
>
> 如果这里出现情况，比如说：
>
> `0,0,1,0,0`
>
> 这种情况，两边也可以插，但并不是连续三个0，所以要假设先在两边插入一个0，这样才可以判断上面出现的特殊情况。
>
> ```java
> public static boolean canPlaceFlowers(int[] flowerbed, int n) {
>         // 首位添加0，防止出现:0,0,1,0,1这种情况不能正确判断
>         int zeroCount = 1;
>         for (int i = 0; i < flowerbed.length; i++) {
>             if (n == 0)
>                 break;
> 
>             if (flowerbed[i] == 0) {
>                 zeroCount += 1;
>                 if (i == flowerbed.length - 1) {
>                     // 如果是最后一个，要判断特殊情况
>                     if (zeroCount >= 2 && n > 0) {
>                         n--;
>                     }
>                 } else {
>                     if (zeroCount == 3) {
>                         n--;
>                         zeroCount = 1;
>                     }
>                 }
>             } else {
>                 zeroCount = 0;
>             }
>         }
>         return n == 0 ? true : false;
>     }
> ```
>
> 
>
> 