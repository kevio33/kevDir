# 初级算法题归纳

## 一、数组

**1.买卖股票最佳时机**

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

```
例1：
输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

例2：
输入: prices = [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
     
例3：
输入: prices = [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```



**解题思路**

```java
其实这道题就是要求不能亏本，在股价跌之前就必须卖出。所以顾名思义就是只求股价上升时期差值相加，而不用考虑下降时期的值

解法一:
class Solution {
    public int maxProfit(int[] prices) {
        int ans=0;
        for(int i=1;i<=prices.length-1;i++)
        {
            if(prices[i]>prices[i-1])
            {
                ans+=prices[i]-prices[i-1];
            }
        }
        return ans;
    }
}

解法二：
//动态规划
```



**2.旋转数组**

给你一个数组，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

```
示例：
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```



**解题思路：**

```java
首先在保证空间复杂度为1的情况下，可以通过双循环，类似冒泡的形式交换，但是数字多了时间复杂度升高:
public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        for (int i = 0; i < k; i++) {
            int temp = nums[n - 1];
            for (int j = n - 1; j > 0; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = temp;
        }
    }

/*思路2：由于变换的总是后k个数字，所以将后k个数字放到前面k个位置，然后此时后面n-k个数字顺序还不对，需要在进行交换调整*/
[1,2,3,4,5,6] k=2
[5,6,3,4,1,2] 
[5,6,1,2,3,4]
    
/**
     * 翻转
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     */
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }


    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start++] = nums[end];
            nums[end--] = temp;
        }
    }

```



**3.存在重复元素**

给定一个整数数组，判断是否存在重复元素。

如果存在一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。



**解题思路:**

```java
/*可以先排序，然后从前往后进行比较，遇到重复的两个数值就返回false,但是若没有重复的或者重复的值在很后面时间复杂度就很高*/
 public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        int i = 1;
        while(i<nums.length){
            if(nums[i]==nums[i-1])return true;
            i++;
        }
        return false;
    }


/*思路二，由于set带有不允许出现重读的值，所以可以将数值存进set，若出现重读的值会返回false，最后在通过比较大小是否和原数组相同 */
 public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> hashSet = new HashSet<>();
        for (int num : nums) {
            if (hashSet.add(num) == false) {//若添加的数据重复，则返回false
                return true;
            }
        }
        return false;
    }
```



**4.只出现一次数字**

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

```java
输入: [2,2,1]
输出: 1
```



```java
解题思路：
因为是要找出只出现一次的数字，且保证线性时间复杂度和空间复杂度为1。就可以想到位运算（异或）：
    public int singleNumber(int[] nums) {

        if(nums.length==1)return nums[0];

        //思路：位运算，每个元素依次异或。最后剩下的数字肯定是计数的数字
        //i ^ 0 = i;
        //i ^ i = 0;
       int res = 0;

        for (int num : nums) {
            res = res ^ num;
        }
    
        return res;
        
    }
```





**5.两个数组的交集**

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```



```java
解题思路一：
这道题先排序，然后双指针进行比较，找到相同的的数字就存入哈希表，难点是要及时判断指针是否越界，其次是将哈希表的数字转换为数组，采用循环for in:
public int[] intersect(int[] nums1, int[] nums2) {

    //先排序
    Arrays.sort(nums1);
    Arrays.sort(nums2);

    int i = 0;
    int j = 0;
    List<Integer> list = new ArrayList();
    while(i<nums1.length && j<nums2.length){
        while(i<nums1.length&&nums1[i]<nums2[j])
            i++;

        while(j<nums2.length &&i<nums1.length&& nums2[j]<nums1[i])
            j++;

        if(i<nums1.length && j<nums2.length){
            if(nums1[i] == nums2[j]){
                list.add(nums1[i]);
                i++;
                j++;
            }
        }
    }
    j = 0;
    int[] a = new int[list.size()];
    for(int z : list){//转换为数组
        a[j++] = z;
    }

    return a;
}
```





**6.移动零**

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```



```java
解题思路1：
/*双指针，原数组基础上修改。
一前一后指针，前指针用于指向上一个为0的数字的数字，后指针指向下一个非零数字，前指针和后指针之间数字全部为零。否则一起共同向后走
*/
public void moveZeroes(int[] nums) {
    int n = nums.length, left = 0, right = 0;
    while (right < n) {
        if (nums[right] != 0) {//如果不为零则前后指针一起向后走
            swap(nums, left, right);
            left++;
        }
        right++;//如果为零，则找到下一个为零的数字
    }
}

public void swap(int[] nums, int left, int right) {
    int temp = nums[left];
    nums[left] = nums[right];
    nums[right] = temp;
}

解题思路2：
/*可以将非0数字按顺序找出来，然后最后添加零即可*/
```



**7.有效的数独**

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）

![image-20220112191343963](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20220112191343963.png)

```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```



```java
解题思路：
这道题，首先需要用三个二维数组存放每一列，每一行，每一个宫格块已经存在的数，每一次比较都会去判断是否是重复出现的数字，如果三者某一个出现则退出循环。！！难点在于：三行三列宫格的下标计算问题，是一个设计数学的知识
    
  public boolean isValidSudoku(char[][] board) {
        // 记录某行，某位数字是否已经被摆放
        boolean[][] row = new boolean[9][9];
        // 记录某列，某位数字是否已经被摆放
        boolean[][] col = new boolean[9][9];
        // 记录某 3x3 宫格内，某位数字是否已经被摆放
        boolean[][] block = new boolean[9][9];

        for(int i = 0;i<9;i++){
            for(int j = 0;j<9;j++){
                if(board[i][j]!='.'){
                    int num = board[i][j] -'1';//这里是存放对应数字
                    int blockIndex = i /3 * 3 + j / 3;//一共有9个宫格，那么对此进行标号，每一个宫格的计算方法。
                    if(row[i][num] || col[j][num] || block[blockIndex][num]){
                        return false;//出现重复立马退出循环
                    }else{
                        row[i][num] = true;//表明该行数字num+1已经存在
                        col[j][num] = true;
                        block[blockIndex][num] = true;
                    }
                }
            }
        }

        return true;

    }
```



**9.旋转图像：**

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

![image-20220112202500527](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20220112202500527.png)

![image-20220112202515935](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20220112202515935.png)



```java
解题思路：
将n纬矩形想象成n/2层正方形包裹，然后逐层进行交换
public void rotate(int[][] matrix) {
        int len = matrix.length;
        for (int i = 0; i < len / 2; i++) {//围成矩形正方形层数
            int start = i;//每一层其实坐标
            int end = len - i - 1;//每一层终止坐标
            for (int j = 0; j < end - start; j++) {//刚层的正方形进行交换
                int temp = matrix[start][start + j];
                matrix[start][start + j] = matrix[end - j][start];
                matrix[end - j][start] = matrix[end][end - j];
                matrix[end][end - j] = matrix[start + j][end];
                matrix[start + j][end] = temp;
            }
        }      
    }
```



## 二、字符串

**1.字符串中的第一个唯一字符**

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

```
s = "leetcode"
返回 0

s = "loveleetcode"
返回 2
```



解题思路：

```java
/*使用字符数组，下标为该字符的ASCII码。因为是要找到第一个不重复的字符，意思是可能存在多个不重复字符，所有不可避免的要
①先遍历存储所有字符出现次数；
②第二次再按照字符串的顺序遍历找出最小索引的那一个*/

 public int firstUniqChar(String s) {
     char[] map = new char[26];
     char[] chars = s.toCharArray();
     for (char c : chars) {
         map[c - 'a']++;
     }
     for (int i = 0; i < chars.length; i++) {
         if (map[chars[i] - 'a'] == 1)
             return i;
     }
     return -1;
 }
```



**2.有效的字母异位词**

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

```
输入: s = "anagram", t = "nagaram"
输出: true

输入: s = "rat", t = "car"
输出: false
```



```java
解题思路：
public boolean isAnagram(String s, String t) {

    /*由于是判断每一个字符出现的次数，那么肯定需要将整个字符串遍历完 
        1.首先判断两个字符串长度是否相同，不相同肯定不符合
        2.然后遍历s存进字符数组
        3.用t再来遍历，对应每个字符出现次数是否和s相同
        4.最后遍历记录的字符数组，是否都为0
        */

    int lengthS = s.length();
    int lengthT = t.length();

    if(lengthS != lengthT)return false;

    int[] array = new int[26];
    for(int i = 0;i<lengthS;i++){
        char sChar = s.charAt(i);
        char tChar = t.charAt(i);
        array[sChar-97]++;
        array[tChar-97]--; 
    }

    for(int j = 0;j<26;j++){
        if(array[j] !=0)return false;
    }

    return true;

}


优化版(用时减少百分之40%)：
public boolean isAnagram(String s, String t) {
    int lenS = s.length();
    int lenT = t.length();
    if (lenS != lenT) {
        return false;
    }
    int[] sCounts = new int[26];
    int[] tCounts = new int[26];
    for (char ch : s.toCharArray()) {
        sCounts[ch - 'a']++;
    }
    for (char ch : t.toCharArray()) {
        tCounts[ch - 'a']++;
    }
    for (int i = 0; i < 26; i++) {
        if (sCounts[i] != tCounts[i]) {
            return false;
        }
    }
    return true;
}
```



**3.字符串转换整数 (atoi)**

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 `atoi` 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。

```java
//示例1
输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。

    
//示例2
输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。


//示例3
输入：s = "4193 with words"
输出：4193
解释：
第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）
             ^
解析得到整数 4193 。
由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。


//示例4
输入：s = "words and 987"
输出：0
解释：
第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）
         ^
解析得到整数 0 ，因为没有读入任何数字。
由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。
```



```java
解题思路：
本题其实最重要的其实是字符串值转换为int类型的值，然后就是判断该值是否越界
    
 public int myAtoi(String str) {
    char[] chars = str.toCharArray();
    int n = chars.length;
    int idx = 0;
    while (idx < n && chars[idx] == ' ') {
        // 去掉前导空格
        idx++;
    }
    if (idx == n) {
        //去掉前导空格以后到了末尾了
        return 0;
    }
    boolean negative = false;
    if (chars[idx] == '-') {
        //遇到负号
        negative = true;
        idx++;
    } else if (chars[idx] == '+') {
        // 遇到正号
        idx++;
    } else if (!Character.isDigit(chars[idx])) {
        // 其他符号
        return 0;
    }
    int ans = 0;
    while (idx < n && Character.isDigit(chars[idx])) {
        int digit = chars[idx] - '0';//因为‘2’的ASCII码为50，所以要减去0
        if (ans > (Integer.MAX_VALUE - digit) / 10) {
            // 本来应该是 ans * 10 + digit > Integer.MAX_VALUE
            // 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。
            return negative? Integer.MIN_VALUE : Integer.MAX_VALUE;
        }
        ans = ans * 10 + digit;
        idx++;
    }
    return negative? -ans : ans;
}
```



**4.最长公共前缀**

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

```
输入：strs = ["flower","flow","flight"]
输出："fl"

输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```



```java
解题思路：

/*
先取第一个字符串当做他们的公共前缀
然后找出他和第2个字符串的公共前缀，然后再用这个找出的公共前缀分别和第3个，第4个……判断
*/
    
  public String longestCommonPrefix(String[] strs) {
        //边界条件判断
        if (strs == null || strs.length == 0)
            return "";
        //默认第一个字符串是他们的公共前缀
        String pre = strs[0];
        int i = 1;
        while (i < strs.length) {
            //不断的截取，只要不是从不是前缀，那么就要截取
            while (strs[i].indexOf(pre) != 0)
                pre = pre.substring(0, pre.length() - 1);
            i++;
        }
        return pre;
    }
```

>本题要搞清楚是求所有字符串的最长公共前缀，所以完全可以拿第一个作为标兵，因为第一个也是包含在里面的；
>
>此外本题难点在于：pre.substring(0,0) = "";//这是个值得关注的点



## 三、链表

**1.删除链表中的节点**

请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。

题目数据保证需要删除的节点 不是末尾节点 。

> ![img](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/node1.jpg)
>
> ```
> 输入：head = [4,5,1,9], node = 5
> 输出：[4,1,9]
> 解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9
> ```
>
> ![img](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/node2.jpg)
>
> ```
> 输入：head = [4,5,1,9], node = 1
> 输出：[4,5,9]
> 解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9
> ```



```java
解题思路：看到的很有意思的一个题解
目标：杀掉A

正常杀手需要找到A的把柄才可以杀掉A，
可现在找到A本人后竟然没有可以获取A把柄的途径
A得知我们要杀他，心生一计，可助你完成任务
A说我有B的把柄，你杀了B，我改头换面，以B的身份活着
GC也会自动清理掉B的尸体，没人会知道的

    
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;//当前值替换成下一个结点值
        node.next = node.next.next;//当前结点代替下一个结点指向下下结点
    }
}
```





**2.删除链表的倒数第N个节点**

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

> ![img](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/remove_ex1.jpg)
>
> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```
>
> ```
> 输入：head = [1], n = 1
> 输出：[]
> ```
>
> ```
> 输入：head = [1,2], n = 1
> 输出：[1]
> ```



```java
解题思路：
由于是删除倒数第n个结点，那么我们只需要保持前后指针间隔为n就行，当前指针到达最后一个结点的时候，后指针就是要删除的数字 
    
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {



        /*由于是删除倒数第n个结点，那么我们只需要保持前后指针间隔为n就行，当前指针到达最后一个结点的时候，后指针就是要删除的数字 */
        ListNode ahead = head;
        ListNode after = head;
        //ListNode listHead = head;//记录头结点
        int indexOfAfter = 0;

        while(ahead.next!=null){
            if(indexOfAfter>=n){//当前后指针相隔的距离不是n的话，那么后指针就不需要向前走
                
                after = after.next;
            }
            indexOfAfter++;
            ahead = ahead.next;
        }

        //判断只有一个结点的情况
        if(indexOfAfter==0){
            return null;
        }
        //判断删除的结点就是第一个结点的情况下
        if(indexOfAfter == n-1){
            head = head.next;
            return head;
        }

        after.next = after.next.next;

        return head;
    }
}
```





**3.反转链表**

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![img](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/rev1ex1.jpg)



```java
解题思路：
//迭代思想：消耗空间，节约时间，头插法
public ListNode reverseList(ListNode head) {
        //可以通过头插法来反转，这里采用迭代
        //list1-->list2-->list3
        //在list2插入值

        if(head==null)return null;

        ListNode list1 = new ListNode();
        ListNode list3;
        list1.next = new ListNode();
        list1.next.val = head.val;
        list3 = list1.next;
        head = head.next;

        //ListNode listHead = list1;

        while(head!=null){
            ListNode list2 = new ListNode(head.val);
            list2.next = list3;
            list3 = list2;
            list1.next = list3;
            head = head.next;
        }

        return list1.next;

    }


//上述版本的优化：每次访问的原链表节点都会成为新链表的头结点
public ListNode reverseList(ListNode head) {
    //新链表
    ListNode newHead = null;
    while (head != null) {
        //先保存访问的节点的下一个节点，保存起来
        //留着下一步访问的
        ListNode temp = head.next;
        //每次访问的原链表节点都会成为新链表的头结点，
        //其实就是把新链表挂到访问的原链表节点的
        //后面就行了
        head.next = newHead;
        //更新新链表
        newHead = head;
        //重新赋值，继续访问
        head = temp;
    }
    //返回新链表
    return newHead;
}

//也可以通过压栈的方式
public ListNode reverseList(ListNode head) {
    Stack<ListNode> stack = new Stack<>();
    //把链表节点全部摘掉放到栈中
    while (head != null) {
        stack.push(head);
        head = head.next;
    }
    if (stack.isEmpty())
        return null;
    ListNode node = stack.pop();
    ListNode dummy = node;
    //栈中的结点全部出栈，然后重新连成一个新的链表
    while (!stack.isEmpty()) {
        ListNode tempNode = stack.pop();
        node.next = tempNode;
        node = node.next;
    }
    //最后一个结点就是反转前的头结点，一定要让他的next
    //等于空，否则会构成环
    node.next = null;
    return dummy;
}

//尾递归：在链表递归的时候从前往后处理，处理完之后直接返回递归的结果，这就是所谓的尾递归
public ListNode reverseList(ListNode head) {
    return reverseListInt(head, null);
}

private ListNode reverseListInt(ListNode head, ListNode newHead) {
    if (head == null)
        return newHead;
    ListNode next = head.next;
    head.next = newHead;
    return reverseListInt(next, head);
}

```



**4.回文链表**

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

 ![img](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

```java
解题思路：
上面一题，我们做了反转链表，那么这道题就可以运用反转链表思想：
 -可以通过找到链表的中间节点然后把链表后半部分反转，
 -最后再用后半部分反转的链表和前半部分一个个比较即可。这里以示例2为例画个图看一下。
    
    
    
//当然，也可以通过栈来做，现将元素入栈，并且记录元素长度，然后在比较一般元素是否和后面半部分元素相同就行
```

![image.png](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/1603414119-KfHINu-image.png)

![image.png](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/1603414128-PsmRse-image.png)

```java
public boolean isPalindrome(ListNode head) {
    ListNode fast = head, slow = head;
    //通过快慢指针找到中点
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }
    //如果fast不为空，说明链表的长度是奇数个
    if (fast != null) {
        slow = slow.next;
    }
    //反转后半部分链表
    slow = reverse(slow);

    fast = head;
    while (slow != null) {
        //然后比较，判断节点值是否相等
        if (fast.val != slow.val)
            return false;
        fast = fast.next;
        slow = slow.next;
    }
    return true;
}

//反转链表
public ListNode reverse(ListNode head) {
    ListNode prev = null;
    while (head != null) {
        ListNode next = head.next;
        head.next = prev;
        prev = head;
        head = next;
    }
    return prev;
}
```



**使用栈**

```java
public boolean isPalindrome(ListNode head) {
    if (head == null)
        return true;
    ListNode temp = head;
    Stack<Integer> stack = new Stack();
    //链表的长度
    int len = 0;
    //把链表节点的值存放到栈中
    while (temp != null) {
        stack.push(temp.val);
        temp = temp.next;
        len++;
    }
    //len长度除以2
    len >>= 1;
    //然后再出栈
    while (len-- >= 0) {
        if (head.val != stack.pop())
            return false;
        head = head.next;
    }
    return true;
}
```





## 四、树

### **1.验证二叉搜索树**

给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。

有效 二叉搜索树定义如下：

节点的左子树只包含 小于 当前节点的数。
节点的右子树只包含 大于 当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

![image-20220224205447861](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/image-20220224205447861.png)

![image-20220224205501408](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/image-20220224205501408.png)



> 结题思路1：
> 这道题要搞懂什么是二叉搜索树：任意节点左子树都小于该结点，右子树大于该结点。但是要考虑到下面情况：
>
> ![image.png](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/1602255638-CdMLrU-image.png)
>
> **注意6这个节点不光要小于15而且还要大于10，所以这里的每一个节点都是有一个范围的**

```java
public boolean isValidBST(TreeNode root) {
    return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

public boolean isValidBST(TreeNode root, long minVal, long maxVal) {
    if (root == null)
        return true;
    //每个节点如果超过这个范围，直接返回false
    if (root.val >= maxVal || root.val <= minVal)
        return false;
    //这里再分别以左右两个子节点分别判断，
    //左子树范围的最小值是minVal，最大值是当前节点的值，也就是root的值，因为左子树的值要比当前节点小
    //右子数范围的最大值是maxVal，最小值是当前节点的值，也就是root的值，因为右子树的值要比当前节点大
    return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);
}
```



> 结题思路2：
>
> 利用中序遍历递归的方式：
>
> 中序遍历二叉搜索树，遍历的结果一定是有序的，判断当前节点是否大于中序遍历的前一个节点，也就是判断是否有序，如果不大于直接返回 false。
>
> ```java
> //前一个结点，全局的
> TreeNode prev;
> 
> public boolean isValidBST(TreeNode root) {
>     if (root == null)
>         return true;
>     //访问左子树
>     if (!isValidBST(root.left))
>         return false;
>     //访问当前节点：如果当前节点小于等于中序遍历的前一个节点直接返回false。
>     if (prev != null && prev.val >= root.val)
>         return false;
>     prev = root;
>     //访问右子树
>     if (!isValidBST(root.right))
>         return false;
>     return true;
> }
> ```
>
> 



### **2.二叉树的层序遍历**

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![image-20220224214411055](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/image-20220224214411055.png)

![image-20220224214422365](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/image-20220224214422365.png)



> 结题思路：
>
> 这道题利用BFS(广度优先搜索)来做是最合适的:
>
> 每一层的结点放入队列，然后再将他们按先进新出顺序取出放进list，然后在放入每一个结点的左右孩子结点。直至遍历完所有结点
>
> ![image.png](https://gitee.com/kevinyong/kevin-pic-gall2/raw/master/1597977711-ytedjZ-image.png)
>
> ```java
> public List<List<Integer>> levelOrder(TreeNode root) {
>     //边界条件判断
>     if (root == null)
>         return new ArrayList<>();
>     //队列
>     Queue<TreeNode> queue = new LinkedList<>();
>     List<List<Integer>> res = new ArrayList<>();
>     //根节点入队
>     queue.add(root);
>     //如果队列不为空就继续循环
>     while (!queue.isEmpty()) {
>         //BFS打印，levelNum表示的是每层的结点数
>         int levelNum = queue.size();
>         //subList存储的是每层的结点值
>         List<Integer> subList = new ArrayList<>();
>         for (int i = 0; i < levelNum; i++) {
>             //出队
>             TreeNode node = queue.poll();
>             subList.add(node.val);
>             //左右子节点如果不为空就加入到队列中
>             if (node.left != null)
>                 queue.add(node.left);
>             if (node.right != null)
>                 queue.add(node.right);
>         }
>         //把每层的结点值存储在res中，
>         res.add(subList);
>     }
>     return res;
> }
> ```



### 3.平衡二叉树

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

>  一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。 

**示例1：**

 ![img](初级算法.assets/balance_1.jpg) 

> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：true
> ```

**示例2：**

 ![img](初级算法.assets/balance_2.jpg) 

> ```
> 输入：root = [1,2,2,3,3,null,null,4,4]
> 输出：false
> ```

**示例3：**

> ```
> 输入：root = []
> 输出：true
> ```



**解题思路：**

使用两个递归进行判断，一个递归是遍历树，另一个递归是求树的高度

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null)
    		return true;

    	if(Math.abs(helper(root.left) - helper(root.right)) > 1){
    		return false;
    	}

    	return isBalanced(root.left) && isBalanced(root.right);
    }
	//求树的最高高度
    public int helper(TreeNode node){
    	if(node == null)
    		return 0;

    	int left = helper(node.left);
    	int right = helper(node.right);

    	return Math.max(left, right) + 1;
    }
}
```





## 五、动态规划

### 1.打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

**实例：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
偷窃到的最高金额 = 1 + 3 = 4 。
```

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

> 数组中的值表示的是存放的金额，小偷可以选择偷和不偷，如果前一个偷了，那么下一个肯定是不能偷的，因为相邻的房屋在同一晚上被小偷闯入，系统会自动报警。如果上一个没偷，那么下一个可以选择偷也可以选择不偷，视情况而定。
>
> 
>
> 这里可以定义一个二维数组`dp[length][2]`，其中`dp[i][0]`表示第i+1（因为数组下标是从0开始的，所以这里是i+1）家没偷的最大总金额，`dp[i][1]`表示的是第i+1家偷了的最大总金额。那么我们找出递推公式
>
> 
>
> 1，`dp[i][0]=max(dp[i-1][0],dp[i-1][1])`
>
> 他表示如果第i+1家没偷，那么第i家有没有偷都是可以的，我们取最大值即可。
>
> 2，`dp[i][1]=dp[i-1][0]+nums[i]`
>
> 他表示的是如果第i+1家偷了，那么第i家必须没偷，这里nums[i]表示的是第i+1家偷的金额。
>
> 
>
> 递推公式找出来之后我们再来看下边界条件，第一家可以选择偷，也可以选择不偷，所以
>
> `dp[0][0]=0`，第一家没偷
>
> `dp[0][1]=nums[0]`，第一家偷了
>
> ```java
> class Solution {
>     public int rob(int[] nums) {
>         if(nums==null || nums.length == 0)
>             return 0;
> 
>         int length = nums.length;
> 
>         int[][] arrays = new int[length][2];
> 
>         arrays[0][0] = 0;//第一家没有偷
>         arrays[0][1] = nums[0];//第一家偷了
> 
>         for(int i = 1;i<length;i++){
>             //i+1家没有偷，那么前面一家偷不偷都无所谓，选最大即可
>             arrays[i][0] = Math.max(arrays[i-1][0],arrays[i-1][1]);
>             //i+1家偷了，那么前面一家肯定不能偷，所以是加上前一家没有偷的总金额和这一家总金额
>             arrays[i][1] = arrays[i-1][0] + nums[i];
>         }
> 
>         return Math.max(arrays[length-1][0],arrays[length-1][1]);
>     }
> }
> ```
>
> 



### 2.爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

> 示例 1：
>
> 输入：n = 2
> 输出：2
> 解释：有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶
> 示例 2：
>
> 输入：n = 3
> 输出：3
> 解释：有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶
>
> 

```java
/*可以通过两种方式：递归和非递归
1.递归当数值越大，效率越低，重复计算很多
2.非递归采用动态规划思想和斐波拉契公式
*/

//一级台阶：f(1) = 1;
//二级台阶：f(2) = 2;
//三级台阶:f(3) = f(1)+f(2);
//n级台阶:f(n) = f(n-1)+f(n-2);

/*1.动态规划：非递归*/
public int climbStairs(int n) {
    if(n<=1)
        return 1;

    int dp[] = new int[n+1];
    dp[1] = 1;
    dp[2] = 2;
    for(int i = 3;i<=n;i++){
        dp[i] = dp[i-1]+dp[i-2];
    }

    return dp[n];
}
```



> **2.斐波拉契公式**
>
> ![image.png](%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E5%BD%92%E7%BA%B3.assets/ae684255d88d2094c9555b308b5fdb5fffb6a7876d9305c4020cf5a2579f4470-image.png)
>
> ```java
>  /*斐波拉契公式：1,1,2,3,5,8,13……
>  本题：1,2,3,5,8,13……，所以要从n+1项开始
>  
>  */
> public static int climbStairs(int n) {
>      double sqrt = Math.sqrt(5);
>      return (int) ((Math.pow((1 + sqrt) / 2, n + 1) - Math.pow((1 - sqrt) / 2, n + 1)) / sqrt);
>  }
> ```

### 3.买卖股票最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

> 示例 1：
>
> 输入：[7,1,5,3,6,4]
> 输出：5
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> 示例 2：
>
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

```java
/*这道题使用动态规划来实现*/
/*
首先定义一个状态数组：dp[length][2]:①dp[i][0]表示第i+1天（因为下标从0开始）不持有股票的最大利润；②dp[i][1]表示第i+1天持有股票的最大利润。

我们要求到在i+1天时候不持有股票(卖出股票)的最大利润就关注两种状态：
1.第i+1天既没有买也没有卖股票，那么最大利润就是第i天没有持有股票的利润dp[i-1][0]
2.第i+1天卖出了股票，那么最大利润就是第i天持有股票的利润(为负数)+第(i+1)天股票的价格

所以可以得出第i+1天不持有股票最大利润：
dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);
同理我们可以得出第i+1天结束的时候我们持有股票的最大利润
dp[i][1]=max(dp[i-1][1],-prices[i])；

边界条件就是第1天的时候，如果我们不持有股票，那么
dp[0][0]=0;
如果持有股票，那么
dp[0][1]=-prices[0];

*/

public int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0)
        return 0;
    int length = prices.length;
    int[][] dp = new int[length][2];
    //边界条件
    dp[0][0]= 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < length; i++) {
        //递推公式
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
    }
    //毋庸置疑，最后肯定是手里没持有股票利润才会最大，也就是卖出去了
    return dp[length - 1][0];
}
```







## 六、数学

### 1.计数质数

给定整数 `n` ，返回 *所有小于非负整数 `n` 的质数的数量* 。

示例 1：

输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
示例 2：

输入：n = 0
输出：0
示例 3：

输入：n = 1
输出：0



> 解题思路：
>
> 质数——大于1的自然数中，除了1和其本身不再有其他因数的数称为质数
>
> 本题可以通过***埃氏筛选***：
>
> ![image.png](%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E9%A2%98%E5%BD%92%E7%BA%B3.assets/1622705875-ssGHuW-image.png)
>
> ```java
>  public int countPrimes(int n) {
>      //质数是指大于1的自然数中，除1和其本身不在有其他因数的数
>      boolean[] arr = new boolean[n];
>      int cnt = 0;
>      for(int i = 2; i < n; i++) {
>          if(arr[i]) continue;
>          cnt++;
>          for(int j = i; j < n; j+=i) {
>              arr[j] = true;
>          }
>      }
>      return cnt;
> 
>  }
> ```
>



### 2.位1的个数

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/汉明重量)）。

```
> 提示：
>
> 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
> 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
```

> 示例1：
>
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
>
> 示例 2：
>
> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
>
> 示例 3：
>
> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。



```java
//解题思路：这道题解法非常多，主要是对“移位”的熟练运用，通过移位并做出运算来判断1的数量，下面主要是其中几种解法

//***解法一***
//把n往右移32次，每次都和1进行与运算
public int hammingWeight(int n) {
    int count = 0;
    for (int i = 0; i < 32; i++) {
        if (((n >>> i) & 1) == 1) {
            count++;
        }
    }
    return count;
}

//优化解法
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        count += n & 1;
        n = n >>> 1;
    }
    return count;
}

//***解法二***
//可以将1左移，然后与计算同样可以判断1的个数
public int hammingWeight(int i) {
    int count = 0;
    for (int j = 0; j < 32; j++) {
        if ((i & (1 << j)) >>> j == 1)
            count++;
    }
    return count;
}


//***解法三***
//每次消去最右边的1，直到消完为止
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        n &= n - 1;
        count++;
    }
    return count;
}

//解法三：递归形式
public int hammingWeight(int n) {
    return n == 0 ? 0 : 1 + hammingWeight(n & (n - 1));
}

//***解法四：存储形式，这一种形式没怎么弄明白***
//每两位存储，使用加法（先运算再移位）
public int hammingWeight(int n) {
    n = ((n & 0xaaaaaaaa) >>> 1) + (n & 0x55555555);
    n = ((n & 0xcccccccc) >>> 2) + (n & 0x33333333);
    n = (((n & 0xf0f0f0f0) >>> 4) + (n & 0x0f0f0f0f));
    n = n + (n >>> 8);
    n = n +  (n >>> 16);
    return n & 63;
}

//每3位存储，使用加法
public int hammingWeight(int n) {
    n = (n & 011111111111) + ((n >>> 1) & 011111111111) + ((n >>> 2) & 011111111111);
    n = ((n + (n >>> 3)) & 030707070707);
    n = ((n + (n >>> 6)) & 07700770077);
    n = ((n + (n >>> 12)) & 037700007777);
    return ((n + (n >>> 24))) & 63;
}
```



### 3.汉明距离

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

 >
 >
 >示例 1：
 >
 >输入：x = 1, y = 4
 >输出：2
 >解释：
 >1   (0 0 0 1)
 >4   (0 1 0 0)
 >          ↑   ↑
 >(上面的箭头指出了对应二进制位不同的位置。)
 >
 >示例 2：
 >
 >输入：x = 3, y = 1
 >输出：1



```java
//这道题和上一道题有结合地方，可以最后来计算位数为1的个数来得到结果
//因此首先将两个数字进行异或运算，得到他们二进制位不同的数字

public int hammingDistance(int x, int y) {
    //两数字做异或运算，然后得到的数字进行以为，类似算法“找出位1的数量”
    int count = 0;
    int temp =  x ^ y;
    while(temp != 0 ){
        count += temp & 1;
        temp  = temp >>>1;
    }

    return count;

}
```



### 4.颠倒二进制位

颠倒给定的 32 位无符号整数的二进制位。

> 示例 1：
>
> 输入：n = 00000010100101000001111010011100
> 输出：964176192 (00111001011110000010100101000000)
> 解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
>      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
>
> 示例 2：
>
> 输入：n = 11111111111111111111111111111101
> 输出：3221225471 (10111111111111111111111111111111)
> 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
>      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。



```java
//解题思路：可以通过每次取n最后一个数字放到temp的最后一位，然后移位重复
public int reverseBits(int n) {
    int res = 0;
    for(int i = 0;i<32;i++){
        //先把res左移存放n的最后一位
        res <<= 1;
        //再把n的最后一位放到res前一位
        res |= (n & 1);
        //n右移一位，去掉最后一位数字
        n >>= 1;
    }
    return res;
}
```



### 5.缺失的数字

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

> 	示例 1：
>
> 输入：nums = [3,0,1]
> 输出：2
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
> 示例 2：
>
> 输入：nums = [0,1]
> 输出：2
> 解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
> 示例 3：
>
> 输入：nums = [9,6,4,2,3,5,7,0,1]
> 输出：8
> 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
> 示例 4：
>
> 输入：nums = [0]
> 输出：1
> 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。



```java
/*题解：本质上通过判断数组中没有出现的数字，可以通过两种方式解决
1.异或运算：相同数字异或为0
2.减法：给定这个数组不缺失状态下总和，然后减去该数组，最终得到的就是缺失的
*/

 public int missingNumber(int[] nums) {
     //异或运算：
     //1.a^a=0;
     //2.a^0=a;
     int temp = 0;
     for(int i = 0;i<nums.length;i++){
         temp ^= nums[i] ^ (i+1);
     }

     return temp;
    }
```



### 6.Excel表列名称

给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

 **示例 1：** 

```
输入：columnNumber = 1
输出："A"
```

**示例 2：**

```
输入：columnNumber = 28
输出："AB"
```

**示例 3：**

```
输入：columnNumber = 701
输出："ZY"
```

**示例 4：**

```
输入：columnNumber = 2147483647
输出："FXSHRXW"
```



> **解题思路：**
>
> 这道题本质是一道`进制转换`的问题，10进制数转换为26进制数
>
> > 难点在于，用什么表示`A`进制数应该是多少，因为最后要得到的是Ascii码的字母，因此需要考虑得到的结果加上Ascii码是否能够正确表示这个数字。
> >
> > ```
> > 除以27行不行？
> > 1对应A，26对应Z，看起来像是27进位，似乎应该每次余27，每次除以27。
> > 但是，因为1对应A，而27对应的也是A，1%27=1, 27%27=0，同一个A余数不同，构成矛盾。
> > 
> > 那么除以26行不行？
> > 1%26=1,27%26=1，看起来这样似乎可以保持一致。
> > 但是当26%26的时候，为0，可是实际的值却为Z，又构成了新的矛盾。
> > 
> > 所以，我们调整对应关系，让0对应A，25对应Z，26对应AA，这样就构成了一个正常的26进位。
> > 这样对于A：0%26=0， 对于AA：26%26=0，在余数这里可以保持一致。
> > 新的对应关系是原先对应关系-1得到，所以在每次操作的时候，都要让columnNumber-1，得到新的对应关系。
> > ```
>
> ```java
> // 0代表A，1代表B，。。。。。
> // 26代表AA，27(十进制列数要减去1得到)代表AB
> public String convertToTitle(int columnNumber) {
> 
>     StringBuilder sb = new StringBuilder();
> 
>     while (columnNumber > 0) {
>         sb.insert(0, (char) ((columnNumber - 1) % 26 + 65));
>         columnNumber = (columnNumber - 1) / 26;
>     }
> 
>     return sb.toString();
> }
> ```
>
> 