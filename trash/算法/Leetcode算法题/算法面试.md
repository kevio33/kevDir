# 算法面试

## 一、前言

### 1.多数元素

给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。	

> **示例 1：**
>
> ```
> 输入：nums = [3,2,3]
> 输出：3
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [2,2,1,1,1,2,2]
> 输出：2
> ```

```java
/*两种解法*/

//1.题目说肯定存在多数元素，那么肯定就是指该数长度超过了数组大小一半，所以先排序，然后取中间的数字
public int majorityElement(int[] nums) {
    
    Arrays.sort(nums);
    return nums[nums.length/2];

}
    

 //2.摩尔投票法
public int majorityElement(int[] nums) {
    //假设数组中每个不同的数字就代表一个国家，而数字的个数就代表这个国家的人数，他们在一起混战，就是每
    //两个两个同归于尽。我们就可以知道那个人数大于数组长度一半的肯定会获胜。
    //就算退一万步来说，其他的所有人都来攻击这个人数最多的国家，他们每两个两个同归于尽，最终剩下的也是那
    //个众数。
    int more = nums[0];
    int count = 1;
    for(int i = 1;i<nums.length;i++){

        if(count==0){
            //没有人数了，就要重新赋值
            count++;
            more = nums[i];
        }else if(more == nums[i]){
            //自己人，加
            count++;
        }else{
            //不是自己人，减
            count--;
        }
    }

    return more;
}
```



### 2.搜索二维矩阵 II

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

> 示例 1：
>
> ![img](%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95.assets/searchgrid2.jpg)
>
> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
> 输出：true
>
> 
>
> 示例 2：
>
> ![img](%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95.assets/searchgrid.jpg)
>
> 输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
> 输出：false



```java
/*解题思路：
因为该矩阵特点：每行的元素从左到右升序排列。每列的元素从上到下升序排列。
所以可以将其看成一个排序二叉树，从左下或者右上开始遍历，
*/

public boolean searchMatrix(int[][] matrix, int target) {
    //类似二叉排序树，从左下或者右上找都可以
    //从右上开始找：左边的数都小于它，下边的数都大于它
    int col = matrix[0].length-1;
    int row = 0;
    while(col>=0 && row<=matrix.length-1){
        if(matrix[row][col] == target)
            return true;
        else if(matrix[row][col] > target){
            col--;//当该数大于目标数字时候，应该往左移动
        }else{
            row++;//当该数小于目标数字时候，应该往下移动
        }
    }

    return false;
}
```



