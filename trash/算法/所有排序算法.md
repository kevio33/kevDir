# 一、快速排序

基本思想：在待排序的n个记录中任取一个枢轴（一般取第一个），将该枢轴放到一个位置，原数据序列被划分成两部分，左边部分是比该枢轴小的数字序列，右边是比该枢轴大的数字序列，然后把该枢轴放到两部分的中间，这个过程称为一趟快速排序。之后分别对两个子序列递归进行快速排序

## 1.示意图:

![1617454778056](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1617454778056.png)

![1617454790657](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1617454790657.png)

## 2.算法要点：序列划分

确定枢轴记录（第一个数据）的位置使用到了序列划分的思想,分别从前往后进行比较，后面的比枢轴小的则放到前面，前面的比枢轴大的放到后面。

```c
void quickSort(int a[], int start, int end) {
	int temp;
	int s = start;
	int e = end;

	//确保元素有两个以上
	if (s < e) {
		temp = a[start];
		while (s < e)
		{
			//从后往前进行比较，把小的数放到前面
			while (s < e && temp < a[e])
				e--;
			if (s < e)
			{
				a[s++] = a[e];
			}

			//从前完后进行比较，把大的数放到后面
			while (s<e && temp> a[s])
				s++;
			if (s < e)
			{
				a[e--] = a[s];
			}
		}
		a[s] = temp;
		quickSort(a, start, s - 1);
		quickSort(a, s + 1, end);
	}
}
```



## 3.时间复杂度

> https://zhuanlan.zhihu.com/p/341201904

> 最好的情况是枢轴选取得当，每次都能均匀的划分序列。 时间复杂度`O(nlogn)`
>
> 在最坏的情况下，快速排序的时间复杂度为`O(n^2)`：这通常发生在被排序的数组已经是有序的或者接近有序的情况下。但是，**通过使用随机选择枢轴的优化策略，可以大大减少出现最坏情况的概率**，因此快速排序通常被认为是一种高效的排序算法。 



# 二、冒泡排序

## 1.思想：

两相邻元素进行大小比较，如果前者大于后者（要求排序后从小到大）则交换顺序，然后一直比较到最后一个元素。通过每一轮的比较可以得出剩余序列中最大的元素

### 	一轮排序：

​						 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/20180719164409828) 

​						 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/20180719164706462) 

​						 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/20180719170620133) 

​						 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/20180719170747630) 

​						 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/20180719170859672) 

​						 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/20180719165618104) 

## 2.核心代码：

### 双循环：外层负责记录遍历的次数，n个元素的序列一共需要遍历n轮

### 				   内层负责记录一轮遍历的次数。



## 3.代码

```c
/*从前往后遍历，升序*/
void bubbleSort(int a[],int length){
    int temp;
    for(int i = 0;i<length;i++){
        int flag = 0;//用于判断是否提前结束,如果在最终排序完成前已经是有序的就可以提前结束
        for(int j = 0;j<length-i;j++){
            if(a[j]>a[j+1]){
                temp = a[j];
                a[j] = a[j+1];
                a[j+1] = temp;
                flag = 1;
            }
        }
        if(flag == 0){
            return;
        }
    }
}
```

```c
/*从后往前遍历，升序*/
void bubbleSort2(int a[],int length){
    int temp;
    for(int i = 0;i<length;i++){
        int flag = 0;
        for(int j = length-1;j>=i;j--){
            if(a[j]<a[j-1]){
                temp = a[j];
                a[j] = a[j-1];
                a[j-1] = temp;
                flag = 1;
            }
        }
        if(flag == 0)
            return;
    }
}
```

> 冒泡排序的时间复杂度为`O(n^2)`：
>
> 其中n是被排序数组的长度。这是因为在最坏的情况下，冒泡排序需要进行n-1趟排序，每趟排序需要进行n-1次比较和交换操作。因此，总的比较和交换操作次数为`(n-1)+(n-2)+...+1`，约为`n^2/2`，因此时间复杂度为O(n^2)。 



# 三、归并排序

## 	1.思想:

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1024555-20161218163120151-452283750.png)

可以看到这种结构很像一棵完全二叉树，归并排序可以采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程，递归深度为`logn`。

再来看看**治**阶段：需要**将两个已经有序的子序列合并成一个有序序列**，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。

![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1024555-20161218194508761-468169540.png)

![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1024555-20161218194621308-588010220.png)

## 	2.要点：

就是**分和治**的思想，分成若干个序列，然后进行有序表合并操作

## 	3.代码：

```c
//分
void sort(int a[],int start,int end,int temp[]){
    //确保两个元素
    if(start<end){
        int mid = (start+end)/2;
        //先分成若干个序列
        sort(a,start,mid,temp);
        sort(a,mid+1,end,temp);
        //然后进行有序表的合并
        merge(a,start,mid,end,temp);
    }
}

//合并
void merge(int a[],int start,int mid,int end,int temp[]){
    int s = start;//左序列指针
    int m = mid+1;//右序列指针
    int t = 0;//临时数组指针
    //有序表合并
    while(s<=mid&&m<=end){
        if(a[s]<a[m]){
            temp[t++] = a[s++];
        }else{
            temp[t++] = a[m++];
        }
    }

    //将剩余没有拷贝的数据拷贝进去
    while(s<=mid){
        temp[t++] = a[s++];
    }

    while(m<=end){
        temp[t++] = a[m++];
    }

    //将序列放进原数组
    t = 0;
    while(start<=end){
        a[start++] = temp[t++];
    }
}
```

合并相邻有序子序列



## 4.时间复杂度

> https://www.cnblogs.com/tuyang1129/p/12857821.html

归并排序总时间=分解时间+子序列排好序时间+合并时间

无论每个序列有多少数都是折中分解，所以分解时间是个常数，可以忽略不计。

**则：归并排序总时间=子序列排好序时间+合并时间**

n个子序列：如果两两拆分，就犹如`满二叉树`，可以有`logn层`

每一层的子序列都需要排序，都遍历一遍，所以为`nlogn`

> O(nlogn)

# 四、直接插入排序

## 1.基本思想：

将原序列分为两个序列，左边为有序序列，右边为无序序列，每次从无序序列选第一个元素到有序序列进行排序

![1617526424298](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1617526424298.png)

## 2.代码：

```c
void insertSort(int a[],int length){
    int temp;
    for(int i = 1;i<length;i++){
        
        int j = i-1;
        temp = a[i];
        while(j>=0 && temp<a[j]){
            a[j+1] = a[j];//该元素大于temp，向后移
            j--;
        }
        a[j+1] = temp;//temp放入的位置
    }
}
```



## 3.时间复杂度

在最坏的情况下，输入数组完全逆序，此时直接插入排序的时间复杂度为 `O(n^2)`。

并且，直接插入排序的平均时间复杂度也为 `O(n^2)`





# 五、直接选择排序

## 1.思想: 	

将整个序列划分为两部分：有序序列和无序序列，每一次从无序序列选出最小的那一个数与无序序列第一个数进行交换。然后有序序列进行扩容。

> 序列：9 3 1 4 2 7 8 6 5
>
> 第一轮: 1 |  3 9 4 2 7 8 6 5
>
> 第二轮：1 2 | 9 4 3 7 8 6 5
>
> .....

```c
void selectSort(int a[],int length){
    int k,temp;
    for(int i = 0;i<length;i++){
        k = i;
        for(int j = i+1;j<length;j++){
            if(a[k]>a[j]){
                k = j;//记录无序序列最小的位置
            }
        }
        if (k!=i)//无序序列最小的数和无序序列第一个进行交换
        {
            temp = a[k];
            a[k] = a[i];
            a[i] = temp;
        } 
    }
}
```

## 2.时间复杂度

 时间复杂度为`O(n^2) `



# 六、堆排序

> [堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

## 1.堆的定义：

**堆是具有以下性质的`完全二叉树`：**

- **每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；**
- **每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。** 

 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1024555-20161217182750011-675658660.png) 

 ![img](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1024555-20161217182857323-2092264199.png) 

> 简单来说，堆的定义就是:
>
> **大顶堆：arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]**  ，根节点大于所有子节点
>
> **小顶堆：arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]**  ，根节点小于所有子节点



## 2.中心思想：

堆排序是一种`选择排序`。以大跟堆为例：

此时整个序列最大值就是根节点，然后交换根节点与**末尾元素(层序遍历最后一个节点)**，这样末尾就变为了最大值，然后将n-1个元素重新构造成一个堆，重复n-1次，最后得到一个有序序列（一般升序采用大根堆，降序采用小根堆）

```
步骤一:构造成大跟堆/小根堆
步骤二:交换堆顶元素和末尾元素，然后将剩下n-1个元素重新构造成堆
步骤三:重复第二步直到形成有序序列
```



## 3.代码:

```c
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        buildMaxHeap(nums, heapSize);//第一次要初始化为大根堆
        for (int i = nums.length - 1; i >= 0; --i) {
            swap(nums, 0, i);
            --heapSize;
            maxHeapify(nums, 0, heapSize);
        }
        return nums[0];
    }

    //构建大根堆
    public void buildMaxHeap(int[] a, int heapSize) {
        for (int i = heapSize / 2-1; i >= 0; --i) {
            maxHeapify(a, i, heapSize);//i代表当前节点索引
        } 
    }

    //调整大根堆元素
    public void maxHeapify(int[] a, int i, int heapSize) {
        int l = i * 2 + 1;//左儿子，这里下标以0开始，根节点为0
        int r = i * 2 + 2;//右儿子
        int largest = i;
        if (l < heapSize && a[l] > a[largest]) {//如果左儿子大于largest节点
            largest = l;
        } 
        if (r < heapSize && a[r] > a[largest]) {//如果右儿子大于largest节点
            largest = r;
        }
        if (largest != i) {//如果存在儿子节点大于父亲节点，那么交换顺序
            swap(a, i, largest);
            maxHeapify(a, largest, heapSize);
        }
    }

    //交换节点
    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

## 4.要点：

①在交换之前先要把无序数列调整为大跟堆，且从最后一个非叶子结点开始

②每一次交换之后都要重新调整根堆

③调整根堆的时候要注意判断该结点是否具有右子结点。



## 5.时间复杂度

它的最坏，最好，平均时间复杂度均为`O(nlogn) `

堆排序是一种选择排序，整体主要由：

**构建初始堆**+**交换堆顶元素和末尾元素并重建堆**

两部分组成。其中构建初始堆经推导复杂度为`O(n)`，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，`[log2(n-1),log2(n-2)...1]`逐步递减，近似为`nlogn `

# 七、基数排序

## 1.思想:

是一种非比较排序，在不限制内存情况下,对一群无序序列进行逐位比较，有下标为0-9的10个桶，先对个位进行比较，放入对应的桶中，然后在对十位比较，放入对应桶中，最大的数有几位就进行几次循环比较。最后得到排序结果;

![1617707852910](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/1617707852910.png)

利用二维数组来对每次比较的结果进行临时存储：

- 第一个下标表示对应的位上的数字
- 第二个下标对应在该位上的位置。

```c
a[k][index] 
/*
例:a[0][2]表示该趟比较位数是0的第二个元素
*/
```

> 此外，还需要一个`count[]`用来记录每一个桶元素个数

 ![img](所有排序算法.assets/radixSort.gif) 



## 2.代码

```c
//用来统计无序序列中数字最高位是多少
int maxPlace(int a[],int length){
    int count = 1;
    int max = 0;
    for (int  i = 0; i < length; i++)
    {
        int temp = a[i];
        while(temp / 10 > 0){
            temp = temp / 10;
            count++;//记录位数
        }
        if(max<count){
            max = count;
            count = 1;
        }

    }
    return max;//返回最大的位数，接下来依据它进行循环次数
}

//
void radixSort(int a[],int length){
    int max = maxPlace(a,length);//获取最大的位数
    int num = 1;
   
    for(int i = 0;i<max;i++){
        int count[10];//用于统计数量
        int temp[10][a.length];
         
        //初始化两个数组
        for (int m = 0; m < 10; m++){
            count[m] = 0;
            for(int j = 0;j<10;j++){
                temp[m][j] = 0;
            }
        }

        //进行统计
        for(int j =0;j<length;j++){
            int kg = a[j] / num;//num是一个变量，因为每一次比较的位数不同
            int k = kg % 10;//求a[j]对应位(个位/十位/百位/)的数字
            count[k]++;//统计该桶里面数字个数
            int te = count[k]-1;
            temp[k][te] = a[j];
        }
        int b = 0;
        for(int h = 0;h<10;h++){
            if(count[h]>0){//说明该桶里面有数字
                for(int j = 0;j<count[h];j++){
                    a[b] = temp[h][j];
                    b++;
                }
            }
        }
        num = num * 10;
    }
}
```



## 3.时间复杂度

基数排序需要遍历每个数字的每一位，因此其时间复杂度与被排序数组中的数字位数有关。 

假设被排序数组中的数字位数为 k，那么基数排序的时间复杂度为 `O(n*k)`，其中 n 是数组中的元素个数。由于 k 通常比 n 小得多，因此基数排序的时间复杂度通常比 `O(n^2)` 更低 





# 八、希尔排序

## 	1.算法思想:

其工作原理是定义一个**间隔序列**来表示排序过程中进行比较的元素之间有多远的**间隔**，每次将具有**相同间隔的数分为一组，进行插入排序**，大部分场景中，间隔是可以提前定义好的，也可以动态生成

**希尔排序的实质就是分组的插入排序**

## 	2.优缺点

**优点：**
空间复杂度较好，O(1)；作为改进版的插入排序，是一种相对高效的基于交换元素的排序方法。
**缺点：**
(i) 不稳定，在交换的过程中，会改变元素的相对次序。
(ii) 希尔排序的时间复杂度依赖于增量序列函数，所以分析起来比较困难，当n在某个特定范围的时候，希尔排序的时间复杂都约为O(n1.3)

## 	3.演示

最原始的那种增量，即从 gap=length/2 逐步减半，其实这还不算最快的希尔，有几个增量在实践中表现更出色

![在这里插入图片描述](%E6%89%80%E6%9C%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.assets/20190107113756741.png)

## 4.代码

```c
void shellSort(int a[],int length){
    int gap = length / 2;
    int temp;
    for(gap;gap>0;gap /= 2){//排序次数
        for(int i = gap;i<length;i++){//直接插入排序
            temp = a[i];
            int j = i;
            while((j-gap)>=0&&temp<a[j-gap]){//拿i这个位置的数和前面数进行直接插入排序，所以是temp比较
                a[j] = a[j-gap];
                j = j-gap;
            }
            a[j] = temp;//找到该元素放的位置
        }

    }
}
```



# 九、计数排序

> https://www.runoob.com/w3cnote/counting-sort.html



# 十、桶排序

> https://www.cnblogs.com/bigsai/p/13396391.html