> [MVC/MVP/MVVM](https://juejin.cn/post/6901200799242649607)

# 1.概述

这三个架构模式，都分别有三个不同的部件，都有相同的 **Model** 层和 **View** 层。Model 为模型层，主要管理业务模型的数据和行为；View 为展示层，其职责就是管理用户界面。三个架构模式目的都是为了解耦 Model 和 View，主要不同点就在于三者实现解耦的方案不同。

# 2.MVC

**MVC = Model-View-Controller** 

- Model

> **Model = 数据 + 业务逻辑**。因此，**处理业务逻辑属于 Model 的职责，而非 Controller**。
>
> 从数据的维度来说，可以细分为:
>
> - 数据的定义：定义数据结构，一般用实体类来定义，以方便在不同角色间传递数据
> - 数据的存储：数据的存储和获取则可能有几种途径：数据库、网络或缓存等。因此，**在实际应用中，一个 Model 并不只是简单的一个对象，而是一个更广泛的层级。**
> - 数据的获取
>
> 很多时候，会将 Model 层再进行分解，比如应用于客户端程序时，可以将 Model 层再细分为业务逻辑层、网络层、存储层等，而**实体类其实只是贯穿其中的一种数据结构而已**。
>
> 狭义上，当说一个Model对象，其实对外部组件而言更多是指Model对外提供的数据，而并不关心数据从何而来。

- View

> View就是接收用户请求交互并展示数据的给用户。

- Controller

> 主要是担任Model与View之间的桥梁，用于控制程序的流程，确保View访问到需要显示的Model对象数据，并充当View了解Model更改的渠道。
>
> 因此，理论上，Controller应该是很轻的

 ![传统MVC](架构模式.assets/7e498763c1af4882952a82b5b0bc6ca1_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 



## 变种MVC

最初的MVC，由于 View 依赖了 Model，实际上减低了 View 的可复用性。那么，如果能将 View 和 Model 彻底解耦，那就可以提高 View 的可复用性了。因此，出现了下面这种变种 MVC： 

 ![apple_mvc](架构模式.assets/a08c7f1a7130476180d1e0c4078fd9af_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 

> View 和 Model 不直接通信了，而统一通过 Controller 实现数据的传递。Model 将结果告知 Controller，Controller 再去更新 View。 

 **Android的Activity** 同时担任Controller和部分View的角色，也就是ViewController。 



# 3.MVP

 **MVP = Model-View-Presenter** 

 ![now_mvp](架构模式.assets/486c5170f4cd4fe5afa2913c51f8c867_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 

`MVP`里，三件套各自的职责和依赖关系和变种`MVC`里的职责和依赖关系其实是一样的，**但是，MVP 之间的交互主要是通过接口实现的**，Model、View、Presenter 都有各自的接口，定义各自的行为方法。针对接口编程，自然就能减低耦合，提高可复用性，以及容易进行单元测试

例如下面的登录例子

![image-20200620223716639](架构模式.assets/efafc6f86ed541aaacccfbd096862e10_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 

## 优点

- 模型与视图完全分离，我们可以修改视图而不影响模型
- 可以更高效地使用Model，因为所有的交互都发生在一个地方——Presenter内部
- 我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。
- 如果把逻辑放在Presenter接口中， 那么就可以脱离用户接口来测试这些逻辑（单元测试） 
- M 和 V 之间彻底分离了，降低了耦合性，修改 V 层也不会影响 M 层。

## 缺点

-  代码的复杂性会增加 
- 增加代码量：由于需要为每个View创建一个Presenter，因此代码量会增加，特别是对于一些简单的应用程序来说。



## MVP和MVC区别

MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，

在MVC中View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 

# 4.MVVM

 **MVVM = Model-View-ViewModel** 

 ![mvvm](架构模式.assets/b77bc732f1a8497886b0b3a6dbd6dd3e_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 

MVVM 的关系图和 MVP 很相似，最大的不同在于 View 和 ViewModel 之间主要是通过数据绑定的方案来实现交互的。 

## 数据绑定

MVVM 最重要的一个特性就是数据绑定，通过将 View 的属性绑定到 ViewModel，可以使两者之间松耦合，也完全不需要在 ViewModel 里写代码去直接更新一个 View。 

当 ViewModel 的数据发生改变之后，与之绑定的 View 也会随之自动更新。反过来，如果 View 发生了变化，那 ViewModel 是否也同样会随之变化呢？这就涉及到数据绑定的两种类型： 

- **单向绑定**：ViewModel 与 View 绑定之后，ViewModel 变化后，View 会自动更新，但反之不然，即数据传递的方向是单向的。**（ViewModel —> View）**

- **双向绑定**：ViewModel 与 View 绑定之后，如果 View 和 ViewModel 中的任何一方变化后，另一方都会自动更新，这就是双向绑定。（**ViewModel <—> View**）



## 使用

Android目前主流的方案就是采用Jetpack

重点讲解下如何用 Jetpack 实现 MVVM 架构，Jetpack 提供了多个架构组件，包括 `ViewModel`、`LiveData`、`DataBinding`等，Android 官方推荐的应用架构如下图： 

 ![jetpack](架构模式.assets/907400586d984367a5e385c3e9987760_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 

> 详情参考android Jetpack笔记