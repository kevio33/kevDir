# 一、树

> 参考——https://blog.csdn.net/Real_Fool_/article/details/113930623

## 	1.定义:

 树(Tree)是 n(n≥0)个结点的有限集。若 n=0， 称为空树；若 n > 0，则它满足如下两个条件：
  (1)  有且仅有一个特定的称为根 (Root) 的结点；
  (2)  其余结点可分为 m (m≥0) 个互不相交的有限集 T1, T2, T3, …, Tm， 其中每一个集合本身又 
         是一棵树，并称为根的子树 (SubTree)。



**形式化定义:**

T={D,R}。D是包含n个结点的有穷集合（n≥0）。当n=0时为空树，否则关系R满足以下条件:

- 有且仅有一个结点`d0∈D`，它对于关系R来说没有前驱结点，结点d0称作树的根结点。
-  除结点d0外，D中的每个结点对于关系R来说都有且仅有一个前驱结点。
-  D中每个结点对于关系R来说可以有零个或多个后继结点。

**表示法**

​	树形表示法：

![image-20210426120731008](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426120731008.png)

​	广义表示法:

![image-20210426120756446](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426120756446.png)

## 	2.树的基本属性

**①度：**

​	**结点的度：** 一个结点的孩子个数，`如上图结点B的度是2，结点D的度为3`

​	**树的度：**树内结点的最大度数 ，`如上图树的度为3`

**②树中的结点数等于所有结点的度数加1**

**③度为m的树中第i层上至多有`m^(i-1)`个结点（i≥1）**

**④高度为h的m叉树至多有**<img src="https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426122209797.png" alt="image-20210426122209797" style="zoom:50%;" />**个结点**

**⑤具有n个结点的m次树的最小高度为 `[logm(n(m-1)+1)]`（就是上面公式反推）**



## 3.树的遍历:

![image-20210426123107451](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426123107451.png)

### (1)先序遍历：

先遍历左子树，然后遍历右子树，最后访问根结点。

### (2)中序遍历：

先遍历左子树，然后访问根结点，最后遍历右子树。

### (3)后序遍历：

先遍历左子树，然后遍历右子树，最后访问根结点。



### 先序&中序and中序&后序

 根据（先序&中序）或（中序&后序）序列能构建唯一二叉树。

> 先序与后序构建的二叉树不唯一

#### 先序遍历与中序遍历唯一确定一个二叉树

> https://www.cnblogs.com/jiaxin359/p/9512348.html

问题：已知一个二叉树前序遍历为：ABDEGCFH，中序遍历为：DBGEACHF，则该二叉树的后序遍历为？ 

- **第一步**：根据前序遍历 **A B D E G C F H** 确定头结点是A，根据中序遍历 **D B G E A C H F** 将树划分为左子树 **D B G E** 和右子树 **C H F**。
- **第二步**：划分为左右两棵子树：对于左子树，前序遍历是 **B D E G**，后续遍历是 **D B G E**。对于右子树，前序遍历是 **C F H**，后续遍历是 **C H F**。
- **第三步**：对左子树和右子树分别运用第一步和第二步进行分析。
- **递归结束的条件**：当中序遍历的结点只剩下一个结点的时候，那么这个结点就是叶子结点。 

 ![img](数据结构知识.assets/890640-20180821165523909-1901265415.png) 

```java
private static TreeNode test(int[] preorder, int p, int q, int[] inorder, int i, int j) {

    if (p > q) return null;
    if (p == q) return new TreeNode(preorder[p]);

    TreeNode node = new TreeNode(preorder[p]);
    int k = i;
    // 找到根结点在中序遍历序列中的位置
    while (preorder[p] != inorder[k]) k++;
    node.left = test(preorder, p+1, p+k-i, inorder, i, k-1);
    node.right = test(preorder, p+k-i+1, q, inorder, k+1, j);

    return node;
}

public static TreeNode buildTree(int[] preorder, int[] inorder) {
    return test(preorder, 0, preorder.length-1, inorder, 0, inorder.length-1);
}
```

**python代码**

```python
class TreeNode:
    """树结点"""
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def reConstructBinaryTree(self, pre, tin):
        """根据前序遍历和中序遍历来重建一颗二叉树，要求前序遍历和中序遍历当中字符不重复
        Args:
          pre: 前序遍历  list类型或者者str类型
          tin: 中序遍历  
        Returns：
          head: 一个TreeNode类型的根结点
        """
        return self.rebuild_tree(pre, 0, len(pre)-1, tin, 0, len(tin)-1)

    def rebuild_tree(self, pre, pre_start, pre_end, tin, tin_start, tin_end):
         """递归的进行树的重建"""
        if pre_start > pre_end or tin_start > tin_end:
            return None

        head = TreeNode(pre[pre_start])
        tin_mid = tin.index(pre[pre_start])
        left_length = tin_mid - tin_start

        head.left = self.rebuild_tree(pre, pre_start+1, pre_start+left_length, 
                                      tin, tin_start, tin_mid-1)
        head.right = self.rebuild_tree(pre,pre_start+left_length+1, pre_end, 
                                       tin, tin_mid+1, tin_end)
                                       
        return head

def post_order_print(head):
    """以后序遍历的方式打印一颗二叉树"""
    if head is None:
        return
    post_order_print(head.left)
    post_order_print(head.right)
    print(head.val,end='')

if __name__ == '__main__':
    pre = 'ABDEGCFH'
    tin = 'DBGEACHF'
    s = Solution()
    head = s.reConstructBinaryTree(pre, tin)
    post_order_print(head)  # result: DGEBHFCA
```



#### 后序遍历与中序遍历唯一确定一个二叉树

与上面类似，后序遍历确定根结点，中序遍历确定左右子树





## 4.二叉树：

### 	(1)定义：

二叉树是 `n (n≥0) `个结点的有限集，它**或者是空集 (n = 0)**，或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成。

**特点:**

- 每个结点最多有俩孩子（不存在度大于2的结点）
- 子树有左右之分，其次序不能颠倒
- 二叉树可为空集合，根可有空的左子树或空的右子树



**二叉树与树的区别：**

二叉树结点子树要区分左子树还是右子树。即具有两颗结点的二叉树有两种状态

![image-20210426140735936](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426140735936.png)



### 	(2)性质

![1710766673169](数据结构知识.assets/1710766673169.png)



### 几种特殊的二叉树

#### 	(1)满二叉树

一棵高度为 k 且有 `2^k- 1` 个结点的二叉树称为满二叉树。

树中每层都含有最多的结点。

> 对满二叉树按层序编号:约定编号从根结点(根结点编号为1起，自上而下，自左向右。这样，每个结点对应一个编号,对于编号为`i`的结点，若有双亲，则其双亲为`i / 2 `,若有左孩子，则左孩子为`2i `;若有右孩子，则右孩子为`2i+1`。

![image-20210426141520734](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426141520734.png)

#### 	(2)完全二叉树

深度为 k 的具有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号为 1~n 的结点一一对应时，称之为完全二叉树。

![1710849176632](数据结构知识.assets/1710849176632.png)

**特点:**

叶子只可能分布在层次最大的两层上。 **对任一结点，如果其右子树的最大层次为 l， 则其左子树的最大层次必为 l 或 l + 1。** 

**性质:**

则对任一结点` i (1≤i≤n)`，有： 
         (1)  如果 `i = 1`，则结点 i 是二叉树的根，无双亲； 
                如果` i >1`，则其双亲是结点  `i / 2`。 
         (2)  如果 `2i > n`，则结点 `i` 为叶子结点，无左孩子； 
                否则，其左孩子是结点 `2i`。
         (3)  如果 `2i + 1 > n`，则结点 `i `无右孩子；否则，其 
                右孩子是结点 `2i + 1`。



#### (3)二叉查找树( Binary Search Tree )

又叫：`二叉搜索树`、`二叉排序树`

它或者是一颗空树，或者具有下列性质的二叉树：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树。



#### (4)平衡二叉树

它要么是一颗空树，要么**具有以下性质的二叉排序树**：

> 二叉平衡树是一种二叉排序树

- 它的左子树和右子树的**深度之差(平衡因子)的绝对值不超过1**
- 且它的左子树和右子树都是一颗平衡二叉树。
-  平衡二叉树的查找、插入和删除操作的时间复杂度为`O(log n)`，其中n为树中的结点数 
- 平衡二叉树的实现方式有多种，例如**AVL树**、**红黑树**、**B树等**。
- 平衡二叉树在许多应用中都有广泛的应用，例如数据库索引、文件系统、内存分配等领域都使用平衡二叉树来提高查找和插入的效率。 

##### **一棵平衡二叉树必须有如下条件:**

- 它**必须是二叉查找树**
- 每个结点的左子树和右子树的高度差至多为1

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTMwMzAzOS8yMDE4MDUvMTMwMzAzOS0yMDE4MDUyMzE5MDU0ODQ3OS0zMDMwNjQ0NDcucG5n)

> 左边二叉树的结点`45`左子树高度2，右子树高度0，左右子树高度差为2-0=2，不满足条件；
> 右边二叉树的结点均满足左右子树高度差至多为1，同时它满足二叉搜索树的要求，因此它是一棵平衡二叉树。

​	

##### 相关概念

**①平衡因子**：将**二叉树上结点的左子树高度减去右子树高度的值称为该结点的`平衡因子BF(Balance Factor)`**。

对于平衡二叉树，BF的取值范围为`[-1,1]`。如果发现某个结点的BF值不在此范围，则需要对树进行调整。

**②最小不平衡子树**：距离插入结点最近的，且平衡因子的绝对值大于1子树.。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/aHR0cHM6Ly9pbWFnZXMyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTMwMzAzOS8yMDE4MDUvMTMwMzAzOS0yMDE4MDUyMzE5MTc0MTE2MC02NDgzNTMzODUucG5n)

在图三中，左边二叉树的结点`45`的BF = 1，插入结点`43`后，结点`45`的`BF = 2`。结点`45`是距离插入点`43`最近的BF不在[-1,1]范围内的结点，因此以结点45为根的子树为最小不平衡子树



##### 平衡二叉树调整

整个实现过程是通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。分为LL型、RR型、LR型和RL型4种类型，各调整方法如下(下面用A表示最低不平衡结点)：

**LL型调整：**

> 由于在A的左孩子(L)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1增至2。下面图1是LL型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个结点分别作为左右孩子结点才能平衡，A结点就好像是绕结点B顺时针旋转一样。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818212028853)

LL型调整的一般形式如下图所示:

> 表示在A的左孩子B的左子树BL(不一定为空)中插入结点(图中阴影部分所示)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将A的左孩子B提升为新的根结点；②将原来的根结点A降为B的右孩子；③各子树按大小关系连接(BL和AR不变，BR调整为A的左子树)。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818221513880)

**RR型调整：**

由于在A的右孩子(R)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图3是RR型的最简单形式。显然，按照大小关系，结点B应作为新的根结点，其余两个结点分别作为左右孩子结点才能平衡，A结点就好像是绕结点B逆时针旋转一样。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818215441436)

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818220942825)

**LR型调整**

> 由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个结点分别作为左右孩子结点才能平衡。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818222514855)

> LR型调整的一般形式如下图6所示，表示在A的左孩子B的右子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的右孩子；③各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818224419149)

**RL型调整：**

> 由于在A的右孩子(R)的左子树(L)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由-1变为-2。图7是RL型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个结点分别作为左右孩子结点才能平衡。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818224940731)

RL型调整的一般形式如下图所示，表示在A的右孩子B的左子树(根结点为C，不一定为空)中插入结点(图中两个阴影部分之一)而导致不平衡( h 表示子树的深度)。这种情况调整如下：①将B的左孩子C提升为新的根结点；②将原来的根结点A降为C的左孩子；③各子树按大小关系连接(AL和BR不变，CL和CR分别调整为A的右子树和B的左子树)。

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20150818230041580)



##### AVL树

AVL树是**严格的平衡二叉树**，平衡条件必须满足（**所有结点的左右子树高度差的绝对值不超过1**）。不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而旋转是非常**耗时**的，由此我们可以知道**AVL树适合用于插入与删除次数比较少，但查找多的情况



##### 红黑树

一种二叉查找树，但在每个结点增加一个存储位表示结点的颜色，可以是红或黑（非红即黑）。通过对任何一条从根到叶子的路径上各个结点着色的方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因此，红黑树是一种弱平衡二叉树（由于是弱平衡，可以看到，在相同的结点情况下，AVL树的高度低于红黑树），相对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，我们就用红黑树。


**优点：**

红黑树是一种**近似平衡**的二叉查找树，其主要的优点就是“平衡“，即**左右子树高度几乎一致**，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 O(logn)。

<img src="https://gitee.com/kevinyong/kevin-gallery/raw/master/20201016143824185.png" alt="img" style="zoom:67%;" />

**特性**

1、根结点永远是黑色的

2、每个结点要么是红色，要么是黑色；

3、每个红色结点的两个子结点一定都是黑色；

4、红色结点不能连续（也即是，红色结点的孩子和父亲都不能是红色）；

5、从任一结点到其子树中每个叶子结点的路径都包含相同数量的黑色结点；

6、**所有的叶结点都是是黑色的**（注意这里说叶子结点其实是上图中的 NIL 结点）；



**红黑树调整**

当插入/删除操作的时候或破坏树的结构使之不满足上述条件，这就需要通过调整重新满足红黑树条件

+ 颜色调整，改变某个结点颜色
+ 结构调整，改变树的结构关系，左旋（Rotate Left）、右旋（Rotate Right）

**左旋**：

左旋的过程是将 p 的右子树绕 p 逆时针旋转，使得 p 的右子树成为 p 的父亲，同时修改相关结点的引用，使左子树的深度加 1，右子树的深度减 1，通过这种做法来调整树的稳定性。过程如下：

<img src="https://gitee.com/kevinyong/kevin-gallery/raw/master/20201016143952563.png" alt="img" style="zoom:67%;" />

```java
static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
                                      TreeNode<K,V> p) {
    //root:表示根结点
    //p:表示要调整的结点
    //r:表示p的右结点
    //pp:表示p的parent结点
    //rl:表示p的右孩子的左孩子结点
    TreeNode<K,V> r, pp, rl;
    //r判断，如果r为空则旋转没有意义
    if (p != null && (r = p.right) != null) {
        //多个等号的连接操作从右往左看，设置rl的父亲为p
        if ((rl = p.right = r.left) != null)
            rl.parent = p;
        //判断p的父亲，为空，为根结点，根结点的话就设置为黑色
        if ((pp = r.parent = p.parent) == null)
            (root = r).red = false;
        //判断p结点是左儿子还是右儿子
        else if (pp.left == p)
            pp.left = r;
        else
            pp.right = r;
        r.left = p;
        p.parent = r;
    }
    return root;
}
```

**右旋**

右旋的过程是将 p 的左子树绕 p 顺时针旋转，使得 p 的左子树成为 p 的父亲，同时修改相关结点的引用，使右子树的深度加 1，左子树的深度减 1，通过这种做法来调整树的稳定性。实现过程如下：

<img src="https://gitee.com/kevinyong/kevin-gallery/raw/master/20201016144105945.png" alt="img" style="zoom:67%;" />

```java
static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,TreeNode<K,V> p) {
			//root:表示根结点
			//p:表示要调整的结点
			//l:表示p的左结点
			//pp:表示p的parent结点
			//lr:表示p的左孩子的右孩子结点
            TreeNode<K,V> l, pp, lr;
			//l判断，如果l为空则旋转没有意义
            if (p != null && (l = p.left) != null) {
				//多个等号的连接操作从右往左看，设置lr的父亲为p
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
				//判断p的父亲，为空，为根结点，根结点的话就设置为黑色
                if ((pp = l.parent = p.parent) == null)
                    (root = l).red = false;
				//判断p结点是右儿子还是左儿子
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
            return root;
}
```



**插入元素时调整图解**

<img src="https://img-blog.csdnimg.cn/20201016144146750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MDIzNjMyOQ==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom: 25%;" />

**删除图解**

![img](数据结构知识.assets/20201016144209156.png)

**查找**

![img](数据结构知识.assets/20201016144224829.png)



> [红黑树与AVL树的区别](https://blog.csdn.net/u010899985/article/details/80981053)



##### B树

**概述：**

Ｂ树和Ｂ＋树的出现是因为另外一个问题，那就是磁盘ＩＯ；众所周知，ＩＯ操作的效率很低，那么，当在大量数据存储中，查询时我们不能一下子将所有数据加载到内存中，只能逐一加载磁盘页，每个磁盘页对应树的结点。造成大量磁盘ＩＯ操作（最坏情况下为树的高度）。平衡二叉树由于树深度过大而造成磁盘IO读写过于频繁，进而导致效率低下。

​	为了减少磁盘IO的次数，必须降低树的深度，基本想法是：

​	   （1）、**每个结点存储多个元素**
　　（2）、**摒弃二叉树结构，采用多叉树**

​	**特征：**

- 树的结点 最多 有 多少个孩子结点（子树）称为B树的阶，通常用m表示
- 一个结点有k个孩子时，必有k-1个关键字才能将子树中所有关键字划分为k个子集

```java
1.根结点至少有两个子女。
2.每个中间结点都包含k-1个元素和k个孩子，其中 ceil（m/2） ≤ k ≤ m
3.每一个叶子结点都包含k-1个元素，其中 ceil（m/2） ≤ k ≤ m
4.所有的叶子结点都位于同一层。
5.每个结点中的元素从小到大排列，结点当中k-1个元素正好是k个孩子包含的元素的值域划分
6.除根结点外，其它每个分支至少有 t = ⌈m/2⌉棵子树。
   
```

示例：三阶B树

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/2018032420113990)

**查询：**

　以上图为例：若查询的数值为５：
　　第一次磁盘ＩＯ：在内存中定位（与17、35比较），比17小，左子树；
　　第二次磁盘ＩＯ：在内存中定位（与８、12比较），比８小，左子树；
　　第三次磁盘ＩＯ：在内存中定位（与3、5比较），找到5，终止。
整个过程中，我们可以看出：比较的次数并不比二叉查找树少，尤其是当某一结点中的数据很多时，但是磁盘IO的次数却是大大减少。比较是在内存中进行的，相比于磁盘IO的速度，比较的耗时几乎可以忽略。所以当树的高度足够低的话，就可以极大的提高效率。相比之下，结点中的元素多点也没关系，仅仅是多了几次内存交互而已，只要不超过磁盘页的大小即可。

**插入：**

​	对于高度为k的m阶B树，新结点一般插在叶子层。通过检索确定关键码插入的位置，然后分两种情况讨论:

- 若该结点中关键码个数小于m-1，则直接插入
- 若该结点中的关键码个数等于m-1，则将引起结点的分裂，此时以**中间关键码**为界限将结点一分为二，产生新的结点，并把**中间关键码**插入到父结点。

重复上述工作，最坏情况一直分裂到根结点，建立一个新的根结点，B树增加一层

**例如:**在下面B树中插入key:4

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180324225635106)

第一步：检索key插入的结点位置，在3-5之间。

第二步：判断结点中关键码个数，由于该B树阶为3，所以每个结点最多有2个关键字，此时无法增加，父结点2,6也无法增加，所以增加到根结点。

第三步：结点分裂，拆分3,5与2,6，让根结点9升级为两元素结点4,9。结点6独立为根结点的第二个孩子

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180324230149255)

![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20190217130528243.png)

**删除：**

在删除B树结点时，为了避免回溯，当遇到需要合并的结点时就立即执行合并，B树的删除算法如下：从root向叶子结点按照查询规律遍历：

     （1）如果target在叶结点x中，则直接从x中删除target，情况（2）和（3）会保证当再叶子结点找到target时，肯定能借结点或合并成功而不会引起父结点的关键字个数少于t-1。
     （2）如果target在内部结点（简称内结点：非叶子结点）x中：  
      		(a)如果x的左分支结点y至少包含t个关键字，则找出y的最右的关键字prev，并替换target，并在y中递归删除prev。
    
             (b) 如果x的右分支结点z至少包含t个关键字，则找出z的最左的关键字next，并替换target，并在z中递归删除next。
    
             (c) 否则，如果y和z都只有t-1个关键字，则将target与z合并到y中，使得y有2t-1个关键字，再从y中递归删除target。
    
      (3) 如果关键字不在内部结点x中，则必然在x的某个分支结点p[i]为根的子树中，如果p[i]结点只有t-1个关键字，执行3a、3b或者3c以保证我们降至一个包含至少t个关键字的结点，然后通过对x的某个合适的子结点递归而结束。
    
             (a) 如果p[i-1]拥有至少t个关键字，则将x的某个关键字降至p[i]中，将p[i-1]的最大结点上升至x中。
             (b) 如果p[i+1]拥有至少t个关键字，则将x个某个关键字降至p[i]中，将p[i+1]的最小关键字上升至x个。 否则将p[i]与其中一个兄弟合并，将x的一个关键字降至合并的结点中，成为中间关键字。

​	删除下图中的T，其中阶层为3；

(1) 根结点的右子树的关键字个数为3 > 2，直接下降至LOT结点。

  (2) 由于T在内部结点LOT，T的前子结点和后子结点都只包含t-1 = 1个关键字，所以满足②c将两个子结点和T合并，生成结点PTY，并递归从PTY中删除T。

 (3) T在PTY中，而且PTY是一个叶子结点，所以直接删除。
![img](https://gitee.com/kevinyong/kevin-gallery/raw/master/20190217133133695.png)



​	删除元素11：

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180324232514619)

第一步：判断该元素是否在叶子结点上。
　　　该元素在叶子结点上，可以直接删去，但是删除之后，中间结点12只有一个孩子，不符合B树的定义：每个中间结点都包含k个孩子，（其中 ceil（m/2） <= k <= m）所以需要调整；

第二步：判断其左右兄弟结点中有“多余”的关键字，即：原关键字个数n>=ceil(m/2) - 1；
　　显然结点11的右兄弟结点中有多余的关键字。那么可将右兄弟结点中最小关键字上移至双亲结点。而将双亲结点中小于该上移关键字的关键字下移至被删关键字所在结点中即可

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180324232544302)



###### 	B+树

**Ｂ＋树是Ｂ树的变种，有着比Ｂ树更高的查询效率**



**特点**一个m阶的B+树有如下几个特征:

```java
1.有k个子树的中间结点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子结点。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。

3.所有的中间结点元素都同时存在于子结点，在子结点元素中是最大（或最小）元素。
```

下面是一棵3阶的B+树

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180325001555181)

B+树通常有两个指针，一个指向根结点，另一个指向关键字最小的叶子结点。因此，对于B+树进行查找两种运算：一种是从最小关键字起顺序查找，另一种是从根结点开始，进行随机查找。

**查找：**

**B+树的优势在于查找效率**上，下面做一具体说明：
　　首先，Ｂ＋树的查找和Ｂ树一样，类似于二叉查找树。起始于根结点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在结点内部典型的使用是二分查找来确定这个位置。

​	（1）不同的是，**Ｂ＋树中间结点没有数据**（索引元素所指向的数据记录），只有索引，而Ｂ树每个结点中的每个关键字都有数据；这就意味着同样的大小的磁盘页可以容纳更多结点元素，在相同的数据量下，Ｂ＋树更加“矮胖”，ＩＯ操作更少

​    （2）、其次，因为卫星数据的不同，导致查询过程也不同；Ｂ树的查找只需找到匹配元素即可，最好情况下查找到根结点，最坏情况下查找到叶子结点，所说性能很不稳定，而Ｂ＋树每次必须查找到叶子结点，性能稳定

B树的卫星数据：

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180325104112455)

B+树的卫星数据：

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180325104136182)

 (3)在范围查询方面，B+树的优势更加明显
　　B树的范围查找需要不断依赖中序遍历。首先二分查找到范围下限，在不断通过中序遍历，知道查找到范围的上限即可。整个过程比较耗时。
　　而B+树的范围查找则简单了许多。首先通过二分查找，找到范围下限，然后同过叶子结点的链表顺序遍历，直至找到上限即可，整个过程简单许多，效率也比较高。
　　例如：同样查找范围[3-11]，两者的查询过程如下：
		B树的查找过程：

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180325111523599)

B+树查找过程：

![这里写图片描述](https://gitee.com/kevinyong/kevin-gallery/raw/master/20180325111559207)

**插入：**

B+树的插入与B树的插入过程类似。不同的是B+树在叶结点上进行，如果叶结点中的关键码个数超过m，就必须分裂成关键码数目大致相同的两个结点，并保证上层结点中有这两个结点的最大关键码。

**删除：**

B+树中的关键码在叶结点层删除后，其在上层的复本可以保留，作为一个”分解关键码”存在，如果因为删除而造成结点中关键码数小于ceil(m/2)，其处理过程与B-树的处理一样。在此，我就不多做介绍了。



###### 总结：

​	   ①、B树主要用于文件系统以及部分数据库索引，例如： MongoDB。而大部分关系数据库则使用B+树做索引，例如：mysql数据库；
　　②、从查找效率考虑一般要求B树的阶数m >= 3;
　　③、B树上算法的执行时间主要由读、写磁盘的次数来决定，故一次I/O操作应读写尽可能多的信息。因此B树的结点规模一般以一个磁盘页为单位。一个结点包含的关键字及其孩子个数取决于磁盘页的大小。

​		④、单一结点存储更多的元素，使得查询的IO次数更少；



## 5.哈夫曼树

### 	(1)定义：

**哈夫曼树(最优树)：带权路径长度最短的树**

### 	(2)特点：

- 哈夫曼树中权越大的叶子离根越近
- 具有相同带权结点的哈夫曼树不唯一
- 满二叉树不一定是哈夫曼树
- 包含n个叶子结点的哈夫曼树中共有`2n-1`个结点

### 	(3)构造哈夫曼树

在众多结点中，每次选择两个权值最小的结点进行合并形成一棵新的树。直到最后合并成一棵哈夫曼树

![image-20210426155307528](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426155307528.png)



### 	(4)应用：哈夫曼编码

- 为了解决数据的最小冗余编码问题(短编码表示频率大的字符)
- 解决译码唯一性的问题：要求任一字符的编码都不能是另一字符编码的前缀！

![image-20210426160016228](https://gitee.com/kevinyong/kevin-gallery/raw/master/image-20210426160016228.png)

上图中，以出现频率作为权重来生成哈夫曼树



## 6.最小生成树

> https://blog.csdn.net/qq_35644234/article/details/59106779

最小生成树（Minimum Spanning Tree，简称MST）是一个图论概念，它指的是一个连通无向图的所有顶点的一个子集，使得这个子集中的边的权值和最小，并且这个子集中的边能够将图中所有的顶点连接起来。 

**最小生成树有以下特点：**

1. 最小生成树是一个无向图。
2. 最小生成树中的边的权值和最小。
3. 最小生成树中包含所有的顶点。
4. 最小生成树中不包含环。
5. 最小生成树是唯一的。

**应用：**

常见的最小生成树算法包括`Prim算法`、`Kruskal算法`和`Boruvka算法`等。这些算法都是基于贪心策略的，通过不断选择权值最小的边来构造最小生成树。 



# 二、图

## 1.数组压缩