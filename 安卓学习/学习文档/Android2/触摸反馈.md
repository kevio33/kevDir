# 触摸反馈

> [Android触屏事件和MotionEvent详解](https://cloud.tencent.com/developer/article/1728826)

## 一、**Android屏幕交互事件**

用户在设备屏幕上的所有操作都会转换为各类屏幕交互事件。Android屏幕交互事件主要有如下几种类型。

- key event 键盘、遥控器按键，鼠标点击会生成按键事件（key event）
- hover event 鼠标在屏幕上的停留、滑动会产生hover event
- scroll event 鼠标滚轮的滚动会生成scroll event
- **touch event** 对触屏设备，当用户用手指或触控笔在设备屏幕上操作时会产生触屏事件（touch event）。



## 二、Touch Event

### 触屏事件类型

按照动作来分，可以将触屏事件可以分为以下三类

1. 手指按到屏幕上
2. 手指在屏幕上移动
3. 手指离开屏幕 

其中手指按到屏幕上和手指离开屏幕一定是成对出现的，在这中间会出现不定次数的手指在屏幕上移动的事件。



### **触屏事件序列**

在Android系统中，从手指按到屏幕上开始，到手指离开屏幕，这个过程中产生的一系列触屏事件构成了一个事件序列（也可以称为事件流）。对多点触屏事件，则是从第一个手指按到屏幕上开始，到最后一个手指离开屏幕为止。

一个触屏事件序列第一个事件一定是手指按到屏幕上，最后一个事件一定是手指离开屏幕。用户在设备屏幕上的所有触屏操作最终都会转换为若干个这样的事件序列。



### 触屏事件的表示

在MotionEvent中，涉及到三个重要的对象：**Event**、**Pointer**、**Motion**

- 在Android系统中使用MotionEvent对象来表示一个触屏事件，当用户用手指在屏幕上操作时，会产生一系列的MotionEvent对象。但是需要注意的是，产生了一个MotionEvent对象并不表示这一定是一个触屏操作，MotionEvent不仅可以用来表示touch event，还可以表示hover event，scroll event。也就是说，除了key event之外的其他屏幕交互事件都用MotionEvent来表示（key event用KeyEvent对象表示）。
- **MotionEvent类中将产生此次事件的动作称为motion**
- **将产生此动作的主体（如手指，鼠标等）称为pointer**。一个MotionEvent对象中可以包含一个或多个pointer，每个pointer都包含id，index，位置，大小，方向等属性。在一个触屏事件序列的多个事件中，同一个pointer拥有相同的id，但是index可以不同。



#### （1）action code

 MotionEvent提供了`getActionMasked()`和`getAction()`方法来获取此次操作的类型，它是一个int型数值。

 在MotionEvent类中定义了一系列的int常量来表示各种预定义的操作类型 

| 事件类型常量        | 含义说明                                                     |
| :------------------ | :----------------------------------------------------------- |
| ACTION_DOWN         | 当手指接触屏幕时产生此事件，在多点触摸时，只有第一个手指接触屏幕时才会产生此事件，中间其他手指接触屏幕不会产生此事件。它表示一个触屏事件序列的开始。 |
| ACTION_UP           | 当手指离开屏幕时产生此事件，在多点触摸时，只有最后一个手指（这个手指并不一定是产生ACTION_DOWN事件的那个手指）离开屏幕时才会产生此事件，中间其他手指离开屏幕不会产生此事件。它表示一个触屏事件序列的结束。 |
| ACTION_MOVE         | 当手指在屏幕上滑动时产生此事件， 在多点触摸时，每个手指的滑动都会产生一个此事件 |
| ACTION_POINTER_DOWN | 只有在多点触摸时才会产生此事件，在一个触屏事件序列中，除第一个接触屏幕的手指外，其他手指接触屏幕时会产生此事件。 |
| ACTION_POINTER_UP   | 同样只有在多点触摸时才会产生此事件，在一个触屏事件序列中，除最后一个离开屏幕的手指外，其他手指离开屏幕时会产生此事件。 |
| ACTION_CANCEL       | 这个事件比较特殊，它和上述事件都不一样，上述事件都是由用户在屏幕上操作所触发的，但是这个事件是由系统自动产生的。当一个事件序列需要提前终止的时候由系统自动产生此事件。正常来说，一个事件序列应该以最后一个手指离开屏幕，也就是ACTION_UP作为结束，但是在某些情况下，事件序列需要被提前终止。这通常是因为处理这个事件序列的View对象的Parent对象在事件序列结束之前主动拦截了后续的事件。此外，如果处理这个事件序列的View对象从窗口中被移除了，它也会收到ACTION_CANCEL事件。例如处理这个事件序列的View对象所在的Activty被finish()，所在的Dialog被dismiss()，或者被其Parent View Remove了。在这些情况下，虽然这时手指还停留在屏幕上，但View对象将无法再接收到后续的触屏事件，这时它会收到ACTION_CANCEL事件，表示事件序列由于外在原因需要提前终止。 |

> 一个正常的触摸事件序列一定是以ACTION_DOWN为开始，以ACTION_UP为结束，中间可以有0个或多个ACTION_MOVE， 如果是多点触摸，中间还会有若干次的ACTION_POINTER_DOWN和ACTION_POINTER_UP。 



**getAction()和getActionMasked()的区别：**

- 对ACTION_POINTER_DOWN和ACTION_POINTER_UP之外的事件：getAction()返回值和getActionMasked()是相同的。

- 对ACTION_POINTER_DOWN和ACTION_POINTER_UP：getAction()返回值和getActionMasked()返回值稍有不同

  > getAction()返回值包含了操作类型和产生此事件的pointer对应的pointer index两个信息，其中低8位代表操作类型，高8位代表pointer index 。 



#### （2）pointer信息 

1. 通过getPointerCount()方法获取此事件产生时pointer的个数，它一定是大于等于1的。例如有两个手指接触在屏幕上，则getPointerCount()为2。
2. 通过getPointerId(int pointerIndex)获取pointerIndex对应的pointer id。
3. 通过findPointerIndex(int pointerId)获取pointerId对应的pointer index。
4. 通过getX(int pointerIndex)，getY(int pointerIndex)方法来获取此事件产生时pointerIndex对应的pointer在屏幕上的相对位置。
5. 通过getRawX()，getRawY()方法来获取此事件产生时pointerIndex对应的pointer在屏幕上的绝对位置。不带参数的重载方法表示获取pointerIndex为0的pointer在屏幕上的位置。  

除此之外，还有getToolMajor()，getToolMinor()，getTouchMajor()，getTouchMinor()，getOrientation()等方法获取pointer的区域大小，方向等信息。



#### （3）操作时间  

可以通过MotionEvent类的getEventTime()方法来获取此事件产生的时间。

#### （4）事件序列的历史数据  

在MotionEvent对象中还会保存其所在的事件序列的一些历史事件的信息，可以通过getHistorySize()获取历史事件记录的条数，通过一系列的getHistoricalXXX()方法获取历史事件的信息。由于ACTION_DOWN 是一个事件序列的开始，所以ACTION_DOWN对应的事件对象中是不会有历史事件记录的，在这之后的事件对应的MotionEvent对象中会有0到多个的历史事件信息的记录，具体记录的个数并不固定，总的数量也不会太多。





### 实例：

#### 设置TouchListener

对于某个系统控件，可以通过设置一个触摸事件监听者，然后实现touchListener的onTouch方法。**会返回一个布尔类型，代表该回调是否处理该事件**

```java
btn.setOnTouchListener(new View.OnTouchListener() {
    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return false;
    }
```





#### 自定义View的触摸反馈

自定义的view的触摸反馈主要是通过重写`onTouchEvent`方法，在里面实现触摸算法

```kotlin
class MyCustomView(context: Context?, attrs: AttributeSet?) : View(context, attrs) {
    //重写onTouchEvent方法
    override fun onTouchEvent(event: MotionEvent?): Boolean {
        //如果触碰手势是抬起，那就证明完成了一次点击，触发点击事件
        if(event?.actionMasked == MotionEvent.ACTION_UP){
            performClick()
        }
        return true
    }
}
```

布局文件中将组件替换为自定义组件

```xml
<com.example.widgettest.customView.MyCustomView
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:id="@+id/view"
        android:background="@color/black"
        />
```





## 三、事件分发\拦截\消费

> [触摸事件传递详解](https://www.jianshu.com/p/7701b871104e)
>
> [触摸事件，拦截、分发](https://juejin.cn/post/6906812971549196301)
>
> [代码详情](http://haichenyi.com/2021/11/20/Android%E2%80%94%E2%80%94%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/)

**与触摸事件有关的操作有如下3个方法：**

- public boolean dispatchTouchEvent(MotionEvent event)
- public boolean onTouchEvent(MotionEvent event)
- public boolean onInterceptTouchEvent(MotionEvent event)

在View和ViewGroup中都存在`dispatchTouchEvent`和`onTouchEvent`方法。

特别的，在ViewGroup中还有一个`onInterceptTouchEvent`方法。这些方法的返回值全部都是boolean型，这是因为事件传递的过程就是一个接一个，某一个点后根据方法boolean的返回值判断是否要继续往下传递。

三个方法可以总结为一张表格：

| Touch 事件相关方法                                   | 方法功能 | ViewGroup | View | Activity |
| ---------------------------------------------------- | -------- | --------- | ---- | -------- |
| public boolean dispatchTouchEvent(MotionEvent ev)    | 事件分发 | Yes       | Yes  | Yes      |
| public boolean onInterceptTouchEvent(MotionEvent ev) | 事件拦截 | Yes       | Yes  | No       |
| public boolean onTouchEvent(MotionEvent ev)          | 事件响应 | Yes       | Yes  | No       |



> **需要注意的是:**
>
> “ View 对 `dispatchTouchEvent(MotionEvent ev)` 和`onInterceptTouchEvent(MotionEvent ev) `的响应的**前提是可以向该 View 中添加子 View**。”
>
> 如果当前的 View 已经是一个最小的单元 View（比如 TextView），那么就无法向这个最小 View 中添加子 View，也就无法向子 View 进行事件的分发和拦截，所以它没有`onInterceptTouchEvent(MotionEvent ev)`方法



 从整体脉络上了解触摸事件机制的整个流程，大致可以按一个倒置的U型图来理解整个机制： 

 ![触摸事件机制](触摸反馈.assets/80d32046329c4b498cc513b299948682_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 

 触摸事件从Activity触发事件然后传递到布局文件，一层一层的往子容器传递到最底层的view，如果每层布局文件未对该事件进行处理或者消费那么该事件会从最底层开始往上传到Activity进行消费。类似于一个倒置的U型。 

再具体一点：

 ![例子](触摸反馈.assets/7c39790feb9544928d4177f45f119c6e_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 

 ![触摸事件分发、拦截和消费](触摸反馈.assets/07942373e4624981b7bf4ac38cc8c62f_tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.awebp) 





## 其他问题：



### onTouch和onClick区别

> https://blog.csdn.net/JavaLive09/article/details/18001619





### 长按事件

#### 长按和短按事件同时相应

> https://blog.csdn.net/xieluoxixi/article/details/52642781



#### 自定义长按事件

> https://blog.csdn.net/hdhhd/article/details/88570021

因为系统提供的长按点击事件处理，默认只能处理400ms的长按事件，因此如果想要自定义时长，需要自己实现长按点击事件

```java
ViewConfiguration.getLongPressTimeout();


//输出是400ms：
public static final int DEFAULT_LONG_PRESS_TIMEOUT = 400;
```



**基本逻辑：**

- 定义一个静态方法，获取要点击的View、长按时间、事件监听回调
- 通过View的`onTouch`处理长按事件

```java
public class LongClickUtil {

    public static void setLongClick(final Handler handler, final View longClickView, final long delayMillis, final View.OnLongClickListener onLongClickListener){

        longClickView.setOnTouchListener(new View.OnTouchListener() {

            private int TOUCH_MAX = 50;
            private int mLastMotionX;
            private int mLastMotionY;

            @Override
            public boolean onTouch(View v, MotionEvent event) {

                int x = (int) event.getX();
                int y = (int) event.getY();

                switch (event.getAction()){
                    case MotionEvent.ACTION_UP:
                        // 抬起时,移除已有Runnable回调,抬起就算长按了(不需要考虑用户是否长按了超过预设的时间)
                        handler.removeCallbacks(r);
                        break;

                    case MotionEvent.ACTION_MOVE:
                        if (Math.abs(mLastMotionX - x) > TOUCH_MAX
                            || Math.abs(mLastMotionY - y) > TOUCH_MAX) {
                            // 移动误差阈值
                            // xy方向判断
                            // 移动超过阈值，则表示移动了,就不是长按(看需求),移除 已有的Runnable回调
                            handler.removeCallbacks(r);
                        }
                        break;
                    case MotionEvent.ACTION_DOWN:
                        // 每次按下重新计时
                        // 按下前,先移除 已有的Runnable回调,防止用户多次单击导致多次回调长按事件的bug
                        handler.removeCallbacks(r);
                        mLastMotionX = x;
                        mLastMotionY = y;
                        // 按下时,开始计时，指定时间内在主线程执行runnable的run方法，
                        handler.postDelayed(r, delayMillis);
                        return true;
                }
                return false;
            }

            private  Runnable r = new Runnable() {
                @Override
                public void run() {
                    onLongClickListener.onLongClick(longClickView);
                }
            };
        });
    }
}
```

调用

```java
LongClickUtil.setLongClick(new Handler(), activityMain2Binding.btn, 2000, new View.OnLongClickListener() {
    @Override
    public boolean onLongClick(View v) {

        activityMain2Binding.tv.setText("长按了噢"+System.currentTimeMillis()/1000);
        return true;
    }
});
```





