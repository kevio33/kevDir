## 一、SparseArray

> https://blog.csdn.net/weixin_40299948/article/details/99889024

**Sparserray是Android中特有的数据结构,他的几个重要的特点：**

- 以键值对形式进行存储，基于分查找,因此查找的时间复杂度为0(LogN);
- 由于SparseArray中Key存储的是数组形式,因此可以直接以int作为Key。避免了HashMap的装箱拆箱操作,性能更高且int的存储开销远远小于Integer;
- 采用了**延迟删除**的机制(针对数组的删除扩容开销大的问题的优化， 具体稍后分析) ;
  

### 数据结构

```java
@UnsupportedAppUsage(maxTargetSdk = 28) // Use keyAt(int)
private int[] mKeys;//存储键
@UnsupportedAppUsage(maxTargetSdk = 28) // Use valueAt(int), setValueAt(int, E)
private Object[] mValues;//值
@UnsupportedAppUsage(maxTargetSdk = 28) // Use size()
private int mSize;//集合大小（并不一定等于实际大小，实际大小看mValues的长度）

private static final Object DELETED = new Object();//DELETED ，static final 的一个静态Object实例，当一个键值对被remove后，会在mValue对应key的value下放置该对象(占位)，标记该元素已经被删除（延迟删除，等下具体介绍）；
private boolean mGarbage = false;//当值为true，标志数据结构中有元素被删除，可以触发gc对无效数据进行回收（真正删除）；
```



### 构造函数

```java
public SparseArray(int initialCapacity) {
    if (initialCapacity == 0) {
        mKeys = EmptyArray.INT;
        mValues = EmptyArray.OBJECT;
    } else {
        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);
        mKeys = new int[mValues.length];
    }
    mSize = 0;
}
```



### Delete

```java
public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);//二分查找找到删除key在mKeys中的下标

    if (i >= 0) {
        if (mValues[i] != DELETED) {
            mValues[i] = DELETED;//使用deleted占位
            mGarbage = true;//表示要删除
        }
    }
}

//remove就是delete的别名
public void remove(int key) {
    delete(key);
}
```

> **binarySearch**方法
>
> ```java
> class ContainerHelpers {
> 
>     //第一个参数array为keys的数组，第二个为数组中元素个数（与keys的length不一定相等），第三个value为目标的key
>     static int binarySearch(int[] array, int size, int value) {
>         //lo为二分查找的左边界
>         int lo = 0;
>         //hi为二分查找的右边界
>         int hi = size - 1;
> 
>         //还没找到，继续查找
>         while (lo <= hi) {
>             //左边界+右边界处以2，获取到mid 的index
>             final int mid = (lo + hi) >>> 1;
>             //获取中间元素
>             final int midVal = array[mid];
> 
>             if (midVal < value) {
>                 lo = mid + 1;
>             } else if (midVal > value) {
>                 hi = mid - 1;
>             } else {
>                 //相等，找到了，返回key对应在array的下标；
>                 return mid;  // value found
>             }
>         }
>         //没有找到该元素，对lo取反！！！！！很重要	
>         return ~lo;  // value not present
>     }
> 
>     static int binarySearch(long[] array, int size, long value) {
>         ......
>     }
> }
> ```



**remove方法主要做的就是这些，找到需要删除的key，并将对应的value用DELETED替换；但是key仍然存在于mKeys数组，因此删除是一个伪删除。这就是所谓的延迟删除机制；**



### Put

```java
public void put(int key, E value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    //原来已经有key，可能是remove后，value存放着DELETED，也可能是存放旧值，那么就替换
    if (i >= 0) {
        mValues[i] = value;
    } else {
        //没有找到，对i取反，得到i= lo（ContainerHelpers.binarySearch）
        i = ~i;
        //如果i小于数组长度，且mValues==DELETED(i对应的Key被延迟删除了)
        if (i < mSize && mValues[i] == DELETED) {
            //直接取代，实现真实删除原键值对
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        //数组中可能存在延迟删除元素且当前数组长度满，无法添加
        if (mGarbage && mSize >= mKeys.length) {
            //真实删除，将所有延迟删除的元素从数组中清除；
            gc();
            //清除后重新确定当前key在数组中的目标位置；
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        //不存在垃圾或者当前数组仍然可以继续添加元素，不需要扩容，则将i之后的元素全部后移，数组中仍然存在被DELETED的垃圾key；
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        //新元素添加成功，潜在可用元素数量+1
        mSize++;
    }
}
```

`put`方法也调用了`ContainerHelpers.binarySearch`方法先进行查找，查找到大于0，则在数组中找到了对应的`key`，此时，直接将`value`进行替换即可；  如果没有找到，返回的是`~lo`，那么，将`i`赋值`~lo`,即`i=lo`，，此时i就是我们需要插入的位置； 

> 因为在二分查找时候，如果没找到，最后返回的是`~i`，因此这里再次取反就代表最符合插入该`Key`的地方

- 找到了`i`，如果没有设置`DELETED`，直接插入即可，将该下标及后面的元素后移
- 找到了`i`，如果设置了`DELETED`,那么要先进行`gc`，然后再插入



### GC

```java
private void gc() {
    // Log.e("SparseArray", "gc start with " + mSize);
    //n代表gc前数组的长度；
    int n = mSize;
    int o = 0;
    int[] keys = mKeys;
    Object[] values = mValues;

    for (int i = 0; i < n; i++) {
        Object val = values[i];
        //遍历元素，如果value不为DELETED，则用前数据放在o上，o的序号表示当前的有效元素下标。
        //每遇到一次DELETED，则i-o的大小+1；
        if (val != DELETED) {
            //之后遇到非DELETED数据，则将后续元素的key和value往前挪
            if (i != o) {
                keys[o] = keys[i];
                values[o] = val;
                values[i] = null;
            }

            o++;
        }
    }
    //此时无垃圾数据，o的序号表示mSize的大小
    mGarbage = false;
    mSize = o;

    // Log.e("SparseArray", "gc end with " + mSize);
}
```

 ![img](https://i-blog.csdnimg.cn/blog_migrate/451fc36dceba4e01c92854213b01aba9.png) 







## 二、ArrayMap

> https://mp.weixin.qq.com/s/PwHRdhgiJEJ3aAWdJenXSQ?poc_token=HCob8majAooLcHKKkR-bxexCvXsjBYTYi9IhND8U

ArrayMap 是官方提供的一种 **键值对集合** ，我们知道，虽然 HashMap 已经提供了足够高的读写效率，但这是基于较高的 **内存占用** 和 **垃圾回收频率** 实现的。 

### 数据结构

 ArrayMap 的思路是使用两个并列的数组来存储键值对： 

```java
public final class ArrayMap<K, V> implements Map<K, V> {
    int[] mHashes;//保存key的hashcode
    Object[] mArray;//顺序保存key-value
    int mSize;
}
```

 ![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/MOu2ZNAwZwNqeafSaVQMYd6yyJaNhC4nvOwWmGqGO1Qv049tiaEaheocfmUS05kl14hqFY01NR0LTD5y8bnToLA/640?wx_fmt=other&from=appmsg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1) 



### 特点

相较于`HashMap`，`ArrayMap`的优点比较明显：

- **更低的PC压力：**ArrayMap 的思路是使用两个并列的数组来存储键值对，可以极大地减少内存分配的次数，降低垃圾回收的压力

- **减少内存占用：** ArrayMap 内部结构简单，提供了更紧凑的数据结构，而非类似 HashMap 复杂的数据结构（链表或红黑树），因此在存储少量数据时，比 HashMap 更加节省内存。 

- **较高读写效率：**ArrayMap 使用 **有序数组** 和 **二分查找** 来定位键值对：

  - 若找到存在相同键的位置，那就直接覆盖值。
  - 若未找到，则在插入键值对时动态调整数组并保持 有序性。

  由于使用了二分查找，因此时间复杂度是 O(log n)，由于其使用场景为 **内存受限的小数据集操作**，因此对数级别的时间复杂度是可以接受的。



### 缓存池

ArrayMap 使用场景通常数据很少，而为了进一步 **优化内存的分配和回收**，其内部引入了 **缓存池** 概念： 

```java
public final class ArrayMap<K, V> implements Map<K, V> {
    static Object[] mBaseCache;
    static Object[] mTwiceBaseCache;
}
```

其内部使用一个 **静态缓存池** 存储已被回收但还可重用的内部存储结构。这包括一组预先定义的对象缓存队列，用来存储不同大小的数组。 

当需要分配新的数组时，首先尝试从缓存中获取，而不是直接进行新的内存分配：

```java
private void allocArrays(int size) {
    if (size == BASE_SIZE) {
        synchronized (sBaseCacheLock) {
            if (mBaseCache != null) {
                // 1.从静态缓存池中取出
                final Object[] array = mBaseCache;
                // 2.复用之
                mArray = array;
                mBaseCache = (Object[]) array[0];   // 【重要】
                mHashes = (int[]) array[1];
                array[0] = array[1] = null;
                // ....
            }
        }
    }
    // 3. 无可用缓存，再new
    mKeys = new Object[size];
    mValues = new Object[size];
}
```



### 缺点

由于缓存池是静态的缘故，就会导致**并发场景下，一个数据异常，会影响到其它场景的其它 ArrayMap 实例** 

```java
private void allocArrays(int size) {
    // 省略其它

    // 1.从静态缓存池中取出
    final Object[] array = mBaseCache;
    // 2.复用之
    mArray = array;
    // *************************
    // 3.此时，其它线程进行了写操作，如 mArray.put(XXX)，即 mBaseCache 缓存池受到了污染.
    // *************************
    mBaseCache = (Object[]) array[0];   // 4.此时读取缓存池数据，脏数据导致类型异常，app崩溃

    // 省略其它
}
```

> 当`mBaseCache`缓存池受到污染后，可能并不会引起崩溃，而是把隐患埋了下来，当下一次，在其它业务场景下，通过`new ArrayMap() `创建对象并申请内存时，缓存池复用才会抛出异常。 



### 使用建议

由于 frameWork、Glide等框架内部依然大量使用了 ArrayMap。

最好的方式是保证使用时的线程安全，即和 Glide 等源码保持一致，**只在主线程使用`ArrayMap`及其子类**。

> 复杂业务情况还是使用HashMap



### 和SparseArray区别

1. **键类型**：
   - `ArrayMap` 的键可以是任何对象。
   - `SparseArray` 的键必须是整数（`int`）。
2. **使用场景**：
   - `ArrayMap` 适用于需要存储**复杂键值对**的场景。
   - `SparseArray` 适用于需要存储**整数键值对**的场景。
3. **内存使用和性能**：
   - 在内存使用和性能上，`ArrayMap` 和 `SparseArray` 都比 `HashMap` 更高效，特别是在键值对数量较少的情况下。
   - `SparseArray` 在处理整数键时更为高效。

