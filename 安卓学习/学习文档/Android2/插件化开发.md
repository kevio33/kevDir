> [插件化开发](https://mp.weixin.qq.com/s/TPwnOtd1xfXRvIV0voWnRQ)
>
> [腾讯技术——插件化](https://cloud.tencent.com/developer/inventory/14232/article/1071815)
>
> [ Qigsaw ](https://github.com/iqiyi/Qigsaw)
>
> [Qigsaw框架分析](https://juejin.cn/post/7186855239532675130)



# 一、概述

**插件化设计之初就是为了不安装新Apk，从而完成应用的更新迭代** 

做插件化主要诉求是因为——**包体积**

- 厂商预装的时候包体积的强制诉求：如果不做插件化，就需要每年预装阶段持续投入人力优化包体积，成本比较高。
- 对外投放的时候，小包有利于提高用户的转化。

小的包体积能够让用户更快的进入应用



# 二、难点

对于一个完整功能的App，可以将其划分成为很多模块，每个模块都可以将其划分成为一个Apk。然后将基础功能的Apk提交给应用市场上架，后续我们可以通过基础的Apk，下载其他模块的Apk，从而完成功能的扩展。 

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640.webp) 

**提交给应用市场的APK为宿主，其他模块的APK为插件**

如何单独加载一个单独的APK？是插件化的第一个难点

## 1.加载插件APK

首先先来分析一下JVM和ART各自的类加载结构

### Java类加载

Jvm中加载的文件是class文件，再由Jvm翻译成特定平台的机器码。使用的类加载器如下：

- **启动类加载器**：由C++语言实现，负责加载Java中的核心类。
- **扩展类加载器**：负责加载Java扩展的核心类之外的类。
- **应用程序类加载器**：负责加载用户类路径上指定的类库。

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097042363.webp) 

**双亲委派机制保证了收到类加载请求的时候，优先让父类加载器去加载，父类加载器处理不了的时候，才会自己去加载，保证了类加载机制的稳定性。** 



### Android类加载

`Android`由于从`Dalvik`过渡到`ART`，所以加载机制产生了变化。

- 早期`Art`加载时候， 在**安装的时候**，会将dex文件直接编译成`.oat`这样的机器码，但这样会出现问题是：

  > **提高安装和升级应用的时间**

- 在 Android 7.0 以后，第一次启动的时候，使用` Jit`，针对`dex`，边解释边执行，然后在空闲的时候，将剩余的 `dex` 文件编译成机器码 

  > 所以，可以注意到，每次应用升级的一段时间内，我们的启动时长会出现波动，过了几天以后，又会达到稳定的状态。因此，很多大厂，会针对这个过程优化 

**针对第二点，很多大厂会对其优化：**

- 如何更多的触发 dex2aot 过程。
- 对启动热点代码预先aot，比如谷歌的BaselineProfile方案，很多大厂也有自己的方案。

**在看一下Android的类加载器**

Android里面类加载的单位是dex，类加载器包括：

- **BootClassLoader**：用来解决Android系统启动时的核心基础类。
- **PathClassLoader**：Android中默认的类加载器，主要用来加载应用程序自身的类以及系统类库之外的本地代码。
- **DexClassLoader**：加载指定路径下的Apk、Jar包的类。
- **InMemoryDexClassLoader**：Android 8.0 中可以用来加载内存中的Dex文件。

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097395489.webp) 

**如果加载指定路径下的APK，可以使用DexClassLoader，这样单独加载插件APK的问题就解决了**



### 方案实现

`DexClassLoader`的原理主要是通过`DexPathList`管理`DexFile`列表信息，从而加载到具体的类。 

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097515182.webp) 

基于DexClassLoader，通常有两种方案:

1. 单个DexClassLoader方案。
2. 多个DexClassLoader方案。

**单个DexClassLoader**

单个DexClassLoader指的我们可能有多个插件Dex，多个插件Dex使用同一个DexClassLoader，如图：

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097530341.webp) 

将所有的插件中的类都由统一的DexClassLoader加载。

**多个DexClassLoader**

多个DexClassLoader指的是对于多个插件Dex，每一个Dex都会有自己的DexClassLoader，如图：

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097541062.webp) 

 由各自DexClassLoader负责相关的插件的类加载。 



**两者各自优缺点**

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097599119.webp) 



## 2.组件加载

仅仅能够加载插件中的类显然是不够的，还要能够启动插件中的的四大组件，并正确的执行四大组件的生命周期 

**因为，只有在我们宿主包中Manifest文件中注册的四大组件才能够启动，如果没有注册，就会抛出异常，提醒你在Manifest中注册** 

### 1. Activity解决方法

如果想让对应的Activity启动，一般有如下几种方法：

1. 宿主包提前声明组件。
2. 占位组件 + 手动调用组件。
3. 占位组件 + 欺骗系统。

#### **1.1 宿主包提前声明组件**

**将所有的四大组件在宿主包中都提前声明**，这是最简单粗暴的方式。

但这种方式会丢失插件化的动态性，也就是说，如果想在插件包中，加入宿主包没有注册的Activity，这就会有问题。

那这种方式的优点呢？解决包体积的问题的同时不用处理复杂的组件加载以及伴随的生命周期的问题。

#### **1.2 占位组件 + 手动调用组件**

那如果想要保存插件的动态化加载呢？也就是说我们想要在插件包中的 Manifest 文件中进行注册。

默认情况下，如果我们启动一个没有在插件 Manifest 中注册的的 Activity，会发生 error，原因是启动过程中的 Instrumentation 中的 checkStartActivityResult 方法：

```java
public class Instrumentation {
    public static void checkStartActivityResult(int res, Object intent) {
        if (!ActivityManager.isStartResultFatalError(res)) {
            return;
        }

        switch (res) {
            case ActivityManager.START_INTENT_NOT_RESOLVED:
            case ActivityManager.START_CLASS_NOT_FOUND:
                if (intent instanceof Intent && ((Intent)intent).getComponent() != null)
                    throw new ActivityNotFoundException(
                    "Unable to find explicit activity class "
                    + ((Intent)intent).getComponent().toShortString()
                    + "; have you declared this activity in your AndroidManifest.xml?");
                throw new ActivityNotFoundException(
                    "No Activity found to handle " + intent);
                ...
        }
    }
}
```

**使用占位Activity，这其实就是使用的代理模式。每次需要启动插件中的Activity的时候，先启动一个占位Activity实例，然后在占位Activity实例里面持有目标Activity的实例对象，从而通过反射或者其他方法调用实例的生命周期。** 

![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097735922.webp) 

> **这种方法的问题主要如下：**
>
> 1. 代码的入侵性比较强，需要统一继承PluginActvity。
> 2. 对于Activity的启动模式，处理比较繁琐。
> 3. 改造已有的模块比较繁琐。

#### 1.3 欺骗系统

先看一下具体Activity的启动流程，默认大家对Activity的启动流程比较了解了：

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728097781318.webp) 

整个过程中，同样也需要一个占位Activity。

使用步骤如下：

1. 在途中的第一步，启动PluginActivity跳转的时候，通过Instrument处理的时候，会将PluginActivity的Intent改成占位Activity的Intent，并存入原始Activity的信息。
2. 在图片中的第十三步，等系统验证完成回来创建占位Activity的实例对象，就替换成PluginActivity。
3. 最终，系统以为自己调用的是占位Activity的对象，并且和实际上调用的是PluginActivity进行绑定。 

## 3.资源加载

最终使用之前，我们在插件中的Android资源文件并不能使用，比如说图片、字符串、布局文件等，原因是插件的资源路径并没有被添加。 

Apk安装以后，我们都是通过 Resource 对象去访问资源，简单看一下 Resouce 的构造方法： 

```java
@Deprecated  
public Resources(AssetManager assets, DisplayMetrics metrics, Configuration config) {  
    this(null);  
    mResourcesImpl = new ResourcesImpl(assets, metrics, config, new DisplayAdjustments());  
}
```

可以看到，构造函数中有一个参数是 AssetManager，**可以通过在 AssetManager 中，加入插件的资源地址，就可以访问到插件中的资源。** 



现在可以访问具体的资源了，和之前的类加载方式类似，也有两种加载方式：

- **合并式**：插件和宿主资源可以互相访问，要处理**资源冲突**。
- **独立式**：无需处理资源冲突，宿主和插件的资源访问比较难处理。

### **解决资源冲突**

宿主和插件包都是独立编译的，所以打包的时候生成的资源Id会存在相同的情况，这个时候，访问的的时候就存在资源冲突 

**资源id是8位16进制数表示：** 

 ![图片](E:\kevin\kevDir\安卓学习\学习文档\Android2\插件化开发.assets\640-1728098043935.webp) 

如上图：

- **PP为Package Id，代表应用类型**：如系统应用、第三方应用、dynamic feature等。
- **TT为资源类型**：如drawabl、layout和string。
- **EEEE为Entry**：代表资源顺序。

所以对不同的插件包，进行打包的时候，前面的PP字段，可以进行依次递减，可以避免资源冲突的问题。常用的方案有：

1. 修改AAPT生成ResourceId，在编译期间完成修改。
2. 修改resouce.arsc文件。

**Qigsaw就是使用的第一种方案**