

# 分屏操作





# 原理分析

> 参考——[分屏功能原理(Android12L)](https://mp.weixin.qq.com/s/b6d2vupUG0TtM0l-jsgIHQ)

## 1.初始化阶段

①SystemUI在**进程**的初始化阶段准备好了分屏需要的**`MainStage和SlideStage`**对象，这两个对象分别负责分屏的一边。

②这两个对象的内部会创建一个**`RootTask`**节点（利用WindowOrganizer能力），把应用的`Task`节点挂载到`RootTask`下面，通过修改Bounds来改变应用显示的大小。

```java
//frameworks/base/libs/WindowManager/Shell/src/com/android/wm/shell/ShellInitImpl.javaShellInitImpl.java
private void init() {
    // 会为分屏功能分别创建 MainStage 和 SideStage （内部又会创建一个RootTask节点）
    mSplitScreenOptional.ifPresent(SplitScreenController::onOrganizerRegistered);
}

// StageTaskListener.java
StageTaskListener(...) {
    taskOrganizer.createRootTask(displayId, WINDOWING_MODE_MULTI_WINDOW, this);
}
```

## 2.触发分屏阶段

①点击分屏按钮后，Launcher3通知SystemUI触发分屏功能。

②紧接着SystemUI进程触发分屏的操作

```java
//frameworks/base/libs/WindowManager/Shell/src/com/android/wm/shell/splitscreen/StageCoordinator.java
void startTasksWithLegacyTransition(int mainTaskId, @Nullable Bundle mainOptions,
                                    int sideTaskId, @Nullable Bundle sideOptions, @SplitPositionint sidePosition,
                                    float splitRatio, RemoteAnimationAdapter adapter) {
    // 1）显示分屏中间的View
    setDividerVisibility(true/* visible */ );
    final WindowContainerTransaction wct = new WindowContainerTransaction();

    mSplitLayout.setDivideRatio(splitRatio);
    if (mMainStage.isActive()) {
        mMainStage.moveToTop(getMainStageBounds(), wct);
    } else {
        // Build a request WCT that will launch both apps such that task 0 is on the main stage
        // while task 1 is on the side stage.
        // 2）设置mMainStage对应的RootTask的Bounds并移动到最前面
        mMainStage.activate(getMainStageBounds(), wct, false/* reparent */ );
    }
    // 3）设置mSideStage对应的RootTask的Bounds并移动到最前面
    mSideStage.moveToTop(getSideStageBounds(), wct);

    // 配置launch task的option，让分屏应用的task启动到RootTask节点之下
    // Make sure the launch options will put tasks in the corresponding split roots
    addActivityOptions(mainOptions, mMainStage);
    addActivityOptions(sideOptions, mSideStage);
    // 4）启动分屏应用，启动方式和从任务管理器启动是一样的，startActivityFromRecents
    // Add task launch requests
    wct.startTask(mainTaskId, mainOptions);
    wct.startTask(sideTaskId, sideOptions);
    // 所有修改封装到WindowContainerTransaction中然后通过WindowOrganizer框架完成上面的变化
    // Using legacy transitions, so we can't use blast sync since it conflicts.
    mTaskOrganizer.applyTransaction(wct);
}
```



## 3.分屏拉伸阶段

