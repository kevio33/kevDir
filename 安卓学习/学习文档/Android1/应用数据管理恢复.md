

## 一、管理组件生命周期

具体参考`JetPack`笔记

## 二、ViewModel

具体参考ViewModel笔记



## 三、LiveData

具体参考LiveData笔记

## 四、butter knife

http://jakewharton.github.io/butterknife/

> 以及被启用，推荐使用`dataBinding`替换buttert knife

## 五、onSaveInstanceState

在某些情况下，您的 Activity 会因`正常的应用行为而被销毁`，**例如当用户按下返回按钮或您的 Activity 通过调用`finish()`方法发出销毁信号时。当您的 Activity 因用户按下返回按钮或因其自行结束而被销毁时，系统和用户对该 `Activity`实例的概念将永远消失。**在这些情况下，用户的期望与系统行为相匹配，您无需完成任何额外工作。

但是，如果系统因系统限制（例如配置变更或内存压力）而销毁 Activity，虽然实际的 `Activity` 实例会消失，但`系统会记住它曾经存在过`。*如果用户尝试回退到该 Activity，系统将使用一组描述 Activity 销毁时状态的已保存数据新建该 Activity 的实例。*

**(1)使用onSaveInstanceState() 保存简单轻量的界面状态**

当Activity停止时，系统会调用onSaveInstanceState方法，将状态信息保存到实例状态 Bundle 中。**此方法默认实现保存有关 Activity 视图层次结构状态的瞬时信息**，例如 `EditText` 微件中的文本或 `ListView` 微件的滚动位置。

如果想要保存其他状态，需要重写:

`如果您希望默认实现保存视图层次结构的状态，必须调用父类实现。`

```java
static final String STATE_SCORE = "playerScore";
static final String STATE_LEVEL = "playerLevel";
// ...

@Override
public void onSaveInstanceState(Bundle savedInstanceState) {
    // Save the user's current game state
    savedInstanceState.putInt(STATE_SCORE, currentScore);
    savedInstanceState.putInt(STATE_LEVEL, currentLevel);

    // Always call the superclass so it can save the view hierarchy state
    super.onSaveInstanceState(savedInstanceState);
}
```



**恢复保存的状态：**

在onCreate中：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState); // Always call the superclass first

    // Check whether we're recreating a previously destroyed instance
    if (savedInstanceState != null) {
        // Restore value of members from saved state
        currentScore = savedInstanceState.getInt(STATE_SCORE);
        currentLevel = savedInstanceState.getInt(STATE_LEVEL);
    } else {
        // Probably initialize members with default values for a new instance
    }
    // ...
}
```

在onRestoreInstanceState()恢复,您可以选择实现系统在 [`onStart()`] 方法调用的 [`onRestoreInstanceState()`]，而不是在 [`onCreate()`] 期间恢复状态。仅当存在要恢复的已保存状态时，系统才会调用 [`onRestoreInstanceState()`]，因此您无需检查 [`Bundle`]是否为 null：

```java
public void onRestoreInstanceState(Bundle savedInstanceState) {
    // Always call the superclass so it can restore the view hierarchy
    super.onRestoreInstanceState(savedInstanceState);

    // Restore state members from saved instance
    currentScore = savedInstanceState.getInt(STATE_SCORE);
    currentLevel = savedInstanceState.getInt(STATE_LEVEL);
}
```



## 六、界面状态保存

下表是对几种界面保存状态方法的优缺点归纳

|                                                      | ViewModel                              | 保存的实例状态                             | 永久性存储空间                              |
| ---------------------------------------------------- | -------------------------------------- | ------------------------------------------ | ------------------------------------------- |
| 存储位置                                             | 在内存中                               | 在内存中                                   | 在磁盘或网络上                              |
| 在配置更改后继续存在                                 | 是                                     | 是                                         | 是                                          |
| 在系统发起的进程终止后继续存在                       | 否                                     | 是                                         | 是                                          |
| 在用户完全关闭 activity 或触发 onFinish() 后继续存在 | 否                                     | 否                                         | 是                                          |
| 数据限制                                             | 支持复杂对象，但是空间受可用内存的限制 | 仅适用于基元类型和简单的小对象，例如字符串 | 仅受限于磁盘空间或从网络资源检索的成本/时间 |
| 读取/写入时间                                        | 快（仅限内存访问）                     | 慢（需要序列化/反序列化和磁盘访问）        | 慢（需要磁盘访问或网络事务）                |

> 参考——https://developer.android.google.cn/topic/libraries/architecture/saving-states?hl=zh-cn



# MVVM开发

## 一、databinding

> [databinding详解](https://juejin.cn/post/6844904085800353805)

`DataBinding` 是 `Google` 在 `Jetpack` 中推出的一款数据绑定的支持库，利用该库可以实现在页面组件中直接绑定应用程序的数据源。数据能够单向或双向绑定到 layout 文件中，有助于防止内存泄漏，而且能自动进行空检测以避免空指针异常。使其维护起来更加方便，架构更明确简介。 `DataBinding`是 `MVVM` 模式在 `Android` 上的一种实现，用于降低布局和逻辑的耦合性，使代码逻辑更加清晰。`DataBinding` 能够省去一直以来的 `findViewById()` 步骤，大量减少 Activity 内的代码。



### 1.启用databinding

```
android {
        ...
        dataBinding {
            enabled = true
        }
    }
```



### 2.布局文件的配置

在xml布局中使用` <data></data> `标签来描述，在该标签中添加` <variable name="data" type="com.example.databinding.MyViewModel"/> `，这里的`name`描述了可以在这个布局中使用的属性,`type`则表示该属性所属类的详细路径,如下：

```xml
<?xml version="1.0" encoding="utf-8"?>
<layout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools">
    <data>
        <variable
            name="date"
            type="com.example.databinding.MyViewModel" />
    </data>
</layout>

```

> 如果 `date` 类型要多处用到，也可以直接将之 **import** 进来，这样就不用每次都指明整个包名路径了，而 `java.lang.*` 包中的类会被自动导入，所以可以直接使用
>
> > 不知道为何会报错
>
> ```xml
> <data>
>     <import type="com.example.databinding.MyViewModel"/>
>     <variable
>               name="date"
>               type="date"/>
> </data>
> 
> ```

布局中，使用`@{}`使用属性、方法

```xml
<!--在标签中使用属性-->
<TextView
          android:layout_width="wrap_content"
          android:layout_height="wrap_content"
          android:text="@{String.valueOf(date.number)}"
          app:layout_constraintBottom_toBottomOf="parent"
          app:layout_constraintEnd_toEndOf="parent"
          app:layout_constraintStart_toStartOf="parent"
          app:layout_constraintTop_toTopOf="parent" />


<Button
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="增加"
        android:onClick="@{()->date.add()}"
        />
```

> 完整布局
>
> ```xml
> <?xml version="1.0" encoding="utf-8"?>
> <layout xmlns:android="http://schemas.android.com/apk/res/android"
> xmlns:app="http://schemas.android.com/apk/res-auto"
> xmlns:tools="http://schemas.android.com/tools">
>     <data>
>         <variable
>             name="date"
>             type="com.example.mvvm_news.viewmodel.DateViewModel" />
>     </data>
> 
>     <LinearLayout
>         android:layout_width="match_parent"
>         android:layout_height="match_parent"
>         android:gravity="center"
>         android:orientation="vertical">
>         <TextView
>             android:layout_width="wrap_content"
>             android:layout_height="wrap_content"
>             android:text="@{String.valueOf(date.number)}"
>             app:layout_constraintBottom_toBottomOf="parent"
>             app:layout_constraintEnd_toEndOf="parent"
>             app:layout_constraintStart_toStartOf="parent"
>             app:layout_constraintTop_toTopOf="parent" />
>         <Button
>             android:layout_width="wrap_content"
>             android:layout_height="wrap_content"
>             android:text="增加"
>             android:onClick="@{()->date.add()}"
>             />
>     </LinearLayout>
>     
> </layout>
> ```

创建一个`ViewModel`类，用其来承载视图的相关数据及方法 

```java
public class MyViewModel extends ViewModel {
    private MutableLiveData<Integer> number;
    public MutableLiveData<Integer> getNumber() {
        if (number == null){
            number = new MutableLiveData<>();
            number.setValue(0);
        }
        return number;
    }
    public void add(){
        number.setValue(number.getValue()+1);
    }
}
```

将数据与视听双向绑定

```java
public class MainActivity extends AppCompatActivity {

    DateViewModel dateViewModel;
    ActivityMainBinding mainBinding;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // setContentView(R.layout.activity_main);
        // 使用binding的DataBindingUtil.setContentView()方法绑定布局
        mainBinding = DataBindingUtil.setContentView(this,R.layout.activity_main);
        // 创建myViewModel对象
        dateViewModel = new ViewModelProvider(this).get(DateViewModel.class);

        // 将具体的值绑定进去,就是将 ViewModel 绑定进去
        mainBinding.setDate(dateViewModel);
        // 刷新
        mainBinding.setLifecycleOwner(this);
    }
}
```

