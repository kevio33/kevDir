

## 一、管理组件生命周期

具体参考`JetPack`笔记

## 二、ViewModel

具体参考ViewModel笔记



## 三、LiveData

具体参考LiveData笔记

## 四、butter knife

http://jakewharton.github.io/butterknife/

> 以及被启用，推荐使用`dataBinding`替换buttert knife

## 五、onSaveInstanceState

在某些情况下，您的 Activity 会因`正常的应用行为而被销毁`，**例如当用户按下返回按钮或您的 Activity 通过调用`finish()`方法发出销毁信号时。当您的 Activity 因用户按下返回按钮或因其自行结束而被销毁时，系统和用户对该 `Activity`实例的概念将永远消失。**在这些情况下，用户的期望与系统行为相匹配，您无需完成任何额外工作。

但是，如果系统因系统限制（例如配置变更或内存压力）而销毁 Activity，虽然实际的 `Activity` 实例会消失，但`系统会记住它曾经存在过`。*如果用户尝试回退到该 Activity，系统将使用一组描述 Activity 销毁时状态的已保存数据新建该 Activity 的实例。*

**(1)使用onSaveInstanceState() 保存简单轻量的界面状态**

当Activity停止时，系统会调用onSaveInstanceState方法，将状态信息保存到实例状态 Bundle 中。**此方法默认实现保存有关 Activity 视图层次结构状态的瞬时信息**，例如 `EditText` 微件中的文本或 `ListView` 微件的滚动位置。

如果想要保存其他状态，需要重写:

`如果您希望默认实现保存视图层次结构的状态，必须调用父类实现。`

```java
static final String STATE_SCORE = "playerScore";
static final String STATE_LEVEL = "playerLevel";
// ...

@Override
public void onSaveInstanceState(Bundle savedInstanceState) {
    // Save the user's current game state
    savedInstanceState.putInt(STATE_SCORE, currentScore);
    savedInstanceState.putInt(STATE_LEVEL, currentLevel);

    // Always call the superclass so it can save the view hierarchy state
    super.onSaveInstanceState(savedInstanceState);
}
```



**恢复保存的状态：**

在onCreate中：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState); // Always call the superclass first

    // Check whether we're recreating a previously destroyed instance
    if (savedInstanceState != null) {
        // Restore value of members from saved state
        currentScore = savedInstanceState.getInt(STATE_SCORE);
        currentLevel = savedInstanceState.getInt(STATE_LEVEL);
    } else {
        // Probably initialize members with default values for a new instance
    }
    // ...
}
```

在onRestoreInstanceState()恢复,您可以选择实现系统在 [`onStart()`] 方法调用的 [`onRestoreInstanceState()`]，而不是在 [`onCreate()`] 期间恢复状态。仅当存在要恢复的已保存状态时，系统才会调用 [`onRestoreInstanceState()`]，因此您无需检查 [`Bundle`]是否为 null：

```java
public void onRestoreInstanceState(Bundle savedInstanceState) {
    // Always call the superclass so it can restore the view hierarchy
    super.onRestoreInstanceState(savedInstanceState);

    // Restore state members from saved instance
    currentScore = savedInstanceState.getInt(STATE_SCORE);
    currentLevel = savedInstanceState.getInt(STATE_LEVEL);
}
```



## 六、界面状态保存

下表是对几种界面保存状态方法的优缺点归纳

|                                                      | ViewModel                              | 保存的实例状态                             | 永久性存储空间                              |
| ---------------------------------------------------- | -------------------------------------- | ------------------------------------------ | ------------------------------------------- |
| 存储位置                                             | 在内存中                               | 在内存中                                   | 在磁盘或网络上                              |
| 在配置更改后继续存在                                 | 是                                     | 是                                         | 是                                          |
| 在系统发起的进程终止后继续存在                       | 否                                     | 是                                         | 是                                          |
| 在用户完全关闭 activity 或触发 onFinish() 后继续存在 | 否                                     | 否                                         | 是                                          |
| 数据限制                                             | 支持复杂对象，但是空间受可用内存的限制 | 仅适用于基元类型和简单的小对象，例如字符串 | 仅受限于磁盘空间或从网络资源检索的成本/时间 |
| 读取/写入时间                                        | 快（仅限内存访问）                     | 慢（需要序列化/反序列化和磁盘访问）        | 慢（需要磁盘访问或网络事务）                |

> 参考——https://developer.android.google.cn/topic/libraries/architecture/saving-states?hl=zh-cn



