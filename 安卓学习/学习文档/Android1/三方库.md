

# 一、图片加载

## Glide

> https://github.com/bumptech/glide

### 1.前言

它支持拉取、解码、展示，视频快照、图片和GIF动画。提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。Glide 使用简明的流式（链式）语法API，这是一个非常棒的设计，因为它允许你在大部分情况下一行代码搞定需求，因此搞懂这条链式调用的代码都做了什么准备工作，Glide图片加载的大概框架也就明白了许多。

```java
Glide.with(context)
    .load(url)
    .into(imageView);
```

```groovy
implementation 'com.github.bumptech.glide:glide:4.11.0'
```



### 2.常用方法:

#### 	1.with()

```java
    with(Context context). 使用Application上下文，Glide请求将不受Activity/Fragment生命周期控制。最常用（可以解决部分内存泄漏问题）

    with(Activity activity).使用Activity作为上下文，Glide的请求会受到Activity生命周期控制。

    with(FragmentActivity activity).Glide的请求会受到FragmentActivity生命周期控制。

    with(android.app.Fragment fragment).Glide的请求会受到Fragment 生命周期控制。

    with(android.support.v4.app.Fragment fragment).Glide的请求会受到Fragment生命周期控制。
```



With() 通过RequestManagerRetriever的单例，静态get方法拿到其对象实例，然后通过成员函数get方法，通过getApplicationManager(Context)方法最终拿到RequestManager实例。

```java
//1 Context
public static RequestManager with(Context context) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        /**
          *  retriever  n. （训练成能寻回猎物的）寻回犬；取回的人，挽救者
          */
        return retriever.get(context);
    }
//2 Activity
public static RequestManager with(Activity activity) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(activity);
    }
//3 FragmentActivity
public static RequestManager with(FragmentActivity activity) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(activity);
    }
//4 android.app.Fragment
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public static RequestManager with(android.app.Fragment fragment) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(fragment);
    }
//5 Fragment
 public static RequestManager with(Fragment fragment) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(fragment);
    }
```

上面共有五种with方法重载。都是调用RequestManagerRetriever类的静态get方法获取到实例对象，属于是一个饿汉式单例模式。然后，再将参数传入retriever对象的get方法中，拿到RequestManager对象。

Glide需要拿到加载的生命周期，当我们在Activity加载一张图片，图片还没有加载，Activity就被销毁了，那图片就不用加载。把Glide放到Fragment中，当Activity销毁，Fragment是可以监听到的，这样也可以实现需求。

#### 	2.load()

load()方法通过fromString()调用loadGeneric()，返回asBitmap()相关的DrawableTypeRequest对象，调用DrawableRequestBuilder父类中load方法，给父类成员变量赋值后，在RequestManager类中将DrawableRequestBuilder父类对象强转成子类DrawableTypeRequest。load方法最终拿到了DrawableTypeRequest对象。

```java
load(Uri uri)，

load(File file)，

load(Integer resourceId)，//加载本地resource

load(URL url)，

load(byte[] model)，

load(T model)，

loadFromMediaStore(Uri uri)。
    
1、load SD卡资源：

load("file://"+Environment.getExternalStorageDirectory().getPath()+"/xxx.jpg")

2、load assets资源：

load("file:///android_asset/xxx.gif") 

3、load drawable资源(可以是图片也可以是gif)：

load(R.drawable.xxx)

4、load mipmap资源(可以是图片也可以是gif)：

load(R.mipmap.xxx)

5、load raw资源：

load("android.resource://包名/raw/raw_1")

或load("android.resource://包名/raw/"+R.raw.raw_1)

或load(R.raw.raw_1)

6、load ContentProvider资源：

load("content://media/external/images/media/139469")

7、load http资源：

load("http://xxxxxxx.jpg")

8、load https资源：

load("https://xxxxxxx.jpg") 
```



#### 	3.into()

概述：①初始化各种参数，做好准备工作（网络请求、基于MVP的各种接口回调），②使用最原始的HTTPConnect网络连接，读取文件流，③根据文件判断是GIF动图还是Bitmap静态图片，④通过相关复杂逻辑将下载的图片资源取出来，赋值给ImageView控件。



```java
1、thumbnail(float sizeMultiplier)

 请求给定系数的缩略图。如果缩略图比全尺寸图先加载完，就显示缩略图，否则就不显示。系数sizeMultiplier必须在(0,1)之间，可以递归调用该方法。

2、sizeMultiplier(float sizeMultiplier)

 在加载资源之前给Target大小设置系数。用于装载缩略图，避免加载大量资源。

3、 diskCacheStrategy(DiskCacheStrategy strategy)

设置缓存策略。

DiskCacheStrategy.SOURCE：缓存原始数据，
DiskCacheStrategy.RESULT：缓存变换(如缩放、裁剪等)后的资源数据，
DiskCacheStrategy.NONE：什么都不缓存，
DiskCacheStrategy.ALL：缓存SOURC和RESULT。
默认采用DiskCacheStrategy.RESULT策略，对于download only操作要使用DiskCacheStrategy.SOURCE。

4、priority(Priority priority)

指定加载的优先级，优先级越高越优先加载，但不保证所有图片都按序加载。
枚举  Priority.IMMEDIATE，Priority.HIGH，Priority.NORMAL，Priority.LOW。默认为Priority.NORMAL。

5、 dontAnimate(). 移除所有的动画。

6、 animate(int animationId)

 在异步加载资源完成时会执行该动画。

7、 animate(ViewPropertyAnimation.Animator animator). 

在异步加载资源完成时会执行该动画。

8、 placeholder(int resourceId)

 设置资源加载过程中的占位Drawable。

9、 placeholder(Drawable drawable)

 设置资源加载过程中的占位Drawable。

10、fallback(int resourceId)

 设置model为空时要显示的Drawable。如果没设置fallback，model为空时将显示error的Drawable，如果error的Drawable也没设置，就显示placeholder的Drawable。

11、 fallback(Drawable drawable)

设置model为空时显示的Drawable。

12、error(int resourceId)

设置load失败时显示的Drawable。

13、error(Drawable drawable)

设置load失败时显示的Drawable。

14、listener(RequestListener<? super ModelType, TranscodeType> requestListener)

监听资源加载的请求状态，可以使用两个回调：

onResourceReady(R resource, T model, Target<R> target, boolean isFromMemoryCache, boolean isFirstResource)

和onException(Exception e, T model, Target&lt;R&gt; target, boolean isFirstResource)，

但不要每次请求都使用新的监听器，要避免不必要的内存申请，可以使用单例进行统一的异常监听和处理。

15、skipMemoryCache(boolean skip)

 设置是否跳过内存缓存，但不保证一定不被缓存（比如请求已经在加载资源且没设置跳过内存缓存，这个资源就会被缓存在内存中）。

16、 override(int width, int height)

重新设置Target的宽高值（单位为pixel）。

17、into(Y target)

设置资源将被加载到的Target。

18、into(ImageView view)

 设置资源将被加载到的ImageView。取消该ImageView之前所有的加载并释放资源。

19、into(int width, int height)

 后台线程加载时要加载资源的宽高值（单位为pixel）。

20、 preload(int width, int height). 预加载resource到缓存中（单位为pixel）。

21、 asBitmap()

 无论资源是不是gif动画，都作为Bitmap对待。如果是gif动画会停在第一帧。
 注意：先load()再asBitmap()，不然报错！（与Glide4有区别）

22、asGif()

把资源作为GifDrawable对待。如果资源不是gif动画将会失败，会回调.error()。

23、dontTransform()

表示让Glide在加载图片的过程中不进行图片变换，这样applyCenterCrop()、applyFitCenter()就统统无效了，显示原图大小

24、downloadOnly()直接下载
```



**清空缓存**

```java
禁止内存缓存：

.skipMemoryCache(true)

清除内存缓存：

// 必须在UI线程中调用
Glide.get(context).clearMemory();

禁止磁盘缓存：

.diskCacheStrategy(DiskCacheStrategy.NONE)

清除磁盘缓存：

// 必须在后台线程中调用，建议同时clearMemory()
Glide.get(applicationContext).clearDiskCache();
```



**直接获得Bitmap**

有些时候我们并不希望把图片放入ImageView中。我们只要 Bitmap 本身。Glide 提供了一个用 Targets 的简单的方式去接受图片资源的 Bitmap。Targets 是回调函数，它在 Glide 做完所有的加载和处理之后返回结果。

```java
//方法1
Glide.with(this).load(url).asBitmap().into(newSimpleTarget<Bitmap>() {
    @Override
    public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap>glideAnimation) {
         //resource即是获得的Bitmap
    }
});

//方法2:该方式只能在子线程中获得
Bitmap bitmap =Glide.with(MainActivity.this).load(url).asBitmap().into(500, 500).get();
```

**下载图片到本地**

```java
new Thread(new Runnable() {
            @Override
            public void run() {
                FutureTarget<File> fileFutureTarget = Glide.with(UIUtils.getContext())
                        .load(url)
                        .downloadOnly(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
                try {
                    final File file = fileFutureTarget.get();
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            mPath.setText(file.getPath());
                        }
                    });
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        }).start();
```

**获取bitmap对象**

```java
new Thread(new Runnable() {

            private Bitmap bitmap;

            @Override
            public void run() {
                try {
                    bitmap = Glide.with(UIUtils.getContext())
                            .load(url)
                            .asBitmap()
                            .into(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
                            .get();
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            mIv.setImageBitmap(bitmap);
                        }
                    });
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        }).start();
```

**加载GIF**

```java
//普通显示GIF
Glide.with( context ).load( gifUrl ).into( iv );

//添加GIF检查，如果不是GIF就会显示加载失败位图
Glide.with( context ).load( gifUrl ).asGif().into( iv);
```

**显示本地视频**

```java
String filePath ="/storage/emulated/0/Pictures/xxx.mp4";
Glide 
    .with(context )
    .load(Uri.fromFile( new File( filePath ) ) )
    .into( iv );

//Glid只能加载本地视频，不能从网络中获取
```

**显示圆形图片**

```java
 Glide.with(this).load(R.raw.icon_added)
                .asBitmap()
                .diskCacheStrategy(DiskCacheStrategy.ALL)
                .thumbnail(0.1f)
                .centerCrop()
                .into(new BitmapImageViewTarget(mIv) {
                    @Override
                    protected void setResource(Bitmap resource) {
                        RoundedBitmapDrawable circularBitmapDrawable =
                                RoundedBitmapDrawableFactory.create(MainActivity.this.getResources(),
                                        resource);
                        circularBitmapDrawable.setCircular(true);
                        mIv.setImageDrawable(circularBitmapDrawable);
                    }
                });
```

**先显示略缩图，在显示原图：**

```java
 //用原图的1/10作为缩略图
    Glide
        .with(this)
        .load("http://xxx.png")
        .thumbnail(0.1f)
        .into(iv_0);
    //用其它图片作为缩略图
    DrawableRequestBuilder<Integer> thumbnailRequest = Glide
        .with(this)
        .load(R.drawable.ic_logo);
    Glide.with(this)
        .load("http://xxx.png")
        .thumbnail(thumbnailRequest)
        .into(mIv);
```

**设置监听请求，监控请求发生错误来源，以及图片来源是内存还是磁盘**

```java
Glide.with(this).load(imageUrl).listener(new RequestListener<String, GlideDrawable>() {
            @Override
            public boolean onException(Exception e, String model, Target<GlideDrawable> target, boolean isFirstResource) {
                return false;
            }

            @Override
            public boolean onResourceReady(GlideDrawable resource, String model, Target<GlideDrawable> target, boolean isFromMemoryCache, boolean isFirstResource) {
                //imageView.setImageDrawable(resource);
                return false;
            }
        }).into(imageView);
```

### 3.圆角图片

```java
// 圆角图片
Glide.with(context)
    .load("url")
    .transform(new RoundedCorners(8)) // 数字根据自己需求来改
    .into(imageView)
    
// 圆形图片
Glide.with(context)
    .load("url")
    .transform(new CircleCrop()) // 数字根据自己需求来改
    .into(imageView)
```







## picasso库

> https://github.com/square/picasso

**Picasso** 是一个用于 Android 平台的图片加载库，它可以帮助开发者轻松地加载和显示图片。Picasso 的主要功能包括：

- **异步加载图片**：Picasso 可以异步加载图片，避免阻塞主线程。
- **缓存图片**：Picasso 可以缓存图片，避免重复加载。
- **转换图片**：Picasso 可以对图片进行转换，例如缩放、旋转、裁剪等。
- **显示图片**：Picasso 可以将图片显示到 ImageView 等视图中。



```java
Picasso.with(context).load(R.mipmap.header).into(((MyViewHolder) holder).imageHeader);
```

如果要改变图片的形状

```java
//实现transfor接口
public class CircleTransform implements Transformation {

    @Override
    public Bitmap transform(Bitmap source) {
        int size = Math.min(source.getWidth(), source.getHeight());
        int x = (source.getWidth() - size) / 2;
        int y = (source.getHeight() - size) / 2;
        Bitmap squaredBitmap = Bitmap.createBitmap(source, x, y, size, size);
        if (squaredBitmap != source) {
            source.recycle();
        }
        Bitmap bitmap = Bitmap.createBitmap(size, size, source.getConfig());
        Canvas canvas = new Canvas(bitmap);
        Paint paint = new Paint();
        BitmapShader shader = new BitmapShader(squaredBitmap,
                                               BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP);
        paint.setShader(shader);
        paint.setAntiAlias(true);
        float r = size / 2f;
        canvas.drawCircle(r, r, r, paint);
        squaredBitmap.recycle();
        return bitmap;
    }

    @Override
    public String key() {
        return "circle";
    }
}
```

```java
//调用
Picasso.with(context).load(R.mipmap.header).transform(new CircleTransform()).into(((MyViewHolder) holder).imageHeader);//返回的图片链接访问不了，统一使用本地的图片
```





## Fresco

> https://github.com/facebook/fresco

 Fresco 是 Facebook 开发的一个开源图片加载库，用于 Android 平台。它可以帮助开发者轻松地加载和显示图片 

# 二、导航栏

## 1.CommonTabLayout

> https://github.com/H07000223/FlycoTabLayout

# 三、音视频播放

## 1 dueeekeVideoPlayer

> https://github.com/Doikki/DKVideoPlayer



布局文件引入了播放器的试图

```xml
<xyz.doikki.videocontroller.component.PrepareView
                                                  android:id="@+id/prepare_view"
                                                  android:layout_width="match_parent"
                                                  android:layout_height="match_parent" />
```



是一个自定义View，源代码

```java
public class PrepareView extends FrameLayout implements IControlComponent {

    private ControlWrapper mControlWrapper;//播放控制器
    
    private ImageView mThumb;
    private ImageView mStartPlay;
    private ProgressBar mLoading;
    private FrameLayout mNetWarning;

    public PrepareView(@NonNull Context context) {
        super(context);
    }

    public PrepareView(@NonNull Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
    }

    public PrepareView(@NonNull Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }
    
    //代码块，填充视图，并且初始化组件
    {
        //1
        LayoutInflater.from(getContext()).inflate(R.layout.dkplayer_layout_prepare_view, this, true);
        mThumb = findViewById(R.id.thumb);
        mStartPlay = findViewById(R.id.start_play);
        mLoading = findViewById(R.id.loading);
        mNetWarning = findViewById(R.id.net_warning_layout);
        //设置状态的按钮
        findViewById(R.id.status_btn).setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mNetWarning.setVisibility(GONE);
                VideoViewManager.instance().setPlayOnMobileNetwork(true);
                mControlWrapper.start();
            }
        });
    }

    /**
     * 设置点击此界面开始播放
     */
    public void setClickStart() {
        setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                mControlWrapper.start();
            }
        });
    }

    @Override
    public void attach(@NonNull ControlWrapper controlWrapper) {
        mControlWrapper = controlWrapper;
    }

    @Override
    public View getView() {
        return this;
    }

    @Override
    public void onVisibilityChanged(boolean isVisible, Animation anim) {

    }

    //播放状态变化的回调
    @Override
    public void onPlayStateChanged(int playState) {
        switch (playState) {
            case VideoView.STATE_PREPARING:
                bringToFront();
                setVisibility(VISIBLE);
                mStartPlay.setVisibility(View.GONE);
                mNetWarning.setVisibility(GONE);
                mLoading.setVisibility(View.VISIBLE);
                break;
            case VideoView.STATE_PLAYING:
            case VideoView.STATE_PAUSED:
            case VideoView.STATE_ERROR:
            case VideoView.STATE_BUFFERING:
            case VideoView.STATE_BUFFERED:
            case VideoView.STATE_PLAYBACK_COMPLETED:
                setVisibility(GONE);
                break;
            case VideoView.STATE_IDLE:
                setVisibility(VISIBLE);
                bringToFront();
                mLoading.setVisibility(View.GONE);
                mNetWarning.setVisibility(GONE);
                mStartPlay.setVisibility(View.VISIBLE);
                mThumb.setVisibility(View.VISIBLE);
                break;
            case VideoView.STATE_START_ABORT:
                setVisibility(VISIBLE);
                mNetWarning.setVisibility(VISIBLE);
                mNetWarning.bringToFront();
                break;
        }
    }

    @Override
    public void onPlayerStateChanged(int playerState) {

    }

    @Override
    public void setProgress(int duration, int position) {

    }

    @Override
    public void onLockStateChanged(boolean isLocked) {

    }
}
```

> 上面注释1里面填充的布局文件
>
> ```xml
> <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
>     xmlns:tools="http://schemas.android.com/tools"
>     android:layout_width="match_parent"
>     android:layout_height="match_parent">
> 
>     <ImageView
>         android:id="@+id/thumb"
>         android:layout_width="match_parent"
>         android:layout_height="match_parent"
>         android:scaleType="centerCrop" />
> 
>     <ImageView
>         android:id="@+id/start_play"
>         android:layout_width="@dimen/dkplayer_play_btn_size"
>         android:layout_height="@dimen/dkplayer_play_btn_size"
>         android:layout_gravity="center"
>         android:background="@drawable/dkplayer_shape_play_bg"
>         android:padding="@dimen/dkplayer_default_spacing"
>         android:src="@drawable/dkplayer_selector_play_button" />
> 
>     <ProgressBar
>         android:id="@+id/loading"
>         android:layout_width="@dimen/dkplayer_play_btn_size"
>         android:layout_height="@dimen/dkplayer_play_btn_size"
>         android:layout_gravity="center"
>         android:indeterminateDrawable="@drawable/dkplayer_progress_loading"
>         android:indeterminateDuration="2000"
>         android:visibility="gone"
>         tools:visibility="visible" />
> 
>     <FrameLayout
>         android:id="@+id/net_warning_layout"
>         android:layout_width="match_parent"
>         android:layout_height="match_parent"
>         android:background="@android:color/black"
>         android:clickable="true"
>         android:focusable="true"
>         android:visibility="gone">
> 
>         <LinearLayout
>             android:layout_width="match_parent"
>             android:layout_height="match_parent"
>             android:gravity="center"
>             android:orientation="vertical">
> 
>             <TextView
>                 android:id="@+id/message"
>                 android:layout_width="wrap_content"
>                 android:layout_height="wrap_content"
>                 android:gravity="center"
>                 android:text="@string/dkplayer_wifi_tip"
>                 android:textColor="@android:color/white" />
> 
>             <TextView
>                 android:id="@+id/status_btn"
>                 android:layout_width="wrap_content"
>                 android:layout_height="wrap_content"
>                 android:layout_marginTop="16dp"
>                 android:background="@drawable/dkplayer_shape_status_view_btn"
>                 android:gravity="center"
>                 android:paddingLeft="16dp"
>                 android:paddingTop="4dp"
>                 android:paddingRight="16dp"
>                 android:paddingBottom="4dp"
>                 android:text="@string/dkplayer_continue_play"
>                 android:textColor="@android:color/white" />
> 
>         </LinearLayout>
>     </FrameLayout>
> 
> </FrameLayout>
> ```



在自己写的项目中，每一个fragment初始化了这几个变量

```java
public class VideoFragment extends Fragment implements OnItemChildClickListener, OnShareClickListener {
     //TODO
    private VideoView mVideoView;
    protected StandardVideoController mController;
    //TODO
    protected ErrorView mErrorView;
    //TODO
    protected CompleteView mCompleteView;
    //TODO
    protected TitleView mTitleView;

    /**
     * 当前播放的位置
     */
    protected int mCurPos = -1;
    
    
    /**
     * 初始化videoView
     */
    protected void initVideoView() {
        mVideoView = new VideoView(getActivity());
        mVideoView.setOnStateChangeListener(new VideoView.SimpleOnStateChangeListener() {
            @Override
            public void onPlayStateChanged(int playState) {
                //监听VideoViewManager释放，重置状态
                if (playState == VideoView.STATE_IDLE) {
                    Utils.removeViewFormParent(mVideoView);
                    mLastPos = mCurPos;
                    mCurPos = -1;
                }
            }
        });
        mController = new StandardVideoController(getActivity());
        mErrorView = new ErrorView(getActivity());
        mController.addControlComponent(mErrorView);
        mCompleteView = new CompleteView(getActivity());
        mController.addControlComponent(mCompleteView);
        mTitleView = new TitleView(getActivity());
        mController.addControlComponent(mTitleView);
        mController.addControlComponent(new VodControlView(getActivity()));
        mController.addControlComponent(new GestureView(getActivity()));
        mController.setEnableOrientation(true);
        mVideoView.setVideoController(mController);
    }
    
    /**
     * 开始播放
     * @param position 列表位置
     */
    protected void startPlay(int position) {
        if (mCurPos == position) return;
        if (mCurPos != -1) {
            releaseVideoView();
        }
        VideoEntity videoEntity = datas.get(position);

        //播放assets的视频
        AssetManager am = getActivity().getAssets();
        try {
            AssetFileDescriptor afd = am.openFd("1.mp4");// 注意这里的区别

            mVideoView.setAssetFileDescriptor(afd);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        mTitleView.setTitle(videoEntity.getVtitle());
        View itemView = mLinearLayoutManager.findViewByPosition(position);
        if (itemView == null) return;
        VideoFragAdapter.MyViewHolder viewHolder = (VideoFragAdapter.MyViewHolder) itemView.getTag();
        //把列表中预置的PrepareView添加到控制器中，注意isDissociate此处只能为true, 请点进去看isDissociate的解释
        mController.addControlComponent(viewHolder.mPrepareView, true);
        Utils.removeViewFormParent(mVideoView);
        viewHolder.playerConatainer.addView(mVideoView, 0);
        //播放之前将VideoView添加到VideoViewManager以便在别的页面也能操作它
        VideoViewManager.instance().add(mVideoView, Tag.LIST);
        mVideoView.start();
        mCurPos = position;
    }
}
```



**上面的initView**

主要做了几件事：

- 创建VideoView的实例
- 创建控制器的实例
- 创建errorView、TitleView、GestureView实例
- 将上面几个实例作为component放到controller，controller可能在不同情况下展示这几个页面
- 最后为videoView添加controller

```java
protected void initVideoView() {
    mVideoView = new VideoView(getActivity());
    mVideoView.setOnStateChangeListener(new VideoView.SimpleOnStateChangeListener() {
        @Override
        public void onPlayStateChanged(int playState) {
            //监听VideoViewManager释放，重置状态
            if (playState == VideoView.STATE_IDLE) {
                Utils.removeViewFormParent(mVideoView);
                mLastPos = mCurPos;
                mCurPos = -1;
            }
        }
    });
    mController = new StandardVideoController(getActivity());
    mErrorView = new ErrorView(getActivity());
    mController.addControlComponent(mErrorView);
    mCompleteView = new CompleteView(getActivity());
    mController.addControlComponent(mCompleteView);
    mTitleView = new TitleView(getActivity());
    mController.addControlComponent(mTitleView);
    mController.addControlComponent(new VodControlView(getActivity()));
    mController.addControlComponent(new GestureView(getActivity()));
    mController.setEnableOrientation(true);
    mVideoView.setVideoController(mController);
}
```



**然后是startPlay**

```java
/**
     * 开始播放
     * @param position 列表位置
     */
protected void startPlay(int position) {
    if (mCurPos == position) return;
    if (mCurPos != -1) {
        releaseVideoView();
    }
    VideoEntity videoEntity = datas.get(position);

    //播放assets的视频
    AssetManager am = getActivity().getAssets();
    try {
        //打开assets下的视频文件，返回一个AssetFileDescriptor对象
        AssetFileDescriptor afd = am.openFd("1.mp4");

        mVideoView.setAssetFileDescriptor(afd);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }

    mTitleView.setTitle(videoEntity.getVtitle());
    View itemView = mLinearLayoutManager.findViewByPosition(position);
    if (itemView == null) return;
    VideoFragAdapter.MyViewHolder viewHolder = (VideoFragAdapter.MyViewHolder) itemView.getTag();
    //把列表中预置的PrepareView添加到控制器中，注意isDissociate此处只能为true, 请点进去看isDissociate的解释
    mController.addControlComponent(viewHolder.mPrepareView, true);
    Utils.removeViewFormParent(mVideoView);
    viewHolder.playerConatainer.addView(mVideoView, 0);
    //播放之前将VideoView添加到VideoViewManager以便在别的页面也能操作它
    VideoViewManager.instance().add(mVideoView, Tag.LIST);
    mVideoView.start();
    mCurPos = position;
}
```







### 1.1读取raw/assets目录下的文件

> https://juejin.cn/post/6844903713828503559

# 四、加载刷新

## 1.SmartRefreshLayout

> https://gitee.com/scwang90/SmartRefreshLayout







# 主题换肤

> https://github.com/ximsfei/Android-skin-support
>
> [用例讲解](https://www.jianshu.com/p/2c3833b8a1d2)

# JsBridge

> https://github.com/lzyzsd/JsBridge

实现java和JS的通信，当app中需要跑H5代码时候可以用到

> 官方文档介绍：` It provides safe and convenient way to call Java code from js and call js code from java. `

