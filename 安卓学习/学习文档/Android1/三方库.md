

# 一、图片加载

## Glide

> https://github.com/bumptech/glide

### 1.前言

它支持拉取、解码、展示，视频快照、图片和GIF动画。提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。Glide 使用简明的流式（链式）语法API，这是一个非常棒的设计，因为它允许你在大部分情况下一行代码搞定需求，因此搞懂这条链式调用的代码都做了什么准备工作，Glide图片加载的大概框架也就明白了许多。

```java
Glide.with(context)
    .load(url)
    .into(imageView);
```

```groovy
implementation 'com.github.bumptech.glide:glide:4.11.0'
```



### 2.常用方法:

#### 	1.with()

```java
    with(Context context). 使用Application上下文，Glide请求将不受Activity/Fragment生命周期控制。最常用（可以解决部分内存泄漏问题）

    with(Activity activity).使用Activity作为上下文，Glide的请求会受到Activity生命周期控制。

    with(FragmentActivity activity).Glide的请求会受到FragmentActivity生命周期控制。

    with(android.app.Fragment fragment).Glide的请求会受到Fragment 生命周期控制。

    with(android.support.v4.app.Fragment fragment).Glide的请求会受到Fragment生命周期控制。
```



With() 通过RequestManagerRetriever的单例，静态get方法拿到其对象实例，然后通过成员函数get方法，通过getApplicationManager(Context)方法最终拿到RequestManager实例。

```java
//1 Context
public static RequestManager with(Context context) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        /**
          *  retriever  n. （训练成能寻回猎物的）寻回犬；取回的人，挽救者
          */
        return retriever.get(context);
    }
//2 Activity
public static RequestManager with(Activity activity) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(activity);
    }
//3 FragmentActivity
public static RequestManager with(FragmentActivity activity) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(activity);
    }
//4 android.app.Fragment
@TargetApi(Build.VERSION_CODES.HONEYCOMB)
    public static RequestManager with(android.app.Fragment fragment) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(fragment);
    }
//5 Fragment
 public static RequestManager with(Fragment fragment) {
        RequestManagerRetriever retriever = RequestManagerRetriever.get();
        return retriever.get(fragment);
    }
```

上面共有五种with方法重载。都是调用RequestManagerRetriever类的静态get方法获取到实例对象，属于是一个饿汉式单例模式。然后，再将参数传入retriever对象的get方法中，拿到RequestManager对象。

Glide需要拿到加载的生命周期，当我们在Activity加载一张图片，图片还没有加载，Activity就被销毁了，那图片就不用加载。把Glide放到Fragment中，当Activity销毁，Fragment是可以监听到的，这样也可以实现需求。

#### 	2.load()

load()方法通过fromString()调用loadGeneric()，返回asBitmap()相关的DrawableTypeRequest对象，调用DrawableRequestBuilder父类中load方法，给父类成员变量赋值后，在RequestManager类中将DrawableRequestBuilder父类对象强转成子类DrawableTypeRequest。load方法最终拿到了DrawableTypeRequest对象。

```java
load(Uri uri)，

load(File file)，

load(Integer resourceId)，//加载本地resource

load(URL url)，

load(byte[] model)，

load(T model)，

loadFromMediaStore(Uri uri)。
    
1、load SD卡资源：

load("file://"+Environment.getExternalStorageDirectory().getPath()+"/xxx.jpg")

2、load assets资源：

load("file:///android_asset/xxx.gif") 

3、load drawable资源(可以是图片也可以是gif)：

load(R.drawable.xxx)

4、load mipmap资源(可以是图片也可以是gif)：

load(R.mipmap.xxx)

5、load raw资源：

load("android.resource://包名/raw/raw_1")

或load("android.resource://包名/raw/"+R.raw.raw_1)

或load(R.raw.raw_1)

6、load ContentProvider资源：

load("content://media/external/images/media/139469")

7、load http资源：

load("http://xxxxxxx.jpg")

8、load https资源：

load("https://xxxxxxx.jpg") 
```



#### 	3.into()

概述：①初始化各种参数，做好准备工作（网络请求、基于MVP的各种接口回调），②使用最原始的HTTPConnect网络连接，读取文件流，③根据文件判断是GIF动图还是Bitmap静态图片，④通过相关复杂逻辑将下载的图片资源取出来，赋值给ImageView控件。



```java
1、thumbnail(float sizeMultiplier)

 请求给定系数的缩略图。如果缩略图比全尺寸图先加载完，就显示缩略图，否则就不显示。系数sizeMultiplier必须在(0,1)之间，可以递归调用该方法。

2、sizeMultiplier(float sizeMultiplier)

 在加载资源之前给Target大小设置系数。用于装载缩略图，避免加载大量资源。

3、 diskCacheStrategy(DiskCacheStrategy strategy)

设置缓存策略。

DiskCacheStrategy.SOURCE：缓存原始数据，
DiskCacheStrategy.RESULT：缓存变换(如缩放、裁剪等)后的资源数据，
DiskCacheStrategy.NONE：什么都不缓存，
DiskCacheStrategy.ALL：缓存SOURC和RESULT。
默认采用DiskCacheStrategy.RESULT策略，对于download only操作要使用DiskCacheStrategy.SOURCE。

4、priority(Priority priority)

指定加载的优先级，优先级越高越优先加载，但不保证所有图片都按序加载。
枚举  Priority.IMMEDIATE，Priority.HIGH，Priority.NORMAL，Priority.LOW。默认为Priority.NORMAL。

5、 dontAnimate(). 移除所有的动画。

6、 animate(int animationId)

 在异步加载资源完成时会执行该动画。

7、 animate(ViewPropertyAnimation.Animator animator). 

在异步加载资源完成时会执行该动画。

8、 placeholder(int resourceId)

 设置资源加载过程中的占位Drawable。

9、 placeholder(Drawable drawable)

 设置资源加载过程中的占位Drawable。

10、fallback(int resourceId)

 设置model为空时要显示的Drawable。如果没设置fallback，model为空时将显示error的Drawable，如果error的Drawable也没设置，就显示placeholder的Drawable。

11、 fallback(Drawable drawable)

设置model为空时显示的Drawable。

12、error(int resourceId)

设置load失败时显示的Drawable。

13、error(Drawable drawable)

设置load失败时显示的Drawable。

14、listener(RequestListener<? super ModelType, TranscodeType> requestListener)

监听资源加载的请求状态，可以使用两个回调：

onResourceReady(R resource, T model, Target<R> target, boolean isFromMemoryCache, boolean isFirstResource)

和onException(Exception e, T model, Target&lt;R&gt; target, boolean isFirstResource)，

但不要每次请求都使用新的监听器，要避免不必要的内存申请，可以使用单例进行统一的异常监听和处理。

15、skipMemoryCache(boolean skip)

 设置是否跳过内存缓存，但不保证一定不被缓存（比如请求已经在加载资源且没设置跳过内存缓存，这个资源就会被缓存在内存中）。

16、 override(int width, int height)

重新设置Target的宽高值（单位为pixel）。

17、into(Y target)

设置资源将被加载到的Target。

18、into(ImageView view)

 设置资源将被加载到的ImageView。取消该ImageView之前所有的加载并释放资源。

19、into(int width, int height)

 后台线程加载时要加载资源的宽高值（单位为pixel）。

20、 preload(int width, int height). 预加载resource到缓存中（单位为pixel）。

21、 asBitmap()

 无论资源是不是gif动画，都作为Bitmap对待。如果是gif动画会停在第一帧。
 注意：先load()再asBitmap()，不然报错！（与Glide4有区别）

22、asGif()

把资源作为GifDrawable对待。如果资源不是gif动画将会失败，会回调.error()。

23、dontTransform()

表示让Glide在加载图片的过程中不进行图片变换，这样applyCenterCrop()、applyFitCenter()就统统无效了，显示原图大小

24、downloadOnly()直接下载
```



**清空缓存**

```java
禁止内存缓存：

.skipMemoryCache(true)

清除内存缓存：

// 必须在UI线程中调用
Glide.get(context).clearMemory();

禁止磁盘缓存：

.diskCacheStrategy(DiskCacheStrategy.NONE)

清除磁盘缓存：

// 必须在后台线程中调用，建议同时clearMemory()
Glide.get(applicationContext).clearDiskCache();
```



**直接获得Bitmap**

有些时候我们并不希望把图片放入ImageView中。我们只要 Bitmap 本身。Glide 提供了一个用 Targets 的简单的方式去接受图片资源的 Bitmap。Targets 是回调函数，它在 Glide 做完所有的加载和处理之后返回结果。

```java
//方法1
Glide.with(this).load(url).asBitmap().into(newSimpleTarget<Bitmap>() {
    @Override
    public void onResourceReady(Bitmap resource, GlideAnimation<? super Bitmap>glideAnimation) {
         //resource即是获得的Bitmap
    }
});

//方法2:该方式只能在子线程中获得
Bitmap bitmap =Glide.with(MainActivity.this).load(url).asBitmap().into(500, 500).get();
```

**下载图片到本地**

```java
new Thread(new Runnable() {
            @Override
            public void run() {
                FutureTarget<File> fileFutureTarget = Glide.with(UIUtils.getContext())
                        .load(url)
                        .downloadOnly(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL);
                try {
                    final File file = fileFutureTarget.get();
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            mPath.setText(file.getPath());
                        }
                    });
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        }).start();
```

**获取bitmap对象**

```java
new Thread(new Runnable() {

            private Bitmap bitmap;

            @Override
            public void run() {
                try {
                    bitmap = Glide.with(UIUtils.getContext())
                            .load(url)
                            .asBitmap()
                            .into(Target.SIZE_ORIGINAL, Target.SIZE_ORIGINAL)
                            .get();
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            mIv.setImageBitmap(bitmap);
                        }
                    });
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        }).start();
```

**加载GIF**

```java
//普通显示GIF
Glide.with( context ).load( gifUrl ).into( iv );

//添加GIF检查，如果不是GIF就会显示加载失败位图
Glide.with( context ).load( gifUrl ).asGif().into( iv);
```

**显示本地视频**

```java
String filePath ="/storage/emulated/0/Pictures/xxx.mp4";
Glide 
    .with(context )
    .load(Uri.fromFile( new File( filePath ) ) )
    .into( iv );

//Glid只能加载本地视频，不能从网络中获取
```

**显示圆形图片**

```java
 Glide.with(this).load(R.raw.icon_added)
                .asBitmap()
                .diskCacheStrategy(DiskCacheStrategy.ALL)
                .thumbnail(0.1f)
                .centerCrop()
                .into(new BitmapImageViewTarget(mIv) {
                    @Override
                    protected void setResource(Bitmap resource) {
                        RoundedBitmapDrawable circularBitmapDrawable =
                                RoundedBitmapDrawableFactory.create(MainActivity.this.getResources(),
                                        resource);
                        circularBitmapDrawable.setCircular(true);
                        mIv.setImageDrawable(circularBitmapDrawable);
                    }
                });
```

**先显示略缩图，在显示原图：**

```java
 //用原图的1/10作为缩略图
    Glide
        .with(this)
        .load("http://xxx.png")
        .thumbnail(0.1f)
        .into(iv_0);
    //用其它图片作为缩略图
    DrawableRequestBuilder<Integer> thumbnailRequest = Glide
        .with(this)
        .load(R.drawable.ic_logo);
    Glide.with(this)
        .load("http://xxx.png")
        .thumbnail(thumbnailRequest)
        .into(mIv);
```

**设置监听请求，监控请求发生错误来源，以及图片来源是内存还是磁盘**

```java
Glide.with(this).load(imageUrl).listener(new RequestListener<String, GlideDrawable>() {
            @Override
            public boolean onException(Exception e, String model, Target<GlideDrawable> target, boolean isFirstResource) {
                return false;
            }

            @Override
            public boolean onResourceReady(GlideDrawable resource, String model, Target<GlideDrawable> target, boolean isFromMemoryCache, boolean isFirstResource) {
                //imageView.setImageDrawable(resource);
                return false;
            }
        }).into(imageView);
```

### 3.圆角图片

```java
// 圆角图片
Glide.with(context)
    .load("url")
    .transform(new RoundedCorners(8)) // 数字根据自己需求来改
    .into(imageView)
    
// 圆形图片
Glide.with(context)
    .load("url")
    .transform(new CircleCrop()) // 数字根据自己需求来改
    .into(imageView)
```







## picasso库

> https://github.com/square/picasso

**Picasso** 是一个用于 Android 平台的图片加载库，它可以帮助开发者轻松地加载和显示图片。Picasso 的主要功能包括：

- **异步加载图片**：Picasso 可以异步加载图片，避免阻塞主线程。
- **缓存图片**：Picasso 可以缓存图片，避免重复加载。
- **转换图片**：Picasso 可以对图片进行转换，例如缩放、旋转、裁剪等。
- **显示图片**：Picasso 可以将图片显示到 ImageView 等视图中。



```java
Picasso.with(context).load(R.mipmap.header).into(((MyViewHolder) holder).imageHeader);
```

如果要改变图片的形状

```java
//实现transfor接口
public class CircleTransform implements Transformation {

    @Override
    public Bitmap transform(Bitmap source) {
        int size = Math.min(source.getWidth(), source.getHeight());
        int x = (source.getWidth() - size) / 2;
        int y = (source.getHeight() - size) / 2;
        Bitmap squaredBitmap = Bitmap.createBitmap(source, x, y, size, size);
        if (squaredBitmap != source) {
            source.recycle();
        }
        Bitmap bitmap = Bitmap.createBitmap(size, size, source.getConfig());
        Canvas canvas = new Canvas(bitmap);
        Paint paint = new Paint();
        BitmapShader shader = new BitmapShader(squaredBitmap,
                                               BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP);
        paint.setShader(shader);
        paint.setAntiAlias(true);
        float r = size / 2f;
        canvas.drawCircle(r, r, r, paint);
        squaredBitmap.recycle();
        return bitmap;
    }

    @Override
    public String key() {
        return "circle";
    }
}
```

```java
//调用
Picasso.with(context).load(R.mipmap.header).transform(new CircleTransform()).into(((MyViewHolder) holder).imageHeader);//返回的图片链接访问不了，统一使用本地的图片
```





## Fresco

> https://github.com/facebook/fresco

 Fresco 是 Facebook 开发的一个开源图片加载库，用于 Android 平台。它可以帮助开发者轻松地加载和显示图片 

# 二、导航栏

## 1.CommonTabLayout

> https://github.com/H07000223/FlycoTabLayout

# 三、音视频播放

## 1 dueeekeVideoPlayer

> https://github.com/Doikki/DKVideoPlayer



### 1.1读取raw/assets目录下的文件

> https://juejin.cn/post/6844903713828503559

# 四、加载刷新

## 1.SmartRefreshLayout

> https://gitee.com/scwang90/SmartRefreshLayout







# 主题换肤

> https://github.com/ximsfei/Android-skin-support

# JsBridge

> https://github.com/lzyzsd/JsBridge

实现java和JS的通信，当app中需要跑H5代码时候可以用到

> 官方文档介绍：` It provides safe and convenient way to call Java code from js and call js code from java. `

