

## 管理组件生命周期

如果在生命周期函数调用大量的代码，可能会导致管理混乱，甚至出现onStop()函数以及调用结束，onStart()还在等待回调，例如下面例子：

```java
class MyActivity extends AppCompatActivity {
    private MyLocationListener myLocationListener;

    public void onCreate(...) {
        myLocationListener = new MyLocationListener(this, location -> {
            // update UI
        });
    }

    @Override
    public void onStart() {
        super.onStart();
        Util.checkUserStatus(result -> {
            // what if this callback is invoked AFTER activity is stopped?
            //还在等待回调
            if (result) {
                myLocationListener.start();
            }
        });
    }

    @Override
    public void onStop() {
        super.onStop();
        myLocationListener.stop();
    }
}
```



### androidx.lifecycle

**Lifecycle**是一个类，用于存储有关组件（如 activity 或 fragment）的生命周期状态的信息，并允许其他对象观察此状态。

#### ①DefaultLifecycleObserver

可以实现该接口，并且实现方法来监听组件的生命周期

```java
public class MyObserver implements DefaultLifecycleObserver {
    @Override
    public void onResume(LifecycleOwner owner) {
        connect()
    }

    @Override
    public void onPause(LifecycleOwner owner) {
        disconnect()
    }
}

myLifecycleOwner.getLifecycle().addObserver(new MyObserver());//实现lifeCycleOwner，然后通过addObserver方法添加实现的观察类
```



#### ②LifecycleOwner

该接口必须实现`getLifcycle()`

实现 `DefaultLifecycleObserver`的组件可与实现 `LifecycleOwner` 的组件完美配合，因为所有者可以提供生命周期，而观察者可以注册以观察生命周期。

**例子：**

可以让 `MyLocationListener` 类实现 `DefaultLifecycleObserver`，然后在 `onCreate()` 方法中使用 activity 的 `Lifecycle`对其进行初始化。这样，`MyLocationListener` 类便可以“自给自足”，这意味着，对生命周期状态的变化做出响应的逻辑会在 `MyLocationListener`（而不是在 activity）中进行声明。让各个组件存储自己的逻辑可使 activity 和 fragment 逻辑更易于管理。

```java
class MyActivity extends AppCompatActivity {
    private MyLocationListener myLocationListener;

    public void onCreate(...) {
        myLocationListener = new MyLocationListener(this, getLifecycle(), location -> {
            // update UI
        });
        Util.checkUserStatus(result -> {
            if (result) {
                myLocationListener.enable();
            }
        });
  }
}
```

```java
class MyLocationListener implements DefaultLifecycleObserver {
    private boolean enabled = false;
    public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) {
        ...
    }

    @Override
    public void onStart(LifecycleOwner owner) {
        if (enabled) {
            // connect
        }
    }

    public void enable() {
        enabled = true;
        if (lifecycle.getCurrentState().isAtLeast(STARTED)) {
            // connect if not connected
        }
    }

    @Override
    public void onStop(LifecycleOwner owner) {
        // disconnect if connected
    }
}
```



目前 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 `LifecycleOwner`接口。如果自定义类并使其成为LifecycleOwner，可以使用如下:

```java
public class MyActivity extends Activity implements LifecycleOwner {
    private LifecycleRegistry lifecycleRegistry;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        lifecycleRegistry = new LifecycleRegistry(this);
        lifecycleRegistry.markState(Lifecycle.State.CREATED);
    }

    @Override
    public void onStart() {
        super.onStart();
        lifecycleRegistry.markState(Lifecycle.State.STARTED);
    }

    @NonNull
    @Override
    public Lifecycle getLifecycle() {
        return lifecycleRegistry;
    }
}
```



## ViewModel

### 1.概述

ViewModel类旨在以注重生命周期的方式存储和管理界面相关的数据。`ViewModel`类***让数据可在发生屏幕旋转等配置更改后继续留存，为Activity和Fragment保留数据***

```groovy
// ViewModel依赖
def lifecycle_version = "2.3.1"
implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version"
```

### 2.实现

通过继承ViewModel类，并结合LiveData实现对数据保存，因为ViewModel有自己的生命周期，所以LiveData和ViewModel绑定就不会受Activity的影响，在***应用配置更改期间viewmodel对象不会销毁，所以可以为Activity和Fragment恢复数据***。

**例如：要在程序中保存用户列表信息**

```java
public class MyViewModel extends ViewModel {
    private MutableLiveData<List<User>> users;
    public LiveData<List<User>> getUsers() {
        if (users == null) {
            users = new MutableLiveData<List<User>>();
            loadUsers();
        }
        return users;
    }

    private void loadUsers() {
        // Do an asynchronous operation to fetch users.
    }
}
```

然后可以在Activity访问该列表

```java
public class MyActivity extends AppCompatActivity {
    public void onCreate(Bundle savedInstanceState) {
        // 当onCreate执行时，第一次创建viewmodel
        //再次调用onCreate方法创建Activity时，获取的实例和第一次创建的实例是相同的

        //必须通过ViewModelProvider来获取viewmodel实例
        MyViewModel model = new ViewModelProvider(this).get(MyViewModel.class);
        model.getUsers().observe(this, users -> { 
            // update UI
        });
    }
}
```

> **observe用于观察LiveData的更新**
>
> 传入的第一个参数owner，是为了感知这个参数的生命周期。第二个参数是回调，内部会帮你切换到主线程。

### 3.生命周期

ViewModel会***一直存在在内存中***直到限定其存在范围的Lifecycle永久消失：

- 对于 Activity，是在 Activity 完成时；
- 而对于 Fragment，是在 Fragment 分离时。

图 1 说明了 Activity 经历屏幕旋转而后结束时所处的各种生命周期状态。该图Activity 生命周期的旁边显示了 ViewModel的生命周期。此图表说明了 Activity 的各种状态。这些基本状态同样适用于 Fragment 的生命周期。

![说明 ViewModel 随着 Activity 状态的改变而经历的生命周期。](应用数据管理恢复.assets/viewmodel-lifecycle.png)

### 4.实现加载器

**通过ViewModel和Room以及LiveData来实现加载器的功能**

在以前，可以使用CursorLoader加载器来观察数据库的内容，当数据库中的值发生更改时，加载器会自动触发数据的重新加载并更新界面。下图为加载器加载：

![img](应用数据管理恢复.assets/viewmodel-loader.png)

`ViewModel`与 [Room]和 [LiveData]一起使用可替换加载器。[`ViewModel`]确保数据在设备配置更改后仍然存在。[Room]在数据库发生更改时通知 [`LiveData`]，[LiveData]进而使用修订后的数据更新界面。

![img](应用数据管理恢复.assets/viewmodel-replace-loader.png)

## LiveData

### 1.概述

> LiveData是一种类，持有可被观察的数据。
>  LiveData是一种可感知生命周期的组件，如Activity、Fragment、Service，仅仅在Activity\Fragment\Service等组件都处于活跃的生命周期状态的时候，才去更新app组件。

> 如果观察者（由 [**`Observer`**] 类表示）的生命周期处于 [**`STARTED`**] 或 [**`RESUMED`**]状态，则 LiveData 会认为该观察者处于活跃状态。LiveData 只会将更新通知给活跃的观察者。为观察 [**`LiveData`**] 对象而注册的非活跃观察者不会收到更改通知。

### 2.优势

- **确保界面符合数据状态**

LiveData 遵循观察者模式。当底层数据发生变化时，LiveData 会通知 [`Observer`] 对象。您可以整合代码以在这些 `Observer` 对象中更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。

- **不会发生内存泄漏**

观察者会绑定到 [`Lifecycle`]对象，并在其关联的生命周期遭到销毁后进行自我清理。

- **不会因 Activity 停止而导致崩溃**

如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。

- **不再需要手动处理生命周期**

界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。

- **数据始终保持最新状态**

如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。

- **适当的配置更改**

如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。

- **共享资源**

您可以使用单例模式扩展 [`LiveData`](https://developer.android.google.cn/reference/androidx/lifecycle/LiveData) 对象以封装系统服务，以便在应用中共享它们。`LiveData` 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 `LiveData` 对象。如需了解详情，请参阅[扩展 LiveData](https://developer.android.google.cn/topic/libraries/architecture/livedata#extend_livedata)。

### 3.使用

> 1. 在 [`ViewModel`]类中完成,创建 `LiveData` 的实例以存储某种类型的数据
> 2. 创建[`Observer`]对象，通过回调`onChange()`函数观察LiveData是否改变。
> 3. 使用 [`observe()`] 方法将 `Observer` 对象附加到 `LiveData` 对象。`observe()` 方法会采用 [`LifecycleOwner`] 对象。这样会使 `Observer` 对象订阅 `LiveData` 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中附加 `Observer` 对象。

当您更新存储在 `LiveData` 对象中的值时，它会触发所有已注册的观察者（只要附加的 `LifecycleOwner` 处于活跃状态）。

#### LiveData与MutableLiveData区别

> LiveData与MutableLiveData的其实在概念上是一模一样的.唯一几个的区别如下:
>
> 1. MutableLiveData的父类是LiveData
> 2. LiveData在实体类里可以通知指定某个字段的数据更新.
> 3. MutableLiveData则是完全是整个实体类或者数据类型变化后才通知.不会细节到某个字段

**[`LiveData`]对象通常存储在 [`ViewModel`]对象中**，并可通过 getter 方法进行访问，如以下示例中所示：

```java
public class NameViewModel extends ViewModel {

// Create a LiveData with a String
private MutableLiveData<String> currentName;

    public MutableLiveData<String> getCurrentName() {
        if (currentName == null) {
            currentName = new MutableLiveData<String>();
        }
        return currentName;
    }

// Rest of the ViewModel...
}
```

### 4.观察Livedata

在大多数情况下，应该从 `onCreate()` 方法开始观察 [`LiveData`]对象，原因如下：

- 确保系统不会从 Activity 或 Fragment 的 `onResume()` 方法进行冗余调用。
- 确保 Activity 或 Fragment 变为活跃状态后具有**可以立即显示的数据。**一旦应用组件处于 [`STARTED`](https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle.State#STARTED) 状态，就会从它正在观察的 `LiveData` 对象接收最新值。只有在设置了要观察的 `LiveData` 对象时，才会发生这种情况。

LiveData发送更新的几种情况

- **LiveData 仅在数据发生更改时才发送更新，并且仅发送给活跃观察者。**
- 观察者从非活跃状态更改为活跃状态时也会收到更新。
- 此外，如果观察者第二次从非活跃状态更改为活跃状态，则只有在自上次变为活跃状态以来值发生了更改时，它才会收到更新。

以下示例代码说明了如何开始观察 `LiveData` 对象：

```java
public class NameActivity extends AppCompatActivity {

    private NameViewModel model;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Other code to setup the activity...

        // Get the ViewModel.
        model = new ViewModelProvider(this).get(NameViewModel.class);

        // Create the observer which updates the UI.
        final Observer<String> nameObserver = new Observer<String>() {
            @Override
            public void onChanged(@Nullable final String newName) {
                // Update the UI, in this case, a TextView.
                nameTextView.setText(newName);
            }
        };

        // 观察viewmodel中getCurrentName方法，并且更新数据
        model.getCurrentName().observe(this, nameObserver);
    }
}
```

> **observe()方法用于观察LiveData的改变**
>
> 传入的第一个参数owner，是为了感知这个参数的生命周期。第二个参数是回调，内部会帮你切换到主线程。

### 5.更新LiveData

> LiveData没有公开可用的方法来更新存储的数据，但是***MutableLiveData类公开了setValue(T)、postValue(T)方法来修改存储在LiveData对象中的值***

例如：当用户点击某个按钮时会触发所有观察者

```java
button.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick(View v) {
        String anotherName = "John Doe";
        model.getCurrentName().setValue(anotherName);//此时onChanged()方法会触发
    }
});
```

> 必须调用 [`setValue(T)`]方法以从**主线程更新 `LiveData` 对象**。如果在工作器线程中执行代码，您可以改用 [`postValue(T)`]方法来更新 `LiveData` 对象。在所有情况下，调用 `setValue()` 或 `postValue()` 都会触发观察者并更新界面。

### 6.拓展LiveData



```java
public class StockLiveData extends LiveData<BigDecimal> {
    private static StockLiveData sInstance;
    private StockManager stockManager;

    private SimplePriceListener listener = new SimplePriceListener() {
        @Override
        public void onPriceChanged(BigDecimal price) {
            setValue(price);
        }
    };

    @MainThread
    public static StockLiveData get(String symbol) {
        if (sInstance == null) {
            sInstance = new StockLiveData(symbol);
        }
        return sInstance;
    }

    private StockLiveData(String symbol) {
        stockManager = new StockManager(symbol);
    }

    @Override
    protected void onActive() {
        stockManager.requestPriceUpdates(listener);
    }

    @Override
    protected void onInactive() {
        stockManager.removeUpdates(listener);
    }
}
```

> 本示例中的价格监听器实现包括以下重要方法：
>
> - 当 `LiveData` 对象具有活跃观察者时，会调用 [`onActive()`] 方法。这意味着，您需要从此方法开始观察股价更新。
> - 当 `LiveData` 对象没有任何活跃观察者时，会调用 [`onInactive()`]方法。由于没有观察者在监听，因此没有理由与 `StockManager` 服务保持连接。
> - [`setValue(T)`]方法将更新 `LiveData` 实例的值，并告知活跃观察者。

可以在多个Activity和fragment使用

```java
public class MyFragment extends Fragment {
    @Override
    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {
        super.onViewCreated(view, savedInstanceState);
        LiveData<BigDecimal> myPriceListener = ...;
        StockLiveData.get(symbol).observe(getViewLifecycleOwner(), price -> {
            // Update the UI.
        });
    }
}
```

> [`observe()`] 方法将与 Fragment 视图关联的 [`LifecycleOwner`] 作为第一个参数传递。这样做表示此观察者已绑定到与所有者关联的 [`Lifecycle`]对象，这意味着：
>
> - 如果 `Lifecycle` 对象未处于活跃状态，那么即使值发生更改，也不会调用观察者。
> - 销毁 `Lifecycle` 对象后，会自动移除观察者。

### 7.转换LiveData

您可能希望在将 [`LiveData`]对象分派给观察者之前对存储在其中的值进行更改，或者您可能需要根据另一个实例的值返回不同的 `LiveData` 实例。

>  **Transformation.map()**
>
> 对存储在 `LiveData` 对象中的值应用函数，并将结果传播到下游。

```java
LiveData<User> userLiveData = ...;
LiveData<String> userName = Transformations.map(userLiveData, user -> {
    user.name + " " + user.lastName
});
```

> ****

> **Transformation.switchMap()**
>
> 与 `map()` 类似，对存储在 `LiveData` 对象中的值应用函数，并将结果解封和分派到下游。传递给 `switchMap()` 的函数必须**返回 `LiveData` 对象**

```java
private LiveData<User> getUser(String id) {
  ...;
}

LiveData<String> userId = ...;
LiveData<User> user = Transformations.switchMap(userId, id -> getUser(id) );
```



### 8.Kotlin协程与LiveData





> 参考——https://blog.csdn.net/jzlhll123/article/details/119728380

> 

### 1.概述

> 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。
>
> 该库可帮助您在运行应用的设备上创建应用数据的缓存。此缓存充当应用的单一可信来源，使用户能够在应用中查看关键信息的一致副本，无论用户是否具有互联网连接。

```groovy
//依赖
dependencies {
    def room_version = "2.3.0"

    implementation "androidx.room:room-runtime:$room_version"
    annotationProcessor "androidx.room:room-compiler:$room_version"

    // optional - RxJava2 support for Room
    implementation "androidx.room:room-rxjava2:$room_version"

    // optional - RxJava3 support for Room
    implementation "androidx.room:room-rxjava3:$room_version"

    // optional - Guava support for Room, including Optional and ListenableFuture
    implementation "androidx.room:room-guava:$room_version"

    // optional - Test helpers
    testImplementation "androidx.room:room-testing:$room_version"
}
```







### 2.结合LiveData

## butter knife

http://jakewharton.github.io/butterknife/



## onSaveInstanceState

在某些情况下，您的 Activity 会因`正常的应用行为而被销毁`，**例如当用户按下返回按钮或您的 Activity 通过调用`finish()`方法发出销毁信号时。当您的 Activity 因用户按下返回按钮或因其自行结束而被销毁时，系统和用户对该 `Activity`实例的概念将永远消失。**在这些情况下，用户的期望与系统行为相匹配，您无需完成任何额外工作。

但是，如果系统因系统限制（例如配置变更或内存压力）而销毁 Activity，虽然实际的 `Activity` 实例会消失，但`系统会记住它曾经存在过`。*如果用户尝试回退到该 Activity，系统将使用一组描述 Activity 销毁时状态的已保存数据新建该 Activity 的实例。*

**(1)使用onSaveInstanceState() 保存简单轻量的界面状态**

当Activity停止时，系统会调用onSaveInstanceState方法，将状态信息保存到实例状态 Bundle 中。**此方法默认实现保存有关 Activity 视图层次结构状态的瞬时信息**，例如 `EditText` 微件中的文本或 `ListView` 微件的滚动位置。

如果想要保存其他状态，需要重写:

`如果您希望默认实现保存视图层次结构的状态，必须调用父类实现。`

```java
static final String STATE_SCORE = "playerScore";
static final String STATE_LEVEL = "playerLevel";
// ...

@Override
public void onSaveInstanceState(Bundle savedInstanceState) {
    // Save the user's current game state
    savedInstanceState.putInt(STATE_SCORE, currentScore);
    savedInstanceState.putInt(STATE_LEVEL, currentLevel);

    // Always call the superclass so it can save the view hierarchy state
    super.onSaveInstanceState(savedInstanceState);
}
```



**恢复保存的状态：**

在onCreate中：

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState); // Always call the superclass first

    // Check whether we're recreating a previously destroyed instance
    if (savedInstanceState != null) {
        // Restore value of members from saved state
        currentScore = savedInstanceState.getInt(STATE_SCORE);
        currentLevel = savedInstanceState.getInt(STATE_LEVEL);
    } else {
        // Probably initialize members with default values for a new instance
    }
    // ...
}
```

在onRestoreInstanceState()恢复,您可以选择实现系统在 [`onStart()`] 方法调用的 [`onRestoreInstanceState()`]，而不是在 [`onCreate()`] 期间恢复状态。仅当存在要恢复的已保存状态时，系统才会调用 [`onRestoreInstanceState()`]，因此您无需检查 [`Bundle`]是否为 null：

```java
public void onRestoreInstanceState(Bundle savedInstanceState) {
    // Always call the superclass so it can restore the view hierarchy
    super.onRestoreInstanceState(savedInstanceState);

    // Restore state members from saved instance
    currentScore = savedInstanceState.getInt(STATE_SCORE);
    currentLevel = savedInstanceState.getInt(STATE_LEVEL);
}
```



## 界面状态保存

下表是对几种界面保存状态方法的优缺点归纳

|                                                      | ViewModel                              | 保存的实例状态                             | 永久性存储空间                              |
| ---------------------------------------------------- | -------------------------------------- | ------------------------------------------ | ------------------------------------------- |
| 存储位置                                             | 在内存中                               | 在内存中                                   | 在磁盘或网络上                              |
| 在配置更改后继续存在                                 | 是                                     | 是                                         | 是                                          |
| 在系统发起的进程终止后继续存在                       | 否                                     | 是                                         | 是                                          |
| 在用户完全关闭 activity 或触发 onFinish() 后继续存在 | 否                                     | 否                                         | 是                                          |
| 数据限制                                             | 支持复杂对象，但是空间受可用内存的限制 | 仅适用于基元类型和简单的小对象，例如字符串 | 仅受限于磁盘空间或从网络资源检索的成本/时间 |
| 读取/写入时间                                        | 快（仅限内存访问）                     | 慢（需要序列化/反序列化和磁盘访问）        | 慢（需要磁盘访问或网络事务）                |

> 参考——https://developer.android.google.cn/topic/libraries/architecture/saving-states?hl=zh-cn