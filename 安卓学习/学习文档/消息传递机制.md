# 消息处理机制

> [Android Handler，Looper 与 MessageQueue 使用与分析](https://cloud.tencent.com/developer/article/1783157)

**Android是消息驱动的，实现消息驱动有几个要素：**

- 消息的表示：`Message`
- 消息队列：`MessageQueue`
- 消息循环，用于循环取出消息进行处理：`Looper`
- 消息处理，消息循环从消息队列中取出消息后要对消息进行处理：`Handler`

## 一、Handler

一个Handler允许发送和处理Message，通过关联线程的 MessageQueue 执行 Runnable 对象。 每个Handler实例都和一个单独的线程及其消息队列绑定。 可以将一个任务切换到Handler所在的线程中去执行。一个用法就是子线程通过Handler更新UI。 

**主要用法：**

- 做出计划，在未来某个时间点执行消息和Runnable
- 线程调度，在其他线程规划并执行任务



### 1.handler的主要方法

#### (1)发送和处理消息的几个方法

- `void handleMessage( Message  msg)`:处理消息的方法，该方法通常被重写。
- `final boolean hasMessage(int  what)`:检查消息队列中是否包含有what属性为指定值的消息
- `final boolean hasMessage(int what ,Object object)` :检查消息队列中是否包含有`what`和`object`属性指定值的消息
- `sendEmptyMessage(int what)`:发送空消息
- `final Boolean sendEmptyMessageDelayed(int what ,long delayMillis)`:指定多少毫秒发送空消息
- `final  boolean sendMessage(Message msg)`:立即发送消息
- `final boolean sendMessageDelayed(Message msg,long delayMillis)`:多少秒之后发送消息

#### (2)取消任务

 要取消任务时，调用下面这个方法`removeCallbacksAndMessages(Object token)` 



#### (3)实例

通过handler实现延迟消息传递

```java
Handler handler = new Handler();//一定要实例化
handler.postDelayed(new Runnable() {
    @Override
    public void run() {
        Intent intent = new Intent(HandlerActivity.this,WebViewActivity.class);
        startActivity(intent);
    }
}, 3000);//3秒之后跳转到WebViewActivity界面
}
```



通过handler和线程间进行消息传递，可以进行UI更新

```java
//线程间通信
handler = new Handler(new Handler.Callback(){
    @Override
    public boolean handleMessage(@NonNull Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case 1:
                ToastUtil.showMsg(getApplicationContext(),"线程消息传递成功");
                return true;
        }
        return false;
    }
});

new Thread(){
    @Override
    public void run() {
        super.run();
        Message message = new Message();
        message.what = 1;//给message赋值
        handler.sendMessage(message);//传递信息给给handler
    }
}.start();
```



### 避免内存泄漏

使用Handler可能会出现提示`@SuppressLint(“HandlerLeak”) `

**原因：**Handler在Android中用于消息的发送与异步处理，常常在Activity中作为一个匿名内部类来定义，此时Handler会隐式地持有一个外部类对象（通常是一个Activity）的引用。当Activity已经被用户关闭时，由于Handler持有Activity的引用造成Activity无法被GC回收，这样容易造成内存泄露。
**解决办法：**

- 将其定义成一个静态内部类

  > 此时不会持有外部类对象的引用），在构造方法中传入Activity并对Activity对象增加一个弱引用，这样Activity被用户关闭之后，即便异步消息还未处理完毕，Activity也能够被GC回收，从而避免了内存泄露。
  >
  > ```java
  > private MyHandler handler = new MyHandler(this);
  > static class MyHandler extends Handler {
  >     WeakReference weakReference;
  >     public MyHandler(SecondActivity activity) {
  >         weakReference = new WeakReference(activity);
  >     }
  > 
  >     @Override
  >     public void handleMessage(Message msg) {
  > 
  >     }
  > }
  > ```

- 定义为变量

  > ```java
  > //正确的写法：
  > private Handler mHandler = new Handler(new Handler.Callback() {
  >     @Override
  >     public boolean handleMessage(Message msg) {
  >         return false;
  >     }
  > });
  > ```
  >
  > > 参考——https://blog.csdn.net/androidsj/article/details/79865091



### 2.与handler工作的几个组件

与Handler工作的几个组件Looper、MessageQueue各自的作用：

- Handler：它把消息发送给Looper管理的MessageQueue,并负责处理Looper分给它的消息
- MessageQueue：管理Message，由Looper管理
- Looper：每个线程只有一个Looper，比如UI线程中，系统会默认的初始化一个Looper对象，它负责管理MessageQueue，不断的从MessageQueue中取消息，并将相对应的消息分给Handler处理。



#### (1)Message

Message 属于被传递、被使用的角色。*Message 是包含描述和任意数据对象的“消息”*，能被发送给`Handler`。

虽然构造器是公开的，但获取实例最好的办法是调用`Message.obtain()`或`Handler.obtainMessage()`。这样可以从它的可回收对象池中获取到消息实例。一般来说，每个Message实例持有一个Handler。 

> 因为每个Message都持有Handler实例。如果Handler持有Activity的引用，Activity onDestroy后Message却仍然在队列中，因为Handler与Activity的强关联，会造成Activity无法被GC回收，导致内存泄露。
>
> 因此在Activity onDestroy 时，与Activity关联的Handler应清除它的队列与Activity产生的任务，避免内存泄露。
>
> ```java
> public void recycle()
> void recycleUnchecked()
> ```

 获取Message实例的常用方法，得到的实例与传入的Handler绑定 

```java
public static Message obtain(Handler h) {
    Message m = obtain();
    m.target = h;

    return m;
}
```

 将消息发送给Handler , 调用这个方法后，Handler会将消息添加进它的消息队列`MessageQueue`中。 

```java
message.sendToTarget();
```



#### (2)MessageQueue

持有一列可以被Looper分发的Message。一般来说由Handler将Message添加到MessageQueue中。 获取当前线程的MessageQueue方法是`Looper.myQueue()`。通过`Looper.getMainLooper()`获取到主线程的looper。 

#### (3)Looper

 Looper与MessageQueue紧密关联。在一个线程中运行的消息循环。线程默认情况下是没有与之管理的消息循环的。 要创建一个消息循环，在线程中调用`prepare`，然后调用`loop`。即开始处理消息，直到循环停止。大多数情况下通过Handler来与消息循环互动。 

>  Handler与Looper在线程中交互的典型例子 
>
> ```java
> class LooperThread extends Thread {
>     public Handler mHandler;
>     public void run() {
>         Looper.prepare(); // 为当前线程准备一个Looper
>         // 创建Handler实例，Handler会获取当前线程的Looper
>         // 如果实例化Handler时当前线程没有Looper，会报异常 RuntimeException
>         mHandler = new Handler() {
>             public void handleMessage(Message msg) {
>                 // process incoming messages here
>             }
>         };
>         Looper.loop(); // Looper开始运行
>     }
> }
> ```
>
>  `looper`必须被明确地通过`looper.quit()`终止。 



## 二、EventBus

### 1.简介

```markdown
当我们进行项目开发的时候，往往是需要应用程序的各组件、组件与后台线程间进行通信，比如在子线程中进行请求数据，当数据请求完毕后通过Handler或者是广播通知UI，而两个Fragment之家可以通过Listener进行通信等等。当我们的项目越来越复杂，使用Intent、Handler、Broadcast进行模块间通信、模块与后台线程进行通信时，代码量大，而且高度耦合 。
大概的意思就是：EventBus能够简化各组件间的通信，让我们的代码书写变得简单，能有效的分离事件发送方和接收方(也就是解耦的意思)，能避免复杂和容易出错的依赖性和生命周期问题。
```

### 2.配置

添加依赖

```groovy
dependencies {
    implementation 'org.greenrobot:eventbus:3.1.1'
}
```



###  3.添加混淆

```properties
#在模块的 proguard-rules.pro 混淆规则文件中添加如下规则：
# EventBus
-keepattributes *Annotation*
-keepclassmembers class * {
    @org.greenrobot.eventbus.Subscribe <methods>;
}
-keep enum org.greenrobot.eventbus.ThreadMode { *; }

```



### 4基本使用

分为三个步骤：1.定义事件；2.订阅事件；3.发布事件



#### (1)定义事件

 事件可以是任意普通的Java对象，没有任何特殊的要求 

```java
public class MessageEvent {
    private String message;

    public MessageEvent(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
```

#### (2)订阅事件

 订阅者需要定义事件处理方法（也称为订阅者方法）。当发布对应类型的事件时，该方法将被调用。EventBus 3使用 **@Subscribe** 注解来定义订阅者方法。方法名可以是任意合法的方法名，参数类型为订阅事件的类型 

```java
@Subscribe(threadMode = ThreadMode.MAIN)
public void onMessageEvent(MessageEvent event) {
    ...
}
```

 订阅者还需要在总线上注册，并在不需要时在总线上注销。只有订阅者注册了，它们才会收到事件。在Android中，可以根据Activity或者Fragment的生命周期来注册和注销。例如： 

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    initContentView();
    // 注册订阅者
    EventBus.getDefault().register(this);
}

@Override
protected void onDestroy() {
    super.onDestroy();
    // 注销订阅者
    EventBus.getDefault().unregister(this);
}    
```

#### (3)发布事件

 在需要的地方发布事件，所有订阅了该类型事件并已注册的订阅者将收到该事件。

```java
// 发布事件
EventBus.getDefault().post(new MessageEvent("Hello EventBus!"));
```



测试

```java
public class FirstActivity extends AppCompatActivity {

    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_first);

        button = findViewById(R.id.tosecond_btn);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(getApplicationContext(),SecondActivity.class);
                startActivity(intent);
            }
        });

        //注册订阅者
        EventBus.getDefault().register(this);
    }

    @Subscribe(threadMode = ThreadMode.MAIN)
    public void onMessageEvent(MessageEvent event){
        Log.i("eventbus",event.getMessage());
        button.setText(event.getMessage());
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销订阅
        EventBus.getDefault().unregister(this);
    }
}
```

```java
public class SecondActivity extends AppCompatActivity {

    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        button = findViewById(R.id.backtofirst_btn);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                EventBus.getDefault().post(new MessageEvent("Hello eventbus"));//发布事件，调用该类型(MessageEvent)的事件
            }
        });
    }
}
```



### 5.线程模式

 EventBus总共支持5种线程模式 :

```
·ThreadMode.POSTING 订阅者方法将在发布事件所在的线程中被调用。这是 默认的线程模式。事件的传递是同步的，一旦发布事件，所有该模式的订阅者方法都将被调用。这种线程模式意味着最少的性能开销，因为它避免了线程的切换。因此，对于不要求是主线程并且耗时很短的简单任务推荐使用该模式。使用该模式的订阅者方法应该快速返回，以避免阻塞发布事件的线程，这可能是主线程。

·ThreadMode.MAIN 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。

·ThreadMode.MAIN_ORDERED 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。事件将先进入队列然后才发送给订阅者，所以发布事件的调用将立即返回。这使得事件的处理保持严格的串行顺序。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。

·ThreadMode.BACKGROUND 订阅者方法将在后台线程中被调用。如果发布事件的线程不是主线程，那么订阅者方法将直接在该线程中被调用。如果发布事件的线程是主线程，那么将使用一个单独的后台线程，该线程将按顺序发送所有的事件。使用该模式的订阅者方法应该快速返回，以避免阻塞后台线程。

·ThreadMode.ASYNC 订阅者方法将在一个单独的线程中被调用。因此，发布事件的调用将立即返回。如果订阅者方法的执行需要一些时间，例如网络访问，那么就应该使用该模式。避免触发大量的长时间运行的订阅者方法，以限制并发线程的数量。EventBus使用了一个线程池来有效地重用已经完成调用订阅者方法的线程。

```



### 6.粘性事件

如果先发布了事件，然后有订阅者订阅了该事件，那么除非再次发布该事件，否则订阅者将永远接收不到该事件。此时，可以使用粘性事件。发布一个粘性事件之后，EventBus将在内存中缓存该粘性事件。**当有订阅者订阅了该粘性事件，订阅者将接收到该事件。** 

```java
// 订阅粘性事件
@Subscribe(sticky = true)
public void onMessageEvent(MessageEvent event) {
    ...
}

// 发布粘性事件
EventBus.getDefault().postSticky(new MessageEvent("Hello EventBus!"));

```

发布一个粘性事件后，EventBus将一直缓存该粘性事件。如果想要移除粘性事件，那么可以使用如下方法：

```java
// 移除指定的粘性事件
removeStickyEvent(Object event);

// 移除指定类型的粘性事件
removeStickyEvent(Class<T> eventType);

// 移除所有的粘性事件
removeAllStickyEvents();
```

#### 测试

发布粘性事件代码如下：

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initContentView();
    }

    private void initContentView() {
        findViewById(R.id.btn_main_post_event).setOnClickListener(this);
        findViewById(R.id.btn_main_start_activity).setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.btn_main_post_event:
                // 发布粘性事件
                EventBus.getDefault().postSticky(new MessageEvent("Hello EventBus!"));
                break;

            case R.id.btn_main_start_activity:
                SecondActivity.start(this);
                break;

            default:
                break;
        }
    }
}

```

订阅粘性事件代码如下:

```java
public class SecondActivity extends AppCompatActivity {
    private static final String TAG = "SecondActivity";

    private TextView mTvMessage;

    public static void start(Context context) {
        Intent intent = new Intent(context, SecondActivity.class);
        context.startActivity(intent);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        initContentView();
        // 注册订阅者
        EventBus.getDefault().register(this);
    }

    private void initContentView() {
        mTvMessage = findViewById(R.id.tv_second_message);
    }

    @Subscribe(threadMode = ThreadMode.MAIN, sticky = true)
    public void onMessageEvent(MessageEvent event) {
        Log.i(TAG, "message is " + event.getMessage());
        // 更新界面
        mTvMessage.setText(event.getMessage());
        // 移除粘性事件
        EventBus.getDefault().removeStickyEvent(event);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 注销订阅者
        EventBus.getDefault().unregister(this);
    }
}
```

### 7.事件优先级

EventBus支持在定义订阅者方法时指定事件传递的优先级。默认情况下，订阅者方法的事件传递优先级为0。**数值越大，优先级越高**。在相同的线程模式下，更高优先级的订阅者方法将优先接收到事件。**注意**：优先级只有在相同的线程模式下才有效。 

```java
@Subscribe(priority = 1)
public void onMessageEvent(MessageEvent event) {
    ...
}
```

 你可以在高优先级的订阅者方法接收到事件之后取消事件的传递。此时，低优先级的订阅者方法将不会接收到该事件。**注意：** 订阅者方法只有在线程模式为ThreadMode.POSTING时，才可以取消一个事件的传递。 

```java
@Subscribe(threadMode = ThreadMode.POSTING, priority = 1)
public void onMessageEvent(MessageEvent event) {
    ...
    // 取消事件传递
    EventBus.getDefault().cancelEventDelivery(event);
}
```



### 8.订阅者索引



## 三、回调

### 1.什么是回调：

**举个例子：**

某天，我打电话向你请教问题，当然是个难题，你一时想不出解决方法，我又不能拿着电话在那里傻等，于是我们约定：等你想出办法后打手机通知我，这样，我就挂掉电话办其它事情去了。过了XX分钟，我的手机响了，你兴高采烈的说问题已经搞定，应该如此这般处理。

![img](消息传递机制.assets/20150716224805625)

### 2.步骤：

​	①注册回调接口

​	②运行回调函数

### 3.demo

```java
//你类

public class You implements Runnable{
 
     
    private String who;
     private ContactInterface callBack;  
     public You() {
            // TODO Auto-generated constructor stub
     }
      
    //调用此方法就表示有人联系你了，注册到你这来
     public void setCallBack(String who,String question,ContactInterface callBack) {
         this.who = who;    
         System.out.println("你说：当前联系到我的人是"+who+"，问题是"+question);
         this.callBack =callBack;
     }
        
     public void handleThings(){
         //假如你现在正在想问题的答案，需要一点时间
         for(int i=0;i<100000;i++){  
               if(i == 0){
                   System.out.println("你正在思考问题.....");
               }
         }
          
         String answer = "答案是A";
         //想到问题的办法了
         System.out.println("你说：想到答案了，准备打回去给"+who+"告诉他答案");
         callBack.callBackByTel(answer);
     }
 
    /* (non-Javadoc)
     * @see java.lang.Runnable#run()
     */
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
            handleThings();
        } catch (Exception e) {
            e.printStackTrace();
        }
    } 
}


//我类

public class Me {
 
     public static void main(String[] args){  
          
         Me me = new Me();
         me.hasQuestion();
          
     }
      
     private void hasQuestion(){
         //现在有问题想不出来答案，想去问你
         You you = new You();
         //进行注册
         you.setCallBack("蜗牛", "某道题答案是什么？", new ContactInterface() {
             
            @Override
            public void callBackByTel(String answer) {
                System.out.println("我说：嗯，好的，我收到答案了:"+answer+"，谢谢");
                 
            }
        });
        //你接到电话，起床开始思考问题
        new Thread(you).start();
     }
}

//接口类
public interface ContactInterface {
     
    public void callBackByTel(String answer);
     
}
```

验证结果：
你说：当前联系到我的人是蜗牛，问题是某道题答案是什么？
你正在思考问题
你说：想到问题了，准备打回去给蜗牛告诉他答案
我说：嗯，好的，我收到答案了：答案是A，谢谢