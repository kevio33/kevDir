# 消息处理机制

## 一、Handler

**作用：线程间通信**

通过handler实现延迟消息传递

```java
        Handler handler = new Handler();//一定要实例化
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                Intent intent = new Intent(HandlerActivity.this,WebViewActivity.class);
                startActivity(intent);
            }
        }, 3000);//3秒之后跳转到WebViewActivity界面
    }
```



通过handler和线程间进行消息传递，可以进行UI更新

```java
        //线程间通信
        handler = new Handler(new Handler.Callback(){
            @Override
            public boolean handleMessage(@NonNull Message msg) {
                super.handleMessage(msg);
                switch (msg.what){
                    case 1:
                        ToastUtil.showMsg(getApplicationContext(),"线程消息传递成功");
                        return true;
                }
			   return false;
            }
        });

        new Thread(){
            @Override
            public void run() {
                super.run();
                Message message = new Message();
                message.what = 1;//给message赋值
                handler.sendMessage(message);//传递信息给给handler
            }
        }.start();
```



### 避免内存泄漏

使用Handler可能会出现提示`@SuppressLint(“HandlerLeak”) `

**原因：**Handler在Android中用于消息的发送与异步处理，常常在Activity中作为一个匿名内部类来定义，此时Handler会隐式地持有一个外部类对象（通常是一个Activity）的引用。当Activity已经被用户关闭时，由于Handler持有Activity的引用造成Activity无法被GC回收，这样容易造成内存泄露。
**解决办法：**

- 将其定义成一个静态内部类

  > 此时不会持有外部类对象的引用），在构造方法中传入Activity并对Activity对象增加一个弱引用，这样Activity被用户关闭之后，即便异步消息还未处理完毕，Activity也能够被GC回收，从而避免了内存泄露。
  >
  > ```java
  > private MyHandler handler = new MyHandler(this);
  > static class MyHandler extends Handler {
  >     WeakReference weakReference;
  >     public MyHandler(SecondActivity activity) {
  >         weakReference = new WeakReference(activity);
  >     }
  > 
  >     @Override
  >     public void handleMessage(Message msg) {
  > 
  >     }
  > }
  > ```

- 定义为变量

  > ```java
  > //正确的写法：
  > private Handler mHandler = new Handler(new Handler.Callback() {
  >     @Override
  >     public boolean handleMessage(Message msg) {
  >         return false;
  >     }
  > });
  > ```
  >
  > > 参考——https://blog.csdn.net/androidsj/article/details/79865091

## 二、EventBus

### 1.简介

```markdown
当我们进行项目开发的时候，往往是需要应用程序的各组件、组件与后台线程间进行通信，比如在子线程中进行请求数据，当数据请求完毕后通过Handler或者是广播通知UI，而两个Fragment之家可以通过Listener进行通信等等。当我们的项目越来越复杂，使用Intent、Handler、Broadcast进行模块间通信、模块与后台线程进行通信时，代码量大，而且高度耦合 。
大概的意思就是：EventBus能够简化各组件间的通信，让我们的代码书写变得简单，能有效的分离事件发送方和接收方(也就是解耦的意思)，能避免复杂和容易出错的依赖性和生命周期问题。
```

### 2.配置

添加依赖

```groovy
dependencies {
    implementation 'org.greenrobot:eventbus:3.1.1'
}
```



###  3.添加混淆

```properties
#在模块的 proguard-rules.pro 混淆规则文件中添加如下规则：
# EventBus
-keepattributes *Annotation*
-keepclassmembers class * {
    @org.greenrobot.eventbus.Subscribe <methods>;
}
-keep enum org.greenrobot.eventbus.ThreadMode { *; }

```



### 4基本使用

分为三个步骤：1.定义事件；2.订阅事件；3.发布事件



#### (1)定义事件

 事件可以是任意普通的Java对象，没有任何特殊的要求 

```java
public class MessageEvent {
    private String message;

    public MessageEvent(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
```

#### (2)订阅事件

 订阅者需要定义事件处理方法（也称为订阅者方法）。当发布对应类型的事件时，该方法将被调用。EventBus 3使用 **@Subscribe** 注解来定义订阅者方法。方法名可以是任意合法的方法名，参数类型为订阅事件的类型 

```java
@Subscribe(threadMode = ThreadMode.MAIN)
public void onMessageEvent(MessageEvent event) {
    ...
}
```

 订阅者还需要在总线上注册，并在不需要时在总线上注销。只有订阅者注册了，它们才会收到事件。在Android中，可以根据Activity或者Fragment的生命周期来注册和注销。例如： 

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    initContentView();
    // 注册订阅者
    EventBus.getDefault().register(this);
}

@Override
protected void onDestroy() {
    super.onDestroy();
    // 注销订阅者
    EventBus.getDefault().unregister(this);
}    
```

#### (3)发布事件

 在需要的地方发布事件，所有订阅了该类型事件并已注册的订阅者将收到该事件。

```java
// 发布事件
EventBus.getDefault().post(new MessageEvent("Hello EventBus!"));
```



测试

```java
public class FirstActivity extends AppCompatActivity {

    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_first);

        button = findViewById(R.id.tosecond_btn);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(getApplicationContext(),SecondActivity.class);
                startActivity(intent);
            }
        });

        //注册订阅者
        EventBus.getDefault().register(this);
    }

    @Subscribe(threadMode = ThreadMode.MAIN)
    public void onMessageEvent(MessageEvent event){
        Log.i("eventbus",event.getMessage());
        button.setText(event.getMessage());
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        //注销订阅
        EventBus.getDefault().unregister(this);
    }
}
```

```java
public class SecondActivity extends AppCompatActivity {

    private Button button;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        button = findViewById(R.id.backtofirst_btn);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                EventBus.getDefault().post(new MessageEvent("Hello eventbus"));//发布事件，调用该类型(MessageEvent)的事件
            }
        });
    }
}
```



### 5.线程模式

 EventBus总共支持5种线程模式 :

```
·ThreadMode.POSTING 订阅者方法将在发布事件所在的线程中被调用。这是 默认的线程模式。事件的传递是同步的，一旦发布事件，所有该模式的订阅者方法都将被调用。这种线程模式意味着最少的性能开销，因为它避免了线程的切换。因此，对于不要求是主线程并且耗时很短的简单任务推荐使用该模式。使用该模式的订阅者方法应该快速返回，以避免阻塞发布事件的线程，这可能是主线程。

·ThreadMode.MAIN 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。如果发布事件的线程是主线程，那么该模式的订阅者方法将被直接调用。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。

·ThreadMode.MAIN_ORDERED 订阅者方法将在主线程（UI线程）中被调用。因此，可以在该模式的订阅者方法中直接更新UI界面。事件将先进入队列然后才发送给订阅者，所以发布事件的调用将立即返回。这使得事件的处理保持严格的串行顺序。使用该模式的订阅者方法必须快速返回，以避免阻塞主线程。

·ThreadMode.BACKGROUND 订阅者方法将在后台线程中被调用。如果发布事件的线程不是主线程，那么订阅者方法将直接在该线程中被调用。如果发布事件的线程是主线程，那么将使用一个单独的后台线程，该线程将按顺序发送所有的事件。使用该模式的订阅者方法应该快速返回，以避免阻塞后台线程。

·ThreadMode.ASYNC 订阅者方法将在一个单独的线程中被调用。因此，发布事件的调用将立即返回。如果订阅者方法的执行需要一些时间，例如网络访问，那么就应该使用该模式。避免触发大量的长时间运行的订阅者方法，以限制并发线程的数量。EventBus使用了一个线程池来有效地重用已经完成调用订阅者方法的线程。

```



### 6.粘性事件

如果先发布了事件，然后有订阅者订阅了该事件，那么除非再次发布该事件，否则订阅者将永远接收不到该事件。此时，可以使用粘性事件。发布一个粘性事件之后，EventBus将在内存中缓存该粘性事件。**当有订阅者订阅了该粘性事件，订阅者将接收到该事件。** 

```java
// 订阅粘性事件
@Subscribe(sticky = true)
public void onMessageEvent(MessageEvent event) {
    ...
}

// 发布粘性事件
EventBus.getDefault().postSticky(new MessageEvent("Hello EventBus!"));

```

发布一个粘性事件后，EventBus将一直缓存该粘性事件。如果想要移除粘性事件，那么可以使用如下方法：

```java
// 移除指定的粘性事件
removeStickyEvent(Object event);

// 移除指定类型的粘性事件
removeStickyEvent(Class<T> eventType);

// 移除所有的粘性事件
removeAllStickyEvents();
```

#### 测试

发布粘性事件代码如下：

```java
public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        initContentView();
    }

    private void initContentView() {
        findViewById(R.id.btn_main_post_event).setOnClickListener(this);
        findViewById(R.id.btn_main_start_activity).setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.btn_main_post_event:
                // 发布粘性事件
                EventBus.getDefault().postSticky(new MessageEvent("Hello EventBus!"));
                break;

            case R.id.btn_main_start_activity:
                SecondActivity.start(this);
                break;

            default:
                break;
        }
    }
}

```

订阅粘性事件代码如下:

```java
public class SecondActivity extends AppCompatActivity {
    private static final String TAG = "SecondActivity";

    private TextView mTvMessage;

    public static void start(Context context) {
        Intent intent = new Intent(context, SecondActivity.class);
        context.startActivity(intent);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        initContentView();
        // 注册订阅者
        EventBus.getDefault().register(this);
    }

    private void initContentView() {
        mTvMessage = findViewById(R.id.tv_second_message);
    }

    @Subscribe(threadMode = ThreadMode.MAIN, sticky = true)
    public void onMessageEvent(MessageEvent event) {
        Log.i(TAG, "message is " + event.getMessage());
        // 更新界面
        mTvMessage.setText(event.getMessage());
        // 移除粘性事件
        EventBus.getDefault().removeStickyEvent(event);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 注销订阅者
        EventBus.getDefault().unregister(this);
    }
}
```

### 7.事件优先级

EventBus支持在定义订阅者方法时指定事件传递的优先级。默认情况下，订阅者方法的事件传递优先级为0。**数值越大，优先级越高**。在相同的线程模式下，更高优先级的订阅者方法将优先接收到事件。**注意**：优先级只有在相同的线程模式下才有效。 

```java
@Subscribe(priority = 1)
public void onMessageEvent(MessageEvent event) {
    ...
}
```

 你可以在高优先级的订阅者方法接收到事件之后取消事件的传递。此时，低优先级的订阅者方法将不会接收到该事件。**注意：** 订阅者方法只有在线程模式为ThreadMode.POSTING时，才可以取消一个事件的传递。 

```java
@Subscribe(threadMode = ThreadMode.POSTING, priority = 1)
public void onMessageEvent(MessageEvent event) {
    ...
    // 取消事件传递
    EventBus.getDefault().cancelEventDelivery(event);
}
```



### 8.订阅者索引



## 三、回调

### 1.什么是回调：

**举个例子：**

某天，我打电话向你请教问题，当然是个难题，你一时想不出解决方法，我又不能拿着电话在那里傻等，于是我们约定：等你想出办法后打手机通知我，这样，我就挂掉电话办其它事情去了。过了XX分钟，我的手机响了，你兴高采烈的说问题已经搞定，应该如此这般处理。

![img](消息传递机制.assets/20150716224805625)

### 2.步骤：

​	①注册回调接口

​	②运行回调函数

### 3.demo

```java
//你类

public class You implements Runnable{
 
     
    private String who;
     private ContactInterface callBack;  
     public You() {
            // TODO Auto-generated constructor stub
     }
      
    //调用此方法就表示有人联系你了，注册到你这来
     public void setCallBack(String who,String question,ContactInterface callBack) {
         this.who = who;    
         System.out.println("你说：当前联系到我的人是"+who+"，问题是"+question);
         this.callBack =callBack;
     }
        
     public void handleThings(){
         //假如你现在正在想问题的答案，需要一点时间
         for(int i=0;i<100000;i++){  
               if(i == 0){
                   System.out.println("你正在思考问题.....");
               }
         }
          
         String answer = "答案是A";
         //想到问题的办法了
         System.out.println("你说：想到答案了，准备打回去给"+who+"告诉他答案");
         callBack.callBackByTel(answer);
     }
 
    /* (non-Javadoc)
     * @see java.lang.Runnable#run()
     */
    @Override
    public void run() {
        try {
            Thread.sleep(1000);
            handleThings();
        } catch (Exception e) {
            e.printStackTrace();
        }
    } 
}


//我类

public class Me {
 
     public static void main(String[] args){  
          
         Me me = new Me();
         me.hasQuestion();
          
     }
      
     private void hasQuestion(){
         //现在有问题想不出来答案，想去问你
         You you = new You();
         //进行注册
         you.setCallBack("蜗牛", "某道题答案是什么？", new ContactInterface() {
             
            @Override
            public void callBackByTel(String answer) {
                System.out.println("我说：嗯，好的，我收到答案了:"+answer+"，谢谢");
                 
            }
        });
        //你接到电话，起床开始思考问题
        new Thread(you).start();
     }
}

//接口类
public interface ContactInterface {
     
    public void callBackByTel(String answer);
     
}
```

验证结果：
你说：当前联系到我的人是蜗牛，问题是某道题答案是什么？
你正在思考问题
你说：想到问题了，准备打回去给蜗牛告诉他答案
我说：嗯，好的，我收到答案了：答案是A，谢谢